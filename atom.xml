<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>G-SS-Hacker</title>
  
  <subtitle>---A Cyber Driver---</subtitle>
  <link href="/G-SS-Hacker.github.io/atom.xml" rel="self"/>
  
  <link href="https://g-ss-hacker.github.io/"/>
  <updated>2020-01-28T06:43:43.036Z</updated>
  <id>https://g-ss-hacker.github.io/</id>
  
  <author>
    <name>G-SS-Hacker</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面向对象绪论</title>
    <link href="https://g-ss-hacker.github.io/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%AA%E8%AE%BA/"/>
    <id>https://g-ss-hacker.github.io/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%AA%E8%AE%BA/</id>
    <published>2020-01-28T06:25:40.000Z</published>
    <updated>2020-01-28T06:43:43.036Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1580203723216&amp;di=8aed87a08dfaee482cb60caaaed0998a&amp;imgtype=0&amp;src=http%3A%2F%2F01.minipic.eastday.com%2F20170705%2F20170705072438_f5cc5771dd19389bacdba25fcfa1ee80_4.jpeg" alt></p><h1 id="面向对象绪论"><a href="#面向对象绪论" class="headerlink" title="面向对象绪论"></a>面向对象绪论</h1><blockquote><p>图：歼15航母降落</p></blockquote><p><font color="grey"> <em>Guderian出品</em> </font></p><h2 id="面向对象的基本概念"><a href="#面向对象的基本概念" class="headerlink" title="面向对象的基本概念"></a>面向对象的基本概念</h2><ul><li>类 Class</li><li>对象 Object</li></ul><blockquote><p>浅显理解：类是抽象的对象，对象是具体的类</p></blockquote><h2 id="概念之间的互用"><a href="#概念之间的互用" class="headerlink" title="概念之间的互用"></a>概念之间的互用</h2><ul><li>属性 Attribute == 数据 Data == 状态 State == 信息 Information</li><li>操作 Operation == 方法 Method == 行为 Behavior == 职责 Responsibility</li><li>对象 Object == 实例 Instance</li></ul><h2 id="面向对象的核心特征"><a href="#面向对象的核心特征" class="headerlink" title="面向对象的核心特征"></a>面向对象的核心特征</h2><ul><li>封装 Encapsulation</li><li>继承 Inheritance</li><li>多态 Polymorphism</li><li>聚合/组合 Aggregation / Composition</li><li>接口/实现 Interface / Implementation</li><li>抽象 Abstraction</li></ul><h3 id="封装-Encapsulation"><a href="#封装-Encapsulation" class="headerlink" title="封装 Encapsulation"></a>封装 Encapsulation</h3><blockquote><p>是指隐藏对象的属性和实现细节，仅对外提供公共访问方式</p></blockquote><ol><li><strong>封装什么？</strong></li></ol><ul><li>内部的、不想让其他人随意了解的信息</li><li>类的属性 Attribute</li><li>类的方法 Method</li></ul><ol><li><strong>为什么要封装？</strong></li></ol><ul><li>保护隐私</li><li>保护数据安全</li><li>隔离复杂度</li></ul><ol><li><strong>面向对象的封装有四种方式</strong></li></ol><ul><li>Public</li><li>Private</li><li>Protected</li><li>Package</li></ul><h3 id="继承-Inheritance"><a href="#继承-Inheritance" class="headerlink" title="继承 Inheritance"></a>继承 Inheritance</h3><blockquote><p>一个类从其他类获得它的状态和行为，同时还可以加上自己额外的状态和行为</p></blockquote><p>父类中的属性和方法，在子类中可以重复使用，子类就不需要再定义了，这样即可实现代码的可重用性。如以下类图例子，定义类<code>C1Dobject</code>一维物体，它有一个属性<code>x</code>对应x轴上的一个坐标，两个方法<code>getx()</code>和<code>setx(int)</code>分别表示x坐标的获取和设置。如果我们需要定义二维物体，就没有必要把x坐标重复定义。我们在类<code>C1Dobject</code>的基础上派生出子类<code>C2Dobject</code>，只需再定义属性<code>y</code>和方法<code>gety()</code>及<code>sety(int)</code>就可以完整地抽象出一个二维物体；类似地，如果我们需要定义三维物体，没有必要把x坐标、y坐标重复定义，只需再类<code>C2Dobject</code>的基础上派生出子类<code>C3Dobject</code>，再定义属性<code>z</code>和方法<code>getz()</code>及<code>setz(int)</code>即可。显而易见，继承提高了代码的可重用性，减少了创建类的工作量。</p><p><img src="http://www.plantuml.com/plantuml/png/SoWkIImgAStDuN8sTCbFoafDBb6mgT7LLN0sWdAv82o4X35CWYiv9x6uM06XiPfBeK8XCw-4Io4zjQH2GnF2BWQnWInDhbgu5YCaBPLmBPL8MYhHjHWZQQc2Qwb2qb85q-AGcfS2z180" alt></p><p>以上类图对应的<code>C++</code>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1Dobject</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getx</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setx</span><span class="params">(<span class="keyword">int</span> xPrime)</span> </span>&#123; x = xPrime; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2Dobject</span>:</span> <span class="keyword">public</span> C1Dobject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gety</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sety</span><span class="params">(<span class="keyword">int</span> yPrime)</span> </span>&#123; y = yPrime; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C3Dobject</span>:</span> <span class="keyword">public</span> C2Dobject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> z = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getz</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> z; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setz</span><span class="params">(<span class="keyword">int</span> zPrime)</span> </span>&#123; z = zPrime; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="多态-Polymorphism"><a href="#多态-Polymorphism" class="headerlink" title="多态 Polymorphism"></a>多态 Polymorphism</h3><blockquote><p>使用指向父类的指针或者引用，能够调用子类的对象</p></blockquote><p>结论：</p><ol><li>当一个类从另一个类继承而来，多态使得子类可以代替父类</li><li>消息发送方不需要知道消息接收方属于哪一个子类</li><li><font color="red">同一类族</font>的接收者可以按自己的方式处理消息</li></ol><p>如以下类图例子，定义形状<code>CShape</code>作为父类，派生出矩形<code>CRectangle</code>和三角形<code>CTriangle</code>。现在假设我们知道一个图形<code>shape</code>，希望获取它的面积，而我们并不需要知道它的具体形状（属于哪一个子类），只需要确保<code>shape</code>所属的类在<code>CShape</code>的类组下即可。图形<code>shape</code>的面积可以通过调用函数<code>area()</code>实现。</p><p><img src="http://www.plantuml.com/plantuml/png/SoWkIImgAStDuN8EpaWiI5MmgT7LLN0EIaqkISnBpqb55GufoeI8SYNd91ONAq0bgxaKoZDJIZ8KClDAk1GoKZFJCqeWxCIYr4GDJJ2xbiiXDIy5Q1C0" alt></p><p><code>C++</code>中多态的实现涉及<strong>静态多态</strong>和<strong>动态多态</strong>以及<strong>虚函数</strong>的使用，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CShape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> width, height;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CShape(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>) &#123; width = a, height = b; &#125;</span><br><span class="line"><span class="comment">//纯虚函数，具体功能在子类中实现</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">area</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CRectangle</span>:</span> <span class="keyword">public</span> CShape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//显式调用父类的构造函数</span></span><br><span class="line">CRectangle( <span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>): CShape(a, b) &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"CRectangle area calls: "</span>;</span><br><span class="line"><span class="keyword">return</span> width * height;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTriangle</span>:</span> <span class="keyword">public</span> CShape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//显式调用父类的构造函数</span></span><br><span class="line">CTriangle( <span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>): CShape(a, b) &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"CTriangle area calls: "</span>;</span><br><span class="line"><span class="keyword">return</span> width * height / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CShape *ptr;</span><br><span class="line"><span class="function">CRectangle <span class="title">rect</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">CTriangle  <span class="title">tri</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取矩形的面积</span></span><br><span class="line">ptr = &amp;rect;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ptr-&gt;area() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取三角形的面积</span></span><br><span class="line">ptr = &amp;tri;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ptr-&gt;area() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>C++</code>中构成多态需要满足两个条件：</p><ol><li>调用函数的对象须是<strong>指针</strong>或<strong>引用</strong></li><li>被调用的函数须是<strong>重写</strong><sup><a href="#fn_ 1" id="reffn_ 1"> 1</a></sup>的<strong>虚函数</strong><sup><a href="#fn_ 2" id="reffn_ 2"> 2</a></sup></li></ol><h3 id="聚合-组合-Aggregation-Composition"><a href="#聚合-组合-Aggregation-Composition" class="headerlink" title="聚合/组合 Aggregation / Composition"></a>聚合/组合 Aggregation / Composition</h3><h4 id="聚合-Aggregation"><a href="#聚合-Aggregation" class="headerlink" title="聚合 Aggregation"></a>聚合 Aggregation</h4><blockquote><p>A has B，B是A的一部分，但A不控制B的生命周期</p></blockquote><p>如：学校由学生组成，那么学校与学生是聚合关系</p><p><code>UML</code>图中聚合关系的符号如下图</p><p><img src="https://s.plantuml.com/sym03.png" alt></p><h4 id="组合-Composition"><a href="#组合-Composition" class="headerlink" title="组合 Composition"></a>组合 Composition</h4><blockquote><p>A has B，B是A的一部分，且A控制B的生命周期</p></blockquote><p>如：树由树叶组成，那么树与树叶是组合关系</p><p><code>UML</code>图中聚合关系的符号如下图</p><p><img src="https://s.plantuml.com/sym01.png" alt></p><h3 id="接口-实现-Interface-Implementation"><a href="#接口-实现-Interface-Implementation" class="headerlink" title="接口/实现 Interface / Implementation"></a>接口/实现 Interface / Implementation</h3><h4 id="接口-Interface"><a href="#接口-Interface" class="headerlink" title="接口 Interface"></a>接口 Interface</h4><blockquote><p>描述一个类的用户如何与这个类交互</p></blockquote><h4 id="实现-Implementation"><a href="#实现-Implementation" class="headerlink" title="实现 Implementation"></a>实现 Implementation</h4><blockquote><p>完成接口所定义的功能，如类、构建等完成的任务</p></blockquote><p>如电视机、插座、发电厂的关系如何呢？</p><p><img src="http://www.plantuml.com/plantuml/png/SoWkIImgAStDuKhEIImkLWZEJyvEBL6miSdCAqajIajCJhMpume9Kz3JiuFASS6KrEZfAGJabwSM1UGavfLmEQJcfG3D0G00" alt></p><ul><li>电视机是用户 client</li><li>插座是接口 Interface</li><li>发电厂是实现 Implementation</li></ul><h3 id="抽象-Abstraction"><a href="#抽象-Abstraction" class="headerlink" title="抽象 Abstraction"></a>抽象 Abstraction</h3><blockquote><p>抽取具体客观事物的共性</p></blockquote><p>抽象是面向对象领域<font color="red">发现类</font>的主要方法</p><p>（所谓抽象，玄之又玄，众妙之门）</p><hr><blockquote id="fn_ 1"><sup> 1</sup>. 重写：函数重写必须函数名一致、参数一致、返回值一致<a href="#reffn_ 1" title="Jump back to footnote [ 1] in the text."> &#8617;</a></blockquote><blockquote id="fn_ 2"><sup> 2</sup>. 虚函数：在类的成员函数前加<code>virtual</code>关键字<a href="#reffn_ 2" title="Jump back to footnote [ 2] in the text."> &#8617;</a></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1580203723216&amp;amp;di=8aed87a08dfaee482cb60caaae
      
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="C-plus-plus" scheme="https://G-SS-Hacker.github.io/tags/C-plus-plus/"/>
    
      <category term="面向对象" scheme="https://G-SS-Hacker.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="软件工程" scheme="https://G-SS-Hacker.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>二次曲面</title>
    <link href="https://g-ss-hacker.github.io/%E4%BA%8C%E6%AC%A1%E6%9B%B2%E9%9D%A2/"/>
    <id>https://g-ss-hacker.github.io/%E4%BA%8C%E6%AC%A1%E6%9B%B2%E9%9D%A2/</id>
    <published>2019-12-27T09:17:43.000Z</published>
    <updated>2020-01-25T13:16:10.891Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/12/27/emE71j6LgFIMouW.jpg" alt></p><h1 id="二次曲面"><a href="#二次曲面" class="headerlink" title="二次曲面"></a>二次曲面</h1><blockquote><p>图：Watch Dog 2 by Ubisoft</p></blockquote><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><br>1.椭圆柱面<p></p><script type="math/tex; mode=display">\frac{x^2}{a^2}+\frac{y^2}{b^2}=1</script><p><img src="https://i.loli.net/2019/12/27/Hwvx1keWTuFSYst.png" alt></p><p>2.双曲柱面</p><script type="math/tex; mode=display">\frac{x^2}{a^2}-\frac{y^2}{b^2}=1</script><p><img src="https://i.loli.net/2019/12/27/PwFeypDxlEtRCBH.png" alt></p><p>3.抛物柱面</p><script type="math/tex; mode=display">x^2=2py,(p\ne 0)</script><p><img src="https://i.loli.net/2019/12/27/45RbcKSEJg6mzd8.png" alt></p><p>4.椭球面</p><script type="math/tex; mode=display">\frac{x^2}{a^2}+\frac{y^2}{b^2}+\frac{z^2}{c^2}=1</script><p><img src="https://i.loli.net/2019/12/27/EfLtb1HT73QlpuF.png" alt></p><p>5.单叶双曲面</p><script type="math/tex; mode=display">\frac{x^2}{a^2}+\frac{y^2}{b^2}-\frac{z^2}{c^2}=1</script><p><img src="https://i.loli.net/2019/12/27/F1US2Bg5wjTlb4p.png" alt></p><p>6.双叶双曲面</p><script type="math/tex; mode=display">\frac{x^2}{a^2}-\frac{y^2}{b^2}-\frac{z^2}{c^2}=1</script><p><img src="https://i.loli.net/2019/12/27/FvlP6Zc7On82jBh.png" alt></p><p>7.椭圆抛物面</p><script type="math/tex; mode=display">\frac{x^2}{2p}+\frac{y^2}{2q}=z,(p,q同号)</script><p><img src="https://i.loli.net/2019/12/27/iDJsOL9dQHUpM5g.png" alt></p><p>8.双曲抛物面</p><script type="math/tex; mode=display">\frac{x^2}{2p}-\frac{y^2}{2q}=z,(p,q同号)</script><p>变种：</p><script type="math/tex; mode=display">x^2-y^2=z</script><p><img src="https://i.loli.net/2019/12/27/q5RrWazfgbGyCNV.png" alt></p><p>9.二次锥面</p><script type="math/tex; mode=display">\frac{x^2}{a^2}+\frac{y^2}{b^2}+\frac{z^2}{c^2}=0</script><p><img src="https://i.loli.net/2019/12/27/xWD9suRyaVKtgLj.png" alt></p><a id="more"></a><hr><p>~<font color="#FF7F27"><strong>我们遇到什么困难也不要怕，微笑着面对它！消除恐惧的最好办法就是面对恐惧！坚持就是胜利！加油！奥利给！</strong></font>~</p><font color="#407600">【其他文章·微积分·线性代数】</font><ul><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/不定积分公式/">不定积分公式</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/常用泰勒展开式/">常用泰勒展开式</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/高阶求导公式/">高阶求导公式</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/高等数学公式/">高等数学公式</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/常用等价无穷小/">常用等价无穷小</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/导数基本公式/">导数基本公式</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/矩阵章节总结/">矩阵章节总结</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/行列式章节总结/">行列式章节总结</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/线性方程组章节总结/">线性方程组章节总结</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/27/emE71j6LgFIMouW.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;二次曲面&quot;&gt;&lt;a href=&quot;#二次曲面&quot; class=&quot;headerlink&quot; title=&quot;二次曲面&quot;&gt;&lt;/a&gt;二次曲面&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;图：Watch Dog 2 by Ubisoft&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;br&gt;1.椭圆柱面&lt;p&gt;&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\frac{x^2}{a^2}+\frac{y^2}{b^2}=1&lt;/script&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/27/Hwvx1keWTuFSYst.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;2.双曲柱面&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\frac{x^2}{a^2}-\frac{y^2}{b^2}=1&lt;/script&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/27/PwFeypDxlEtRCBH.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;3.抛物柱面&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
x^2=2py,(p\ne 0)&lt;/script&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/27/45RbcKSEJg6mzd8.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;4.椭球面&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\frac{x^2}{a^2}+\frac{y^2}{b^2}+\frac{z^2}{c^2}=1&lt;/script&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/27/EfLtb1HT73QlpuF.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;5.单叶双曲面&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\frac{x^2}{a^2}+\frac{y^2}{b^2}-\frac{z^2}{c^2}=1&lt;/script&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/27/F1US2Bg5wjTlb4p.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;6.双叶双曲面&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\frac{x^2}{a^2}-\frac{y^2}{b^2}-\frac{z^2}{c^2}=1&lt;/script&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/27/FvlP6Zc7On82jBh.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;7.椭圆抛物面&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\frac{x^2}{2p}+\frac{y^2}{2q}=z,(p,q同号)&lt;/script&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/27/iDJsOL9dQHUpM5g.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;8.双曲抛物面&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\frac{x^2}{2p}-\frac{y^2}{2q}=z,(p,q同号)&lt;/script&gt;&lt;p&gt;变种：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
x^2-y^2=z&lt;/script&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/27/q5RrWazfgbGyCNV.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;9.二次锥面&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\frac{x^2}{a^2}+\frac{y^2}{b^2}+\frac{z^2}{c^2}=0&lt;/script&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/27/xWD9suRyaVKtgLj.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="线性代数" scheme="https://G-SS-Hacker.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>面向对象设计七大原则</title>
    <link href="https://g-ss-hacker.github.io/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    <id>https://g-ss-hacker.github.io/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/</id>
    <published>2019-12-12T15:07:33.000Z</published>
    <updated>2019-12-12T15:10:10.887Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/12/12/nuhOlgtVX1asp7B.jpg" alt></p><h1 id="面向对象设计七大原则"><a href="#面向对象设计七大原则" class="headerlink" title="面向对象设计七大原则"></a>面向对象设计七大原则</h1><blockquote><p>图：北京航空航天大学</p></blockquote><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><p></p><blockquote><p>AKA：设计模式七大原则</p></blockquote><p><strong>1. 单一职责原则</strong></p><ul><li>SRP，Single Responsibility Principle</li><li>每一个对象有且只有一个职责，从而实现”高内聚、低耦合“</li><li>防止一个类实现多个功能，改变一个功能后影响其他功能的正常运作</li></ul><p><strong>2. 开放-封闭原则</strong></p><ul><li>OCP，Open-Closed Principle</li><li>对拓展开放、对修改关闭</li><li>需要对程序进行拓展的时候，不能修改原有代码，只能在原有代码的基础上添加</li></ul><p><strong>3. 李氏替换原则</strong></p><ul><li>LSP，Liskov Substitution Principle</li><li>任何基类出现的地方，一定可以用派生类代替</li><li>派生类可以拓展基类的功能，但不能改变基类的功能</li></ul><p><strong>4. 依赖倒置原则</strong></p><ul><li>DIP，Dependence Inversion Principle</li><li>实现依赖于抽象，而抽象不依赖于实现</li><li>解除高层组件对低层组件的依赖，是实现开闭原则的重要基础</li></ul><p><strong>5. 接口隔离原则</strong></p><ul><li>ISP，Interface Segregation Principle</li><li>一个类对另外一个类的依赖性应当是建立在最小的接口上</li><li>在特定的使用场合给特定用户提供其需要的方法、屏蔽其不需要的方法</li></ul><p><strong>6. 组合重用原则</strong></p><ul><li>CRP, Composite Reuse Principle,</li><li>尽量使用组合，尽量不用继承</li><li>在新的对象里面使用已有的对象，使之成为新的对象的一部分</li></ul><p><strong>7. 迪米特原则</strong></p><ul><li>LoD，Law of Demeter</li><li>一个对象应该对其他对象又尽可能少的了解</li><li>尽量降低成员的访问权限，提供访问器而不公开成员变量</li></ul><hr><a id="more"></a><blockquote><p>注：<code>C++</code>中只有抽象类的概念，<code>JAVA</code>中既有抽象类的概念，又有接口的概念。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/12/nuhOlgtVX1asp7B.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;面向对象设计七大原则&quot;&gt;&lt;a href=&quot;#面向对象设计七大原则&quot; class=&quot;headerlink&quot; title=&quot;面向对象设计七大原则&quot;&gt;&lt;/a&gt;面向对象设计七大原则&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;图：北京航空航天大学&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;AKA：设计模式七大原则&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;1. 单一职责原则&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SRP，Single Responsibility Principle&lt;/li&gt;
&lt;li&gt;每一个对象有且只有一个职责，从而实现”高内聚、低耦合“&lt;/li&gt;
&lt;li&gt;防止一个类实现多个功能，改变一个功能后影响其他功能的正常运作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2. 开放-封闭原则&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OCP，Open-Closed Principle&lt;/li&gt;
&lt;li&gt;对拓展开放、对修改关闭&lt;/li&gt;
&lt;li&gt;需要对程序进行拓展的时候，不能修改原有代码，只能在原有代码的基础上添加&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;3. 李氏替换原则&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LSP，Liskov Substitution Principle&lt;/li&gt;
&lt;li&gt;任何基类出现的地方，一定可以用派生类代替&lt;/li&gt;
&lt;li&gt;派生类可以拓展基类的功能，但不能改变基类的功能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;4. 依赖倒置原则&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DIP，Dependence Inversion Principle&lt;/li&gt;
&lt;li&gt;实现依赖于抽象，而抽象不依赖于实现&lt;/li&gt;
&lt;li&gt;解除高层组件对低层组件的依赖，是实现开闭原则的重要基础&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;5. 接口隔离原则&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ISP，Interface Segregation Principle&lt;/li&gt;
&lt;li&gt;一个类对另外一个类的依赖性应当是建立在最小的接口上&lt;/li&gt;
&lt;li&gt;在特定的使用场合给特定用户提供其需要的方法、屏蔽其不需要的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;6. 组合重用原则&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CRP, Composite Reuse Principle,&lt;/li&gt;
&lt;li&gt;尽量使用组合，尽量不用继承&lt;/li&gt;
&lt;li&gt;在新的对象里面使用已有的对象，使之成为新的对象的一部分&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;7. 迪米特原则&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LoD，Law of Demeter&lt;/li&gt;
&lt;li&gt;一个对象应该对其他对象又尽可能少的了解&lt;/li&gt;
&lt;li&gt;尽量降低成员的访问权限，提供访问器而不公开成员变量&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="面向对象" scheme="https://G-SS-Hacker.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="软件工程" scheme="https://G-SS-Hacker.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++引用</title>
    <link href="https://g-ss-hacker.github.io/C-%E5%BC%95%E7%94%A8/"/>
    <id>https://g-ss-hacker.github.io/C-%E5%BC%95%E7%94%A8/</id>
    <published>2019-12-07T02:51:15.000Z</published>
    <updated>2020-01-25T12:47:04.085Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/12/07/Xua6pB154KjyqiL.jpg" alt></p><h1 id="C-引用"><a href="#C-引用" class="headerlink" title="C++引用"></a>C++引用</h1><blockquote><p>图：LEGO小人仔</p></blockquote><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><p></p><font color="#FF7F27">笔记整理自《北京大学公开课：C++面向对象程序设计》</font><blockquote><p><code>C++</code>跟<code>C</code>相比，多了很多独特的内容，其中有很多都是为了实现面向对象编程范式而引入的，<code>C++</code>的引用就是其一。</p></blockquote><h2 id="引用的概念"><a href="#引用的概念" class="headerlink" title="引用的概念"></a>引用的概念</h2><ul><li>定义一个引用，并将其初始化为引用某个变量的通用写法：<code>类型名 &amp; 引用名 = 某变量名</code></li><li>某个变量的引用，<font color="red">等价于</font>这个变量，相当于该变量的一个别名</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> &amp; r = n;</span><br><span class="line"><span class="comment">//r引用了n，r的类型是int &amp;</span></span><br><span class="line">r = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; r;<span class="comment">//输出4</span></span><br><span class="line">cour &lt;&lt; n;<span class="comment">//输出4</span></span><br><span class="line">n = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; n;</span><br></pre></td></tr></table></figure><ul><li>定义引用时一定要将其<font color="red">初始化</font>成引用某个变量，而不像指针可以指向某个变量也可以不指向某个变量</li><li>初始化后，它就一直引用该变量，不会再引用别的变量了（引用是从一而终的）</li><li>引用只能引用<font color="red">变量</font>，不能引用常量和表达式</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> a = <span class="number">3</span>, b = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">double</span> &amp; r1 = a;</span><br><span class="line"><span class="keyword">double</span> &amp; r2 = r1;<span class="comment">//r2也引用a</span></span><br><span class="line">r2 = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//输出10</span></span><br><span class="line">r1 = b;<span class="comment">//r1并没有引用b</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//输出5</span></span><br></pre></td></tr></table></figure><h2 id="引用的应用"><a href="#引用的应用" class="headerlink" title="引用的应用"></a>引用的应用</h2><p><code>C</code>中，如何编写交换两个整型变量值的函数?</p><ul><li>这样写吗？</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    tmp = a; a = b; b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n1, n2;</span><br><span class="line">swap(n1, n2);</span><br><span class="line"><span class="comment">//n1, n2的值没有被交换</span></span><br></pre></td></tr></table></figure><p>这是错误的，改变形参不会改变实参。</p><ul><li>或者用指针？</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    tmp = *a; *a = *b; *b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n1, n2;</span><br><span class="line">swap(&amp; n1, &amp; n2);<span class="comment">//取地址</span></span><br><span class="line"><span class="comment">//n1, n2的值被交换</span></span><br></pre></td></tr></table></figure><p>正确，但丑陋！</p><p>那么<code>C++</code>中，如何编写交换两个整型变量值的函数?</p><h3 id="引用作为参数"><a href="#引用作为参数" class="headerlink" title="引用作为参数"></a>引用作为参数</h3><blockquote><p><code>C++</code>示例：交换两个整数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp; a, <span class="keyword">int</span> &amp; b)</span><span class="comment">//a就是n1，b就是n2</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    tmp = a; a = b; b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n1, n2;</span><br><span class="line">swap(n1, n2);</span><br><span class="line"><span class="comment">//n1, n2的值被交换</span></span><br></pre></td></tr></table></figure><h3 id="引用作为返回值"><a href="#引用作为返回值" class="headerlink" title="引用作为返回值"></a>引用作为返回值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp; <span class="title">SetValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//神奇之处，对函数的返回值进行赋值</span></span><br><span class="line">    SetValue() = <span class="number">40</span>;</span><br><span class="line">    <span class="comment">//然而它究竟有什么作用呢？我还没想好...</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n;</span><br><span class="line">    <span class="comment">//输出：40</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意被引用的对象<font color="red">不能超过作用域</font>，返回一个<strong>局部变量</strong>的引用是不合法的，但是，可以返回一个<strong>静态类型变量</strong>的引用。</p><h2 id="常引用"><a href="#常引用" class="headerlink" title="常引用"></a>常引用</h2><p>定义引用时，在前面加<code>const</code>关键字即为“常引用”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp; r = n;</span><br></pre></td></tr></table></figure><font color="red">注意不能通过常引用去修改其引用的内容！</font><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp; r = n;</span><br><span class="line">r = <span class="number">200</span>;<span class="comment">//err</span></span><br><span class="line">n = <span class="number">300</span>;<span class="comment">//ok</span></span><br></pre></td></tr></table></figure><h2 id="常引用和非常引用的转换"><a href="#常引用和非常引用的转换" class="headerlink" title="常引用和非常引用的转换"></a>常引用和非常引用的转换</h2><ul><li><code>const T &amp;</code><font color="red">和</font><code>T &amp;</code><font color="red">是不同的类型</font>（千万要注意！！！）</li><li><code>T &amp;</code>类型的引用或<code>T</code>类型的变量可以用来初始化<code>const T &amp;</code>类型的引用</li><li><code>const T</code>类型的常变量和<code>const T &amp;</code>类型的引用则不能用来初始化<code>T &amp;</code>类型的引用，除非进行<strong>强制类型转换</strong></li></ul><a id="more"></a><hr><blockquote><p>参考并整理自《C++面向对象设计》郭炜，北京大学，感谢原作者！编辑时有删改</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/07/Xua6pB154KjyqiL.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;C-引用&quot;&gt;&lt;a href=&quot;#C-引用&quot; class=&quot;headerlink&quot; title=&quot;C++引用&quot;&gt;&lt;/a&gt;C++引用&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;图：LEGO小人仔&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;font color=&quot;#FF7F27&quot;&gt;笔记整理自《北京大学公开课：C++面向对象程序设计》&lt;/font&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;C++&lt;/code&gt;跟&lt;code&gt;C&lt;/code&gt;相比，多了很多独特的内容，其中有很多都是为了实现面向对象编程范式而引入的，&lt;code&gt;C++&lt;/code&gt;的引用就是其一。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;引用的概念&quot;&gt;&lt;a href=&quot;#引用的概念&quot; class=&quot;headerlink&quot; title=&quot;引用的概念&quot;&gt;&lt;/a&gt;引用的概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;定义一个引用，并将其初始化为引用某个变量的通用写法：&lt;code&gt;类型名 &amp;amp; 引用名 = 某变量名&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;某个变量的引用，&lt;font color=&quot;red&quot;&gt;等价于&lt;/font&gt;这个变量，相当于该变量的一个别名&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n = &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &amp;amp; r = n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//r引用了n，r的类型是int &amp;amp;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;r = &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; r;	&lt;span class=&quot;comment&quot;&gt;//输出4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cour &amp;lt;&amp;lt; n;	&lt;span class=&quot;comment&quot;&gt;//输出4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;n = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; n;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;定义引用时一定要将其&lt;font color=&quot;red&quot;&gt;初始化&lt;/font&gt;成引用某个变量，而不像指针可以指向某个变量也可以不指向某个变量&lt;/li&gt;
&lt;li&gt;初始化后，它就一直引用该变量，不会再引用别的变量了（引用是从一而终的）&lt;/li&gt;
&lt;li&gt;引用只能引用&lt;font color=&quot;red&quot;&gt;变量&lt;/font&gt;，不能引用常量和表达式&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, b = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; &amp;amp; r1 = a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; &amp;amp; r2 = r1;	&lt;span class=&quot;comment&quot;&gt;//r2也引用a&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;r2 = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;	&lt;span class=&quot;comment&quot;&gt;//输出10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;r1 = b;				&lt;span class=&quot;comment&quot;&gt;//r1并没有引用b&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;	&lt;span class=&quot;comment&quot;&gt;//输出5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;引用的应用&quot;&gt;&lt;a href=&quot;#引用的应用&quot; class=&quot;headerlink&quot; title=&quot;引用的应用&quot;&gt;&lt;/a&gt;引用的应用&lt;/h2&gt;&lt;p&gt;&lt;code&gt;C&lt;/code&gt;中，如何编写交换两个整型变量值的函数?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这样写吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; tmp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    tmp = a; a = b; b = tmp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n1, n2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;swap(n1, n2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//n1, n2的值没有被交换&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这是错误的，改变形参不会改变实参。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;或者用指针？&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *a, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *b)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; tmp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    tmp = *a; *a = *b; *b = tmp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n1, n2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;swap(&amp;amp; n1, &amp;amp; n2);	&lt;span class=&quot;comment&quot;&gt;//取地址&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//n1, n2的值被交换&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;正确，但丑陋！&lt;/p&gt;
&lt;p&gt;那么&lt;code&gt;C++&lt;/code&gt;中，如何编写交换两个整型变量值的函数?&lt;/p&gt;
&lt;h3 id=&quot;引用作为参数&quot;&gt;&lt;a href=&quot;#引用作为参数&quot; class=&quot;headerlink&quot; title=&quot;引用作为参数&quot;&gt;&lt;/a&gt;引用作为参数&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;C++&lt;/code&gt;示例：交换两个整数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &amp;amp; a, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &amp;amp; b)&lt;/span&gt;	&lt;span class=&quot;comment&quot;&gt;//a就是n1，b就是n2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; tmp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    tmp = a; a = b; b = tmp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n1, n2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;swap(n1, n2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//n1, n2的值被交换&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;引用作为返回值&quot;&gt;&lt;a href=&quot;#引用作为返回值&quot; class=&quot;headerlink&quot; title=&quot;引用作为返回值&quot;&gt;&lt;/a&gt;引用作为返回值&lt;/h3&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n = &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &amp;amp; &lt;span class=&quot;title&quot;&gt;SetValue&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; n; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//神奇之处，对函数的返回值进行赋值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SetValue() = &lt;span class=&quot;number&quot;&gt;40&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//然而它究竟有什么作用呢？我还没想好...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//输出：40&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注意被引用的对象&lt;font color=&quot;red&quot;&gt;不能超过作用域&lt;/font&gt;，返回一个&lt;strong&gt;局部变量&lt;/strong&gt;的引用是不合法的，但是，可以返回一个&lt;strong&gt;静态类型变量&lt;/strong&gt;的引用。&lt;/p&gt;
&lt;h2 id=&quot;常引用&quot;&gt;&lt;a href=&quot;#常引用&quot; class=&quot;headerlink&quot; title=&quot;常引用&quot;&gt;&lt;/a&gt;常引用&lt;/h2&gt;&lt;p&gt;定义引用时，在前面加&lt;code&gt;const&lt;/code&gt;关键字即为“常引用”。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &amp;amp; r = n;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;font color=&quot;red&quot;&gt;注意不能通过常引用去修改其引用的内容！&lt;/font&gt;

&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &amp;amp; r = n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;r = &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;;	&lt;span class=&quot;comment&quot;&gt;//err&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;n = &lt;span class=&quot;number&quot;&gt;300&lt;/span&gt;;	&lt;span class=&quot;comment&quot;&gt;//ok&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;常引用和非常引用的转换&quot;&gt;&lt;a href=&quot;#常引用和非常引用的转换&quot; class=&quot;headerlink&quot; title=&quot;常引用和非常引用的转换&quot;&gt;&lt;/a&gt;常引用和非常引用的转换&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;const T &amp;amp;&lt;/code&gt;&lt;font color=&quot;red&quot;&gt;和&lt;/font&gt;&lt;code&gt;T &amp;amp;&lt;/code&gt;&lt;font color=&quot;red&quot;&gt;是不同的类型&lt;/font&gt;（千万要注意！！！）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;T &amp;amp;&lt;/code&gt;类型的引用或&lt;code&gt;T&lt;/code&gt;类型的变量可以用来初始化&lt;code&gt;const T &amp;amp;&lt;/code&gt;类型的引用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const T&lt;/code&gt;类型的常变量和&lt;code&gt;const T &amp;amp;&lt;/code&gt;类型的引用则不能用来初始化&lt;code&gt;T &amp;amp;&lt;/code&gt;类型的引用，除非进行&lt;strong&gt;强制类型转换&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="OOP" scheme="https://G-SS-Hacker.github.io/tags/OOP/"/>
    
      <category term="C-plus-plus" scheme="https://G-SS-Hacker.github.io/tags/C-plus-plus/"/>
    
      <category term="面向对象" scheme="https://G-SS-Hacker.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++继承和派生</title>
    <link href="https://g-ss-hacker.github.io/C-%E7%BB%A7%E6%89%BF%E5%92%8C%E6%B4%BE%E7%94%9F/"/>
    <id>https://g-ss-hacker.github.io/C-%E7%BB%A7%E6%89%BF%E5%92%8C%E6%B4%BE%E7%94%9F/</id>
    <published>2019-12-06T13:51:21.000Z</published>
    <updated>2019-12-07T02:50:27.918Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/12/06/QYrjln.jpg" alt></p><h1 id="C-继承和派生"><a href="#C-继承和派生" class="headerlink" title="C++继承和派生"></a>C++继承和派生</h1><blockquote><p>图：亲爱的、古老的地球</p></blockquote><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><p></p><font color="#FF7F27">本文整理自《北京大学公开课：C++面向对象程序设计》</font><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><font color="font">继承</font>和<font color="red">派生</font>实际上是一回事：在定义一个新的类<code>B</code>时，如果该类与某个已有的类<code>A</code>相似（指的是<code>B</code>拥有<code>A</code>的全部特点），那么可以把<code>A</code>作为一个<strong>基类</strong>，而把<code>B</code>作为<strong>基类</strong>的一个<strong>派生类</strong>（也称<strong>子类</strong>），这使得创建和维护一个程序更加容易</li><li><strong>派生类</strong>拥有<strong>基类</strong>的全部特点，派生类还可以对<strong>基类</strong>进行修改和扩充。在<strong>派生类</strong>中，可以扩充新的成员变量和成员函数</li><li><strong>派生类</strong>一经定义，可以独立使用，定义对象时不依赖于<strong>基类</strong></li><li><strong>派生类</strong>拥有<strong>基类</strong>的全部成员函数和成员变量。不论是<code>private</code>、<code>protected</code>、<code>public</code></li><li>在<strong>派生类</strong>的各个成员函数中，不能访问<strong>基类</strong>的<code>private</code>成员</li></ul><blockquote><p>简单理解成员修饰符<code>protected</code>和<code>private</code>的区别：<code>protected</code>成员在派生类中可以被访问，而<code>private</code>不能</p></blockquote><ul><li>对象不同类型对应的访问权限：</li></ul><div class="table-container"><table><thead><tr><th>类型</th><th>public</th><th>protected</th><th>private</th></tr></thead><tbody><tr><td>本类</td><td>√</td><td>√</td><td>√</td></tr><tr><td>派生类</td><td>√</td><td>√</td><td>×</td></tr><tr><td>其他类</td><td>√</td><td>×</td><td>×</td></tr></tbody></table></div><h2 id="派生类的写法"><a href="#派生类的写法" class="headerlink" title="派生类的写法"></a>派生类的写法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 派生类名:</span> 访问修饰符 基类名<span class="comment">//Zh</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span>-<span class="title">class</span>:</span> access-specifier base-<span class="class"><span class="keyword">class</span>//<span class="title">En</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>访问修饰符</strong>可以是<code>private</code>、<code>protected</code>、<code>public</code>中的一个。如果未使用<strong>访问修饰符</strong>，则默认为<code>private</code>。该访问修饰符规定了<strong>继承类型</strong>。</p><h2 id="继承类型"><a href="#继承类型" class="headerlink" title="继承类型"></a>继承类型</h2><ul><li>公有继承（<code>public</code>）：继承<code>public</code>和<code>protected</code>且类型不变，不继承<code>private</code></li><li>保护继承（<code>protected</code>）：继承<code>public</code>和<code>protected</code>且类型都为<code>protected</code>，不继承<code>private</code></li><li>私有继承（<code>private</code>）：继承<code>public</code>和<code>protected</code>且类型都变为<code>private</code>，不继承<code>private</code></li></ul><p>一般使用公有继承。</p><h2 id="写法示例：学生管理系统"><a href="#写法示例：学生管理系统" class="headerlink" title="写法示例：学生管理系统"></a>写法示例：学生管理系统</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CStudent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> sName;</span><br><span class="line">    <span class="keyword">int</span> nAge;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsThreeGood</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetName</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp; name)</span></span>&#123; sName = name; &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CUndergraduteStudent</span>:</span> <span class="keyword">public</span> CStudent</span><br><span class="line"><span class="comment">//本科生</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> nDepartment;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsThreeGood</span><span class="params">()</span></span>&#123;<span class="comment">/*...*/</span>&#125;;<span class="comment">//覆盖（不是重载！覆盖的参数表不变，重载的参数表改变！）</span></span><br><span class="line"><span class="comment">//名字与基类一样，但行为不一样</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CanBaoYan</span><span class="params">()</span></span>&#123;<span class="comment">/*...*/</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CGraduatedStudent</span>:</span> <span class="keyword">public</span> CStudent</span><br><span class="line"><span class="comment">//研究生</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> nDepartment;</span><br><span class="line"><span class="keyword">char</span> szMentorName[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CountSalary</span><span class="params">()</span></span>&#123;<span class="comment">/*...*/</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="派生类对象的内存空间"><a href="#派生类对象的内存空间" class="headerlink" title="派生类对象的内存空间"></a>派生类对象的内存空间</h2><font color="Red">派生类对象的体积 = 基类对象的体积 + 派生类对象自己的成员变量的体积。</font><p>在派生类对象中，包含基类对象，而且基类对象的存储位置位于派生类对象新增的成员变量<font color="red">之前</font>。</p><a id="more"></a><h2 id="学籍管理程序实现"><a href="#学籍管理程序实现" class="headerlink" title="学籍管理程序实现"></a>学籍管理程序实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CStudent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">string</span> id;</span><br><span class="line">    <span class="keyword">char</span> gender;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintInfo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetInfo</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp; name_, <span class="keyword">const</span> <span class="built_in">string</span> % id_, <span class="keyword">int</span> age_, <span class="keyword">char</span> gender_)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">GetName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CUndergraduteStudent</span>:</span> <span class="keyword">public</span> CStudent</span><br><span class="line">&#123;<span class="comment">//本科生类，继承了CStudent类</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">string</span> department;<span class="comment">//学生所属的系的名称</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QualifiedForBaoyan</span><span class="params">()</span><span class="comment">//给予保研资格</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"qualified for baoyan"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CStudent::PrintInfo();<span class="comment">//调用基类的PrintInfo</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Department"</span> &lt;&lt; department &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetInfo</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp; name_, <span class="keyword">const</span> <span class="built_in">string</span> % id_, <span class="keyword">int</span> age_, <span class="keyword">char</span> gender_)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CStudent::SetInfo(name_, id_, age_, gender_);<span class="comment">//调用基类的SetInfo</span></span><br><span class="line">department = department_;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CUndergraduteStudent s2;</span><br><span class="line">    </span><br><span class="line">    s2.SetInfo(<span class="string">"Guderian"</span>, <span class="string">"999999999"</span>, <span class="number">21</span>, <span class="string">"M"</span>, <span class="string">"Combat Command"</span>);</span><br><span class="line">    <span class="comment">//古德里安，999999999，,2岁，男性，战役指挥学</span></span><br><span class="line">    s2.QualifiedForBaoyan();</span><br><span class="line">    <span class="comment">//获得保研资格</span></span><br><span class="line">    s2.PrintInfo();</span><br><span class="line">    <span class="comment">//打印信息</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">Guderian qualified <span class="keyword">for</span> baoyan</span><br><span class="line">Name: Guderian</span><br><span class="line">ID: <span class="number">999999999</span></span><br><span class="line">Age: <span class="number">21</span></span><br><span class="line">Gender: M</span><br><span class="line">Department: Combat Command</span><br></pre></td></tr></table></figure><h2 id="派生类的使用方法"><a href="#派生类的使用方法" class="headerlink" title="派生类的使用方法"></a>派生类的使用方法</h2><ul><li>在派生类中，调用基类的成员函数，设置了从基类继承的信息之后，之后再设置自己独有的信息。这一方法在<code>C++</code>面向对象编程中是很常用的。</li><li><strong>多继承</strong>：一个子类可以有多个父亲，继承多个父亲的特性</li></ul><hr><blockquote><p>参考并整理自《C++面向对象设计》郭炜，北京大学，感谢原作者！编辑时有删改</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/12/06/QYrjln.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;C-继承和派生&quot;&gt;&lt;a href=&quot;#C-继承和派生&quot; class=&quot;headerlink&quot; title=&quot;C++继承和派生&quot;&gt;&lt;/a&gt;C++继承和派生&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;图：亲爱的、古老的地球&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;font color=&quot;#FF7F27&quot;&gt;本文整理自《北京大学公开课：C++面向对象程序设计》&lt;/font&gt;

&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;font color=&quot;font&quot;&gt;继承&lt;/font&gt;和&lt;font color=&quot;red&quot;&gt;派生&lt;/font&gt;实际上是一回事：在定义一个新的类&lt;code&gt;B&lt;/code&gt;时，如果该类与某个已有的类&lt;code&gt;A&lt;/code&gt;相似（指的是&lt;code&gt;B&lt;/code&gt;拥有&lt;code&gt;A&lt;/code&gt;的全部特点），那么可以把&lt;code&gt;A&lt;/code&gt;作为一个&lt;strong&gt;基类&lt;/strong&gt;，而把&lt;code&gt;B&lt;/code&gt;作为&lt;strong&gt;基类&lt;/strong&gt;的一个&lt;strong&gt;派生类&lt;/strong&gt;（也称&lt;strong&gt;子类&lt;/strong&gt;），这使得创建和维护一个程序更加容易&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;派生类&lt;/strong&gt;拥有&lt;strong&gt;基类&lt;/strong&gt;的全部特点，派生类还可以对&lt;strong&gt;基类&lt;/strong&gt;进行修改和扩充。在&lt;strong&gt;派生类&lt;/strong&gt;中，可以扩充新的成员变量和成员函数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;派生类&lt;/strong&gt;一经定义，可以独立使用，定义对象时不依赖于&lt;strong&gt;基类&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;派生类&lt;/strong&gt;拥有&lt;strong&gt;基类&lt;/strong&gt;的全部成员函数和成员变量。不论是&lt;code&gt;private&lt;/code&gt;、&lt;code&gt;protected&lt;/code&gt;、&lt;code&gt;public&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在&lt;strong&gt;派生类&lt;/strong&gt;的各个成员函数中，不能访问&lt;strong&gt;基类&lt;/strong&gt;的&lt;code&gt;private&lt;/code&gt;成员&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;简单理解成员修饰符&lt;code&gt;protected&lt;/code&gt;和&lt;code&gt;private&lt;/code&gt;的区别：&lt;code&gt;protected&lt;/code&gt;成员在派生类中可以被访问，而&lt;code&gt;private&lt;/code&gt;不能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;对象不同类型对应的访问权限：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;public&lt;/th&gt;
&lt;th&gt;protected&lt;/th&gt;
&lt;th&gt;private&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;本类&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;派生类&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;其他类&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h2 id=&quot;派生类的写法&quot;&gt;&lt;a href=&quot;#派生类的写法&quot; class=&quot;headerlink&quot; title=&quot;派生类的写法&quot;&gt;&lt;/a&gt;派生类的写法&lt;/h2&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; 派生类名:&lt;/span&gt; 访问修饰符 基类名	&lt;span class=&quot;comment&quot;&gt;//Zh&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;derived&lt;/span&gt;-&lt;span class=&quot;title&quot;&gt;class&lt;/span&gt;:&lt;/span&gt; access-specifier base-&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;	//&lt;span class=&quot;title&quot;&gt;En&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;访问修饰符&lt;/strong&gt;可以是&lt;code&gt;private&lt;/code&gt;、&lt;code&gt;protected&lt;/code&gt;、&lt;code&gt;public&lt;/code&gt;中的一个。如果未使用&lt;strong&gt;访问修饰符&lt;/strong&gt;，则默认为&lt;code&gt;private&lt;/code&gt;。该访问修饰符规定了&lt;strong&gt;继承类型&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;继承类型&quot;&gt;&lt;a href=&quot;#继承类型&quot; class=&quot;headerlink&quot; title=&quot;继承类型&quot;&gt;&lt;/a&gt;继承类型&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;公有继承（&lt;code&gt;public&lt;/code&gt;）：继承&lt;code&gt;public&lt;/code&gt;和&lt;code&gt;protected&lt;/code&gt;且类型不变，不继承&lt;code&gt;private&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;保护继承（&lt;code&gt;protected&lt;/code&gt;）：继承&lt;code&gt;public&lt;/code&gt;和&lt;code&gt;protected&lt;/code&gt;且类型都为&lt;code&gt;protected&lt;/code&gt;，不继承&lt;code&gt;private&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;私有继承（&lt;code&gt;private&lt;/code&gt;）：继承&lt;code&gt;public&lt;/code&gt;和&lt;code&gt;protected&lt;/code&gt;且类型都变为&lt;code&gt;private&lt;/code&gt;，不继承&lt;code&gt;private&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般使用公有继承。&lt;/p&gt;
&lt;h2 id=&quot;写法示例：学生管理系统&quot;&gt;&lt;a href=&quot;#写法示例：学生管理系统&quot; class=&quot;headerlink&quot; title=&quot;写法示例：学生管理系统&quot;&gt;&lt;/a&gt;写法示例：学生管理系统&lt;/h2&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CStudent&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; sName;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; nAge;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;IsThreeGood&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;	&lt;/span&gt;&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SetName&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; &amp;amp; name)&lt;/span&gt;	&lt;/span&gt;&amp;#123; sName = name; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CUndergraduteStudent&lt;/span&gt;:&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; CStudent&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//本科生&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; nDepartment;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;IsThreeGood&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;	&lt;/span&gt;&amp;#123;&lt;span class=&quot;comment&quot;&gt;/*...*/&lt;/span&gt;&amp;#125;;	&lt;span class=&quot;comment&quot;&gt;//覆盖（不是重载！覆盖的参数表不变，重载的参数表改变！）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;//名字与基类一样，但行为不一样&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CanBaoYan&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;	&lt;/span&gt;&amp;#123;&lt;span class=&quot;comment&quot;&gt;/*...*/&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CGraduatedStudent&lt;/span&gt;:&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; CStudent&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//研究生&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; nDepartment;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; szMentorName[&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CountSalary&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;	&lt;/span&gt;&amp;#123;&lt;span class=&quot;comment&quot;&gt;/*...*/&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;派生类对象的内存空间&quot;&gt;&lt;a href=&quot;#派生类对象的内存空间&quot; class=&quot;headerlink&quot; title=&quot;派生类对象的内存空间&quot;&gt;&lt;/a&gt;派生类对象的内存空间&lt;/h2&gt;&lt;font color=&quot;Red&quot;&gt;派生类对象的体积 = 基类对象的体积 + 派生类对象自己的成员变量的体积。&lt;/font&gt;

&lt;p&gt;在派生类对象中，包含基类对象，而且基类对象的存储位置位于派生类对象新增的成员变量&lt;font color=&quot;red&quot;&gt;之前&lt;/font&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="OOP" scheme="https://G-SS-Hacker.github.io/tags/OOP/"/>
    
      <category term="C-plus-plus" scheme="https://G-SS-Hacker.github.io/tags/C-plus-plus/"/>
    
      <category term="面向对象" scheme="https://G-SS-Hacker.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++友元</title>
    <link href="https://g-ss-hacker.github.io/C-%E5%8F%8B%E5%85%83/"/>
    <id>https://g-ss-hacker.github.io/C-%E5%8F%8B%E5%85%83/</id>
    <published>2019-12-05T12:43:48.000Z</published>
    <updated>2019-12-07T02:49:35.411Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/12/05/4od6BVpY9SDaAXy.jpg" alt></p><h1 id="C-友元"><a href="#C-友元" class="headerlink" title="C++友元"></a>C++友元</h1><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><p></p><font color="#FF7F27">本文整理自《北京大学公开课：C++面向对象程序设计》</font><blockquote><p>友元很简单，在某种程度上算作是C++设计者对C使用者的妥协。友元分为<strong>友元函数</strong>和<strong>友元类</strong>两种。</p></blockquote><h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><p>一个类的友元函数可以访问该类的私有成员，友元函数不是这个类的成员函数，可以是一个普通的全局函数或其他类的成员函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span>;</span><span class="comment">//提前声明CCar是一个类，以便后面的CDriver类使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDriver</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ModifyCar</span><span class="params">(CCar *pCar)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">int</span> <span class="title">MostExpensiveCar</span><span class="params">(CCar cars[], <span class="keyword">int</span> total)</span></span>;<span class="comment">//声明友元</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> CDriver::ModifyCar(CCar *pCar)<span class="comment">//声明友元</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> CDriver::ModifyCar(CCar *pCar)</span><br><span class="line">&#123;</span><br><span class="line">    pCar-&gt;price += <span class="number">1000</span>;<span class="comment">//汽车改装后价值增加</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MostExpensiveCar</span><span class="params">(CCar cars[], <span class="keyword">int</span> total)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmpMax = <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; ++i)</span><br><span class="line">    <span class="keyword">if</span>(cars[i].price &gt; tmpMax)</span><br><span class="line">            tmpMax = cars[i].price;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tmpMax;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以将一个类的成员函数（包括构造、析构函数）说明为另一个类的友元</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> B::function();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h2><p>如果<code>A</code>是<code>B</code>的友元类，那么<code>A</code>的所有成员函数可以访问<code>B</code>的所有私有成员</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">CDriver</span>;</span><span class="comment">//声明CDriver为友元类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDriver</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    CCar myCar;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ModifyCar</span><span class="params">()</span><span class="comment">//改装汽车</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">myCar.price += <span class="number">1000</span>;</span><br><span class="line">            <span class="comment">//因CDriver是CCar的友元类故可以访问其私有成员</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>友元类之间的关系不能传递：类<code>A</code>是类<code>B</code>的友元，类<code>C</code>是类<code>B</code>的友元，但类<code>A</code>不是类<code>C</code>的友元</li><li>友元类之间的关系不能继承</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/05/4od6BVpY9SDaAXy.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;C-友元&quot;&gt;&lt;a href=&quot;#C-友元&quot; class=&quot;headerlink&quot; title=&quot;C++友元&quot;&gt;&lt;/a&gt;C++友元&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;font color=&quot;#FF7F27&quot;&gt;本文整理自《北京大学公开课：C++面向对象程序设计》&lt;/font&gt;

&lt;blockquote&gt;
&lt;p&gt;友元很简单，在某种程度上算作是C++设计者对C使用者的妥协。友元分为&lt;strong&gt;友元函数&lt;/strong&gt;和&lt;strong&gt;友元类&lt;/strong&gt;两种。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;友元函数&quot;&gt;&lt;a href=&quot;#友元函数&quot; class=&quot;headerlink&quot; title=&quot;友元函数&quot;&gt;&lt;/a&gt;友元函数&lt;/h2&gt;&lt;p&gt;一个类的友元函数可以访问该类的私有成员，友元函数不是这个类的成员函数，可以是一个普通的全局函数或其他类的成员函数&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CCar&lt;/span&gt;;&lt;/span&gt;	&lt;span class=&quot;comment&quot;&gt;//提前声明CCar是一个类，以便后面的CDriver类使用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CDriver&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ModifyCar&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(CCar *pCar)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CCar&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; price;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;friend&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MostExpensiveCar&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(CCar cars[], &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; total)&lt;/span&gt;&lt;/span&gt;;	&lt;span class=&quot;comment&quot;&gt;//声明友元&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;friend&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; CDriver::ModifyCar(CCar *pCar)	&lt;span class=&quot;comment&quot;&gt;//声明友元&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; CDriver::ModifyCar(CCar *pCar)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pCar-&amp;gt;price += &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;;	&lt;span class=&quot;comment&quot;&gt;//汽车改装后价值增加&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MostExpensiveCar&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(CCar cars[], &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; total)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; tmpMax = &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; total; ++i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(cars[i].price &amp;gt; tmpMax)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            tmpMax = cars[i].price;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; tmpMax;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以将一个类的成员函数（包括构造、析构函数）说明为另一个类的友元&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;B&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;A&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;friend&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; B::function();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="OOP" scheme="https://G-SS-Hacker.github.io/tags/OOP/"/>
    
      <category term="C-plus-plus" scheme="https://G-SS-Hacker.github.io/tags/C-plus-plus/"/>
    
      <category term="面向对象" scheme="https://G-SS-Hacker.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++常量对象、常量成员函数和常引用</title>
    <link href="https://g-ss-hacker.github.io/C-%E5%B8%B8%E9%87%8F%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B8%B8%E9%87%8F%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%92%8C%E5%B8%B8%E5%BC%95%E7%94%A8/"/>
    <id>https://g-ss-hacker.github.io/C-%E5%B8%B8%E9%87%8F%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B8%B8%E9%87%8F%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%92%8C%E5%B8%B8%E5%BC%95%E7%94%A8/</id>
    <published>2019-12-05T04:43:46.000Z</published>
    <updated>2019-12-07T02:50:43.777Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/12/05/vwAOcbkZFnzf4PR.jpg" alt></p><h1 id="C-常量对象、常量成员函数和常引用"><a href="#C-常量对象、常量成员函数和常引用" class="headerlink" title="C++常量对象、常量成员函数和常引用"></a>C++常量对象、常量成员函数和常引用</h1><blockquote><p>图：广州塔</p></blockquote><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><p></p><font color="#FF7F27">本文整理自《北京大学公开课：C++面向对象程序设计》</font><h2 id="常量对象"><a href="#常量对象" class="headerlink" title="常量对象"></a>常量对象</h2><p>如果不希望某个对象的值被改变，则定义该对象的时候可在前面加<code>const</code>关键字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDemo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> vale;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetValue</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Demo obj;<span class="comment">//常量对象</span></span><br></pre></td></tr></table></figure><hr><h2 id="常量成员函数"><a href="#常量成员函数" class="headerlink" title="常量成员函数"></a>常量成员函数</h2><p>在类的成员函数说明后面可以加<code>const</code>关键字，则该成员函数成为常量成员函数。</p><p>常量成员函数执行期间<font color="red">不应该修改其所作用的对象</font>。因此，在常量成员函数中不能修改成员变量的值（<font color="Red">静态成员变量除外</font>），也不能调用同类的非常量成员函数（<font color="red">静态成员函数除外</font>）。</p><p>非常亮成员函数在执行的过程中是有可能修改掉常量成员函数中的值的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GetValue</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    Sample() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> Sample::GetValue() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    value = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//wrong,不能修改成员变量的值</span></span><br><span class="line">    func();</span><br><span class="line">    <span class="comment">//wrong,不能调用同类的非常量成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Sample o;</span><br><span class="line">    o.value = <span class="number">100</span>;<span class="comment">//err,不能修改成员变量的值</span></span><br><span class="line">    o.func();<span class="comment">//err,不能调用同类的非常量成员函数</span></span><br><span class="line">    o.GetValue();<span class="comment">//ok,可以执行常量成员函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="常量成员函数的重载"><a href="#常量成员函数的重载" class="headerlink" title="常量成员函数的重载"></a>常量成员函数的重载</h2><p>两个成员函数，名字和参数表都一样，但是一个是<code>const</code>，一个不是，算<font color="red">重载</font>，而不是<font color="red">重复定义</font>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    CTest()&#123; n = <span class="number">1</span> ;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span> * n; &#125;</span><br><span class="line">    <span class="comment">//这两个GetValue()函数是重载关系，而不是重复定义</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> CTest objTest1;</span><br><span class="line">    CTest objTest2;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; objTest1.GetValue() &lt;&lt; <span class="string">", "</span> &lt;&lt; objTest2.GetValue();</span><br><span class="line">    <span class="comment">//objTest1是常量对象，调用的是GetValue() const</span></span><br><span class="line">    <span class="comment">//objTest2是非常量对象，调用的是GetValue()</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="常引用"><a href="#常引用" class="headerlink" title="常引用"></a>常引用</h2><p>引用前面可以加<code>const</code>关键字，成为常引用。不能通过常引用，修改其引用的变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r = n;</span><br><span class="line">r = <span class="number">5</span>;<span class="comment">//error</span></span><br><span class="line">n = <span class="number">4</span>;<span class="comment">//OK</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>对象作为函数的参数时，生成该参数需要调用复制构造函数，效率比较低。用指针作参数，代码又不好看，如何解决？可以用对象的引用作为参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">//...  </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintfObj</span><span class="params">(Sample &amp;o)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但对象引用作为函数参数有一定风险性，若函数中不小心修改了形参<code>o</code>，则实参也跟着变，这不是我想要的。如何避免？使用常引用！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">//...  </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintfObj</span><span class="params">(<span class="keyword">const</span> Sample &amp;o)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样函数中就能确保不会出现无意中更改<code>o</code>值的语句了。</p><hr><blockquote><p> 参考并整理自《C++面向对象设计》郭炜，北京大学，感谢原作者！编辑时有删改</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/05/vwAOcbkZFnzf4PR.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;C-常量对象、常量成员函数和常引用&quot;&gt;&lt;a href=&quot;#C-常量对象、常量成员函数和常引用&quot; class=&quot;headerlink&quot; title=&quot;C++常量对象、常量成员函数和常引用&quot;&gt;&lt;/a&gt;C++常量对象、常量成员函数和常引用&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;图：广州塔&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;font color=&quot;#FF7F27&quot;&gt;本文整理自《北京大学公开课：C++面向对象程序设计》&lt;/font&gt;

&lt;h2 id=&quot;常量对象&quot;&gt;&lt;a href=&quot;#常量对象&quot; class=&quot;headerlink&quot; title=&quot;常量对象&quot;&gt;&lt;/a&gt;常量对象&lt;/h2&gt;&lt;p&gt;如果不希望某个对象的值被改变，则定义该对象的时候可在前面加&lt;code&gt;const&lt;/code&gt;关键字。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CDemo&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; vale;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   	&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SetValue&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;	&lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; Demo obj;	&lt;span class=&quot;comment&quot;&gt;//常量对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h2 id=&quot;常量成员函数&quot;&gt;&lt;a href=&quot;#常量成员函数&quot; class=&quot;headerlink&quot; title=&quot;常量成员函数&quot;&gt;&lt;/a&gt;常量成员函数&lt;/h2&gt;&lt;p&gt;在类的成员函数说明后面可以加&lt;code&gt;const&lt;/code&gt;关键字，则该成员函数成为常量成员函数。&lt;/p&gt;
&lt;p&gt;常量成员函数执行期间&lt;font color=&quot;red&quot;&gt;不应该修改其所作用的对象&lt;/font&gt;。因此，在常量成员函数中不能修改成员变量的值（&lt;font color=&quot;Red&quot;&gt;静态成员变量除外&lt;/font&gt;），也不能调用同类的非常量成员函数（&lt;font color=&quot;red&quot;&gt;静态成员函数除外&lt;/font&gt;）。&lt;/p&gt;
&lt;p&gt;非常亮成员函数在执行的过程中是有可能修改掉常量成员函数中的值的。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Sample&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;GetValue&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;	&lt;/span&gt;&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	Sample() &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; Sample::GetValue() &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    value = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//wrong,不能修改成员变量的值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    func();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//wrong,不能调用同类的非常量成员函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; Sample o;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    o.value = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;;	&lt;span class=&quot;comment&quot;&gt;//err,不能修改成员变量的值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    o.func();		&lt;span class=&quot;comment&quot;&gt;//err,不能调用同类的非常量成员函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    o.GetValue();	&lt;span class=&quot;comment&quot;&gt;//ok,可以执行常量成员函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h2 id=&quot;常量成员函数的重载&quot;&gt;&lt;a href=&quot;#常量成员函数的重载&quot; class=&quot;headerlink&quot; title=&quot;常量成员函数的重载&quot;&gt;&lt;/a&gt;常量成员函数的重载&lt;/h2&gt;&lt;p&gt;两个成员函数，名字和参数表都一样，但是一个是&lt;code&gt;const&lt;/code&gt;，一个不是，算&lt;font color=&quot;red&quot;&gt;重载&lt;/font&gt;，而不是&lt;font color=&quot;red&quot;&gt;重复定义&lt;/font&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CTest&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	CTest()	&amp;#123; n = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; ;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;GetValue&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; n; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;GetValue&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; * n; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;comment&quot;&gt;//这两个GetValue()函数是重载关系，而不是重复定义&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; CTest objTest1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CTest objTest2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; objTest1.GetValue() &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;, &quot;&lt;/span&gt; &amp;lt;&amp;lt; objTest2.GetValue();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//objTest1是常量对象，调用的是GetValue() const&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//objTest2是非常量对象，调用的是GetValue()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h2 id=&quot;常引用&quot;&gt;&lt;a href=&quot;#常引用&quot; class=&quot;headerlink&quot; title=&quot;常引用&quot;&gt;&lt;/a&gt;常引用&lt;/h2&gt;&lt;p&gt;引用前面可以加&lt;code&gt;const&lt;/code&gt;关键字，成为常引用。不能通过常引用，修改其引用的变量。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &amp;amp;r = n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;r = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;;	&lt;span class=&quot;comment&quot;&gt;//error&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;n = &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;;	&lt;span class=&quot;comment&quot;&gt;//OK&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="OOP" scheme="https://G-SS-Hacker.github.io/tags/OOP/"/>
    
      <category term="C-plus-plus" scheme="https://G-SS-Hacker.github.io/tags/C-plus-plus/"/>
    
      <category term="面向对象" scheme="https://G-SS-Hacker.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++复制构造函数</title>
    <link href="https://g-ss-hacker.github.io/C-%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <id>https://g-ss-hacker.github.io/C-%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</id>
    <published>2019-12-04T12:55:34.000Z</published>
    <updated>2019-12-07T02:50:40.328Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/12/04/BtpLFjvfUKwGqTV.jpg" alt></p><h1 id="C-复制构造函数"><a href="#C-复制构造函数" class="headerlink" title="C++复制构造函数"></a>C++复制构造函数</h1><blockquote><p>图：广州天河CBD</p></blockquote><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><p></p><font color="#FF7F27">本文整理自《北京大学公开课：C++面向对象程序设计》</font><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>只有一个参数，即对同类对象的引用</li><li>形如<code>X::X(X &amp;)</code>或<code>X::X(const X &amp;)</code>，二者选一，后者能以常量对象作为参数</li><li>如果没有定义复制构造函数，那么编译器生成默认的复制构造函数。默认的复制构造函数完成复制功能</li></ul><hr><h2 id="构造函数与复制构造函数的异同"><a href="#构造函数与复制构造函数的异同" class="headerlink" title="构造函数与复制构造函数的异同"></a>构造函数与复制构造函数的异同</h2><ul><li>构造函数（或称无参构造函数）不一定存在，你不写构造函数，编译器就只会帮你生成一个什么也不做的无参构造函数</li><li>复制构造函数一定存在，你不写复制构造函数，编译器也会帮你写好一个具有复制功能的复制构造函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    douebl real, imag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Complex c1;<span class="comment">//调用缺省的构造函数</span></span><br><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(c1)</span></span>;<span class="comment">//调用缺省的复制构造函数，将c2初始化成和c1一样</span></span><br></pre></td></tr></table></figure><ul><li>如果定义了自己的复制构造函数，则默认的复制构造函数不存在</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> real, imag;</span><br><span class="line">    Complex()&#123;&#125;</span><br><span class="line">    Complex(<span class="keyword">const</span> Complex &amp;c)</span><br><span class="line">        &#123;</span><br><span class="line">            real = c.real;</span><br><span class="line">            imag = c.imag;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Copy constructor called"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Complex c1;</span><br><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(c1)</span></span>;</span><br><span class="line"><span class="comment">//调用自己定义过的复制构造函数，输出Copy constructor called</span></span><br></pre></td></tr></table></figure><hr><h2 id="特别强调1"><a href="#特别强调1" class="headerlink" title="特别强调1"></a>特别强调1</h2><p>注意：不允许有形如<code>X::X(X)</code>的复制构造函数，参数一定是引用，不能是对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    CSample(CSample c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//错，不允许出现这样的复制构造函数</span></span><br><span class="line">        <span class="comment">//这样写的话，下面的内容要么变成了构造函数，要么语法是错误的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="复制构造函数起作用的三种情况"><a href="#复制构造函数起作用的三种情况" class="headerlink" title="复制构造函数起作用的三种情况"></a>复制构造函数起作用的三种情况</h2><h3 id="（1）当用一个对象去初始化同类的另一个对象时"><a href="#（1）当用一个对象去初始化同类的另一个对象时" class="headerlink" title="（1）当用一个对象去初始化同类的另一个对象时"></a>（1）当用一个对象去初始化同类的另一个对象时</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(c1)</span></span>;</span><br><span class="line">Complex c2 = c1; <span class="comment">//初始化语句，非赋值语句，与上面写法是等价的</span></span><br></pre></td></tr></table></figure><h3 id="（2）当某函数有一个参数是类A的对象时"><a href="#（2）当某函数有一个参数是类A的对象时" class="headerlink" title="（2）当某函数有一个参数是类A的对象时"></a>（2）当某函数有一个参数是类A的对象时</h3><p>那么该函数被调用时，类<code>A</code>的复制构造函数将被调用。<code>C++</code>规则：形参是实参的拷贝</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    A()&#123;&#125;;</span><br><span class="line">    A(A &amp;a)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Copy constructor called"</span> &lt;&lt; <span class="built_in">endl</span>;    </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(A a1)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a2;</span><br><span class="line">    Func(a2);</span><br><span class="line">    </span><br><span class="line">    retrun <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">Copy constructor called</span><br></pre></td></tr></table></figure><h3 id="（3）当函数的返回值是类A的对象时"><a href="#（3）当函数的返回值是类A的对象时" class="headerlink" title="（3）当函数的返回值是类A的对象时"></a>（3）当函数的返回值是类A的对象时</h3><p>那么在函数返回时，<code>A</code>的复制构造函数被调用，作用是初始化作为返回值的类<code>A</code>对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    A(<span class="keyword">int</span> n)&#123;v = n&#125;;</span><br><span class="line">    A(<span class="keyword">const</span> A &amp;a)</span><br><span class="line">    &#123;</span><br><span class="line">        v = a.v;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Copy constructor called"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A.Func()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">A <span class="title">b</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Func().v &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//此处Func()的返回值没有名字，是一个复制构造函数初始化的对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">Copy constructor called</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><hr><a id="more"></a><h2 id="特别强调2"><a href="#特别强调2" class="headerlink" title="特别强调2"></a>特别强调2</h2><p>注意：对象间赋值并不导致复制构造函数被调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    CMyClass()&#123;&#125;;</span><br><span class="line">    CMyClass(CMyClass &amp;c)&#123; n = <span class="number">2</span> * c.n; &#125;</span><br><span class="line">    <span class="comment">//不推荐复制构造函数这样写，此处仅用于凸显调用复制构造函数与对象间赋值的区别</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CMyClass c1, c2;</span><br><span class="line">    c1.n = <span class="number">5</span>;</span><br><span class="line">    c2 = c1;<span class="comment">//这是赋值语句</span></span><br><span class="line">    <span class="function">CMyClass <span class="title">c3</span><span class="params">(c1)</span></span>;<span class="comment">//调用复制构造函数，c3并没有变得跟c1一样</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c2.n &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c3.n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="number">5</span>, <span class="number">10</span></span><br></pre></td></tr></table></figure><hr><h2 id="定义函数时常量引用参数的使用"><a href="#定义函数时常量引用参数的使用" class="headerlink" title="定义函数时常量引用参数的使用"></a>定义函数时常量引用参数的使用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(CMyClass obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"fun"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这样的函数，调用时生成形参会引发复制构造函数调用，复制一遍时间开销比较大</li><li>所以可以考虑使用<code>CMyClass &amp;</code> 引用类型作为参数，本质上与实参是一样的</li><li>如果希望确保实参的值在函数中不应被改变，那么可以加上<code>const</code>关键字，这样的话如果你定义的函数中出现了改变实参的值得语句。编译器就会报错</li></ul><blockquote><p>我自己写的程序难道我自己不记得我没有改过参数吗？的确，你现在记得，明天也记得，但以后再改你的程序，就未必记得了。从代码规范的角度来讲，加上<code>const</code>关键字是必要的</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">const</span> CMyClass &amp;obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如此一来，函数中任何试图改变obj值得语句都将是非法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="思考：为什么要自己写复制构造函数？"><a href="#思考：为什么要自己写复制构造函数？" class="headerlink" title="思考：为什么要自己写复制构造函数？"></a>思考：为什么要自己写复制构造函数？</h2><blockquote><p>想通这个问题是高难度操作，作者水平有限，无法清晰地回答，仅提供参考链接。</p></blockquote><p>前置知识：</p><ul><li>深拷贝、浅拷贝</li><li>传值、传地址、传引用</li></ul><p>参考链接：</p><ul><li><a href="https://www.cnblogs.com/qianqiannian/p/8946769.html" target="_blank" rel="noopener">为什么需要拷贝构造函数</a></li><li><a href="https://blog.csdn.net/qq_29344757/article/details/76037255" target="_blank" rel="noopener">c++的默认拷贝构造函数，从深度拷贝和浅拷贝说起</a></li><li><a href="https://blog.csdn.net/mist99/article/details/24660173" target="_blank" rel="noopener">为什么要自己写构造函数和析构函数</a></li><li><a href="https://blog.csdn.net/RealOnlyme/article/details/7272051" target="_blank" rel="noopener">使用缺省的拷贝构造函数带来的危险性</a></li><li><a href="https://www.cnblogs.com/xuewangkai/p/11152377.html" target="_blank" rel="noopener">值传递 引用传递（传地址，传引用）的区别</a></li></ul><hr><blockquote><p>参考并整理自《C++面向对象设计》郭炜，北京大学，感谢原作者！编辑时有删改</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/04/BtpLFjvfUKwGqTV.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;C-复制构造函数&quot;&gt;&lt;a href=&quot;#C-复制构造函数&quot; class=&quot;headerlink&quot; title=&quot;C++复制构造函数&quot;&gt;&lt;/a&gt;C++复制构造函数&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;图：广州天河CBD&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;font color=&quot;#FF7F27&quot;&gt;本文整理自《北京大学公开课：C++面向对象程序设计》&lt;/font&gt;

&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;只有一个参数，即对同类对象的引用&lt;/li&gt;
&lt;li&gt;形如&lt;code&gt;X::X(X &amp;amp;)&lt;/code&gt;或&lt;code&gt;X::X(const X &amp;amp;)&lt;/code&gt;，二者选一，后者能以常量对象作为参数&lt;/li&gt;
&lt;li&gt;如果没有定义复制构造函数，那么编译器生成默认的复制构造函数。默认的复制构造函数完成复制功能&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;构造函数与复制构造函数的异同&quot;&gt;&lt;a href=&quot;#构造函数与复制构造函数的异同&quot; class=&quot;headerlink&quot; title=&quot;构造函数与复制构造函数的异同&quot;&gt;&lt;/a&gt;构造函数与复制构造函数的异同&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;构造函数（或称无参构造函数）不一定存在，你不写构造函数，编译器就只会帮你生成一个什么也不做的无参构造函数&lt;/li&gt;
&lt;li&gt;复制构造函数一定存在，你不写复制构造函数，编译器也会帮你写好一个具有复制功能的复制构造函数&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Complex&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	douebl real, imag;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Complex c1;		&lt;span class=&quot;comment&quot;&gt;//调用缺省的构造函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;Complex &lt;span class=&quot;title&quot;&gt;c2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(c1)&lt;/span&gt;&lt;/span&gt;;	&lt;span class=&quot;comment&quot;&gt;//调用缺省的复制构造函数，将c2初始化成和c1一样&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;如果定义了自己的复制构造函数，则默认的复制构造函数不存在&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Complex&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; real, imag;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	Complex()	&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	Complex(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; Complex &amp;amp;c)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            real = c.real;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            imag = c.imag;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;Copy constructor called&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Complex c1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;Complex &lt;span class=&quot;title&quot;&gt;c2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(c1)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//调用自己定义过的复制构造函数，输出Copy constructor called&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h2 id=&quot;特别强调1&quot;&gt;&lt;a href=&quot;#特别强调1&quot; class=&quot;headerlink&quot; title=&quot;特别强调1&quot;&gt;&lt;/a&gt;特别强调1&lt;/h2&gt;&lt;p&gt;注意：不允许有形如&lt;code&gt;X::X(X)&lt;/code&gt;的复制构造函数，参数一定是引用，不能是对象&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CSample&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CSample(CSample c)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//错，不允许出现这样的复制构造函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//这样写的话，下面的内容要么变成了构造函数，要么语法是错误的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h2 id=&quot;复制构造函数起作用的三种情况&quot;&gt;&lt;a href=&quot;#复制构造函数起作用的三种情况&quot; class=&quot;headerlink&quot; title=&quot;复制构造函数起作用的三种情况&quot;&gt;&lt;/a&gt;复制构造函数起作用的三种情况&lt;/h2&gt;&lt;h3 id=&quot;（1）当用一个对象去初始化同类的另一个对象时&quot;&gt;&lt;a href=&quot;#（1）当用一个对象去初始化同类的另一个对象时&quot; class=&quot;headerlink&quot; title=&quot;（1）当用一个对象去初始化同类的另一个对象时&quot;&gt;&lt;/a&gt;（1）当用一个对象去初始化同类的另一个对象时&lt;/h3&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;Complex &lt;span class=&quot;title&quot;&gt;c2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(c1)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Complex c2 = c1; 	&lt;span class=&quot;comment&quot;&gt;//初始化语句，非赋值语句，与上面写法是等价的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;（2）当某函数有一个参数是类A的对象时&quot;&gt;&lt;a href=&quot;#（2）当某函数有一个参数是类A的对象时&quot; class=&quot;headerlink&quot; title=&quot;（2）当某函数有一个参数是类A的对象时&quot;&gt;&lt;/a&gt;（2）当某函数有一个参数是类A的对象时&lt;/h3&gt;&lt;p&gt;那么该函数被调用时，类&lt;code&gt;A&lt;/code&gt;的复制构造函数将被调用。&lt;code&gt;C++&lt;/code&gt;规则：形参是实参的拷贝&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;A&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	A()	&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	A(A &amp;amp;a)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        	&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;Copy constructor called&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Func&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(A a1)&lt;/span&gt;	&lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    A a2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Func(a2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    retrun &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//输出：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Copy constructor called&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;（3）当函数的返回值是类A的对象时&quot;&gt;&lt;a href=&quot;#（3）当函数的返回值是类A的对象时&quot; class=&quot;headerlink&quot; title=&quot;（3）当函数的返回值是类A的对象时&quot;&gt;&lt;/a&gt;（3）当函数的返回值是类A的对象时&lt;/h3&gt;&lt;p&gt;那么在函数返回时，&lt;code&gt;A&lt;/code&gt;的复制构造函数被调用，作用是初始化作为返回值的类&lt;code&gt;A&lt;/code&gt;对象&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;A&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; v;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    A(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n)	&amp;#123;v = n&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    A(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; A &amp;amp;a)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        v = a.v;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;Copy constructor called&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;A.Func()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;A &lt;span class=&quot;title&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; Func().v &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//此处Func()的返回值没有名字，是一个复制构造函数初始化的对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//输出：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Copy constructor called&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="OOP" scheme="https://G-SS-Hacker.github.io/tags/OOP/"/>
    
      <category term="C-plus-plus" scheme="https://G-SS-Hacker.github.io/tags/C-plus-plus/"/>
    
      <category term="面向对象" scheme="https://G-SS-Hacker.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++构造函数</title>
    <link href="https://g-ss-hacker.github.io/C-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <id>https://g-ss-hacker.github.io/C-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</id>
    <published>2019-12-04T09:10:38.000Z</published>
    <updated>2019-12-07T02:50:36.293Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.mp.itc.cn/upload/20170616/3e26b0c84ed64d5e9c6d533178122240_th.jpg" alt></p><h1 id="C-构造参数"><a href="#C-构造参数" class="headerlink" title="C++ 构造参数"></a>C++ 构造参数</h1><blockquote><p>图：深圳福田CBD</p></blockquote><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><p></p><font color="#FF7F27">本文整理自《北京大学公开课：C++面向对象程序设计》</font><h2 id="构造函数的性质"><a href="#构造函数的性质" class="headerlink" title="构造函数的性质"></a>构造函数的性质</h2><ul><li>构造参数是成员函数的一种</li><li>名字与类名相同，可以由参数，不能有返回值（<code>void</code>也不行）</li><li>作用是对对象进行初始化，如给成员变量赋初值</li><li>如果定义类的时候没写构造函数，则编译器生成一个默认的无参数的构造函数</li><li>默认构造函数无参数，不进行任何操作</li><li>如果定义了构造函数，则编译器不生成默认的无参数的构造函数</li><li>对象生成时构造函数被自动调用。对象一旦生成，就再也不能在其上执行构造函数</li><li>一个类可以有多个构造函数</li></ul><p>注：如果只定义了带参构造函数，在定义对象时必须声明参数</p><h2 id="为什么需要构造函数："><a href="#为什么需要构造函数：" class="headerlink" title="为什么需要构造函数："></a>为什么需要构造函数：</h2><ul><li>不用专门写初始化函数，也不用担心忘记</li><li>有时对象没有被初始化，会导致程序出错</li></ul><h2 id="构造函数的使用"><a href="#构造函数的使用" class="headerlink" title="构造函数的使用"></a>构造函数的使用</h2><h3 id="一个类可以有一个构造函数"><a href="#一个类可以有一个构造函数" class="headerlink" title="一个类可以有一个构造函数"></a>一个类可以有一个构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> radius, xLoc, yLoc;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Circle(<span class="keyword">double</span> r ,<span class="keyword">double</span> x = <span class="number">0</span>, y = <span class="number">0</span>)</span><br><span class="line">&#125;;</span><br><span class="line">Circle::Circle(<span class="keyword">double</span> r, <span class="keyword">double</span> x, <span class="keyword">double</span> y)</span><br><span class="line">&#123;</span><br><span class="line">    radius = r, xLoc = x, yLoc = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Wrong samples</span></span><br><span class="line">Circle c1;<span class="comment">//error,缺少构造函数的参数</span></span><br><span class="line">Circle *pc = <span class="keyword">new</span> Circle;<span class="comment">//error，没有参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Correct samples</span></span><br><span class="line"><span class="function">Circle <span class="title">c1</span><span class="params">(<span class="number">2</span>)</span></span>;<span class="comment">//OK</span></span><br><span class="line"><span class="function">Circle <span class="title">c1</span><span class="params">(<span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>)</span></span>;<span class="comment">//OK</span></span><br><span class="line">Circle *pc = <span class="keyword">new</span> Circle(<span class="number">3</span>, <span class="number">4</span>);<span class="comment">//also OK</span></span><br></pre></td></tr></table></figure><h3 id="一个类可以有多个构造函数"><a href="#一个类可以有多个构造函数" class="headerlink" title="一个类可以有多个构造函数"></a>一个类可以有多个构造函数</h3><p>只要不同的构造函数的参数个数和参数类型不同，这些构造函数就会构成重载的关系</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> radius, xLoc, yLoc;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Circle(<span class="keyword">double</span> r ,<span class="keyword">double</span> x = <span class="number">0</span>, y = <span class="number">0</span>)</span><br><span class="line">        Circle(<span class="keyword">double</span> r);</span><br><span class="line">    Circle(Circle c1, Circle c2)</span><br><span class="line">&#125;;</span><br><span class="line">Circle::Circle(<span class="keyword">double</span> r, <span class="keyword">double</span> x, <span class="keyword">double</span> y)</span><br><span class="line">&#123;</span><br><span class="line">    radius = r, xLoc = x, yLoc = y;</span><br><span class="line">&#125;</span><br><span class="line">Circle::Circle(<span class="keyword">double</span> r)</span><br><span class="line">&#123;</span><br><span class="line">    radius = r;</span><br><span class="line">&#125;</span><br><span class="line">Circle::Circle(Circle c1, Circle c2)</span><br><span class="line">&#123;</span><br><span class="line">    radius = c1.radius + c2.radius;</span><br><span class="line">    xLoc   = c1.xLOc   + c2.xLoc;</span><br><span class="line">    yLoc   = c1.yLOc   + c2.yLoc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Samples</span></span><br><span class="line">Circle c1(3), c2(1, 0), c3(c1, c2);</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="构造函数在数组的使用（1）"><a href="#构造函数在数组的使用（1）" class="headerlink" title="构造函数在数组的使用（1）"></a>构造函数在数组的使用（1）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    CSample()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Constructor 1 Called"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    CSample(<span class="keyword">int</span> n)</span><br><span class="line">        &#123;</span><br><span class="line">            x = n;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Constructor 2 Called"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"step1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    CSample array1[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"step2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    CSample array2[<span class="number">2</span>] = &#123;<span class="number">4</span>, <span class="number">5</span>&#125;;    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"step3"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    CSample array3[<span class="number">2</span>] = &#123;<span class="number">3</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"step4"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    CSample *array4 = <span class="keyword">new</span> CSample[<span class="number">2</span>];<span class="comment">//随机生成两个元素的数组</span></span><br><span class="line">    <span class="keyword">delete</span> []array4;<span class="comment">//解除空间占用</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">step1<span class="comment">//对两个对象初始化的参数没有作任何交代，编译器就认为这个对象就应该用无参的构造函数初始化</span></span><br><span class="line">Constructor <span class="number">1</span> Called</span><br><span class="line">Constructor <span class="number">1</span> Called</span><br><span class="line">step2<span class="comment">//对两个对象初始化的参数都有交代</span></span><br><span class="line">Constructor <span class="number">2</span> Called</span><br><span class="line">Constructor <span class="number">2</span> Called</span><br><span class="line">step3<span class="comment">//只对第一个对象初始化的参数作了交代</span></span><br><span class="line">Constructor <span class="number">2</span> Called</span><br><span class="line">Constructor <span class="number">1</span> Called</span><br><span class="line">step4<span class="comment">//对两个对象初始化的参数没有作任何交代</span></span><br><span class="line">Constructor <span class="number">1</span> Called</span><br><span class="line">Constructor <span class="number">1</span> Called</span><br></pre></td></tr></table></figure><h3 id="构造函数在数组的使用（2）"><a href="#构造函数在数组的使用（2）" class="headerlink" title="构造函数在数组的使用（2）"></a>构造函数在数组的使用（2）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Test(<span class="keyword">int</span> n)&#123;&#125;<span class="comment">//(1)</span></span><br><span class="line">    Test(<span class="keyword">int</span> n, <span class="keyword">int</span> m)&#123;&#125;<span class="comment">//(2)</span></span><br><span class="line">    Test()&#123;&#125;<span class="comment">//(3)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Test array1[<span class="number">3</span>] = &#123;<span class="number">1</span>, Test(<span class="number">1</span>,<span class="number">2</span>)&#125;;</span><br><span class="line"><span class="comment">//三个元素分别用(1)，(2)，(3)初始化</span></span><br><span class="line"></span><br><span class="line">Test array2[<span class="number">3</span>] = &#123;Test(<span class="number">2</span>, <span class="number">3</span>), Test(<span class="number">1</span>, <span class="number">2</span>), <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">//三个元素分别用(2)，(2)，(1)初始化</span></span><br><span class="line"></span><br><span class="line">Test *pArray1[<span class="number">3</span>];</span><br><span class="line"><span class="comment">//仅仅这么定义是不会导致对象生成的，不会引发Test的构造函数被调用。</span></span><br><span class="line"><span class="comment">//*pArray1[3]仅仅是指针而已，不会产生任何对象</span></span><br><span class="line"></span><br><span class="line">Test *pArray2[<span class="number">3</span>] = &#123;<span class="keyword">new</span> Test(<span class="number">4</span>), <span class="keyword">new</span> Test(<span class="number">1</span>, <span class="number">2</span>)&#125;;</span><br><span class="line"><span class="comment">//对指针数组的前两个元素初始化，方法是new两个对象，返回值是指针，用new的两个对象的地址去初始化数组pArray2[3]的前两个元素。</span></span><br><span class="line"><span class="comment">//注意这个语句只生成了两个对象，pArray2[2]还是一个指针，无从得知它的指针指向哪里，它的生成并不会导致任何对象的生成。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意在使用中，指针数组与数组的区别</span></span><br></pre></td></tr></table></figure><hr><blockquote><p>参考并整理自《C++面向对象程序设计》郭炜，北京大学，感谢原作者！编辑时有删改</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.mp.itc.cn/upload/20170616/3e26b0c84ed64d5e9c6d533178122240_th.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;C-构造参数&quot;&gt;&lt;a href=&quot;#C-构造参数&quot; class=&quot;headerlink&quot; title=&quot;C++ 构造参数&quot;&gt;&lt;/a&gt;C++ 构造参数&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;图：深圳福田CBD&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;font color=&quot;#FF7F27&quot;&gt;本文整理自《北京大学公开课：C++面向对象程序设计》&lt;/font&gt;

&lt;h2 id=&quot;构造函数的性质&quot;&gt;&lt;a href=&quot;#构造函数的性质&quot; class=&quot;headerlink&quot; title=&quot;构造函数的性质&quot;&gt;&lt;/a&gt;构造函数的性质&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;构造参数是成员函数的一种&lt;/li&gt;
&lt;li&gt;名字与类名相同，可以由参数，不能有返回值（&lt;code&gt;void&lt;/code&gt;也不行）&lt;/li&gt;
&lt;li&gt;作用是对对象进行初始化，如给成员变量赋初值&lt;/li&gt;
&lt;li&gt;如果定义类的时候没写构造函数，则编译器生成一个默认的无参数的构造函数&lt;/li&gt;
&lt;li&gt;默认构造函数无参数，不进行任何操作&lt;/li&gt;
&lt;li&gt;如果定义了构造函数，则编译器不生成默认的无参数的构造函数&lt;/li&gt;
&lt;li&gt;对象生成时构造函数被自动调用。对象一旦生成，就再也不能在其上执行构造函数&lt;/li&gt;
&lt;li&gt;一个类可以有多个构造函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注：如果只定义了带参构造函数，在定义对象时必须声明参数&lt;/p&gt;
&lt;h2 id=&quot;为什么需要构造函数：&quot;&gt;&lt;a href=&quot;#为什么需要构造函数：&quot; class=&quot;headerlink&quot; title=&quot;为什么需要构造函数：&quot;&gt;&lt;/a&gt;为什么需要构造函数：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;不用专门写初始化函数，也不用担心忘记&lt;/li&gt;
&lt;li&gt;有时对象没有被初始化，会导致程序出错&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;构造函数的使用&quot;&gt;&lt;a href=&quot;#构造函数的使用&quot; class=&quot;headerlink&quot; title=&quot;构造函数的使用&quot;&gt;&lt;/a&gt;构造函数的使用&lt;/h2&gt;&lt;h3 id=&quot;一个类可以有一个构造函数&quot;&gt;&lt;a href=&quot;#一个类可以有一个构造函数&quot; class=&quot;headerlink&quot; title=&quot;一个类可以有一个构造函数&quot;&gt;&lt;/a&gt;一个类可以有一个构造函数&lt;/h3&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Circle&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; radius, xLoc, yLoc;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	Circle(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; r ,&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; x = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, y = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Circle::Circle(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; r, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; x, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; y)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    radius = r, xLoc = x, yLoc = y;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//Wrong samples&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Circle c1;	&lt;span class=&quot;comment&quot;&gt;//error,缺少构造函数的参数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Circle *pc = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Circle;	&lt;span class=&quot;comment&quot;&gt;//error，没有参数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//Correct samples&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;Circle &lt;span class=&quot;title&quot;&gt;c1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;	&lt;span class=&quot;comment&quot;&gt;//OK&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;Circle &lt;span class=&quot;title&quot;&gt;c1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;	&lt;span class=&quot;comment&quot;&gt;//OK&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Circle *pc = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Circle(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;);	&lt;span class=&quot;comment&quot;&gt;//also OK&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;一个类可以有多个构造函数&quot;&gt;&lt;a href=&quot;#一个类可以有多个构造函数&quot; class=&quot;headerlink&quot; title=&quot;一个类可以有多个构造函数&quot;&gt;&lt;/a&gt;一个类可以有多个构造函数&lt;/h3&gt;&lt;p&gt;只要不同的构造函数的参数个数和参数类型不同，这些构造函数就会构成重载的关系&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Circle&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; radius, xLoc, yLoc;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	Circle(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; r ,&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; x = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, y = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Circle(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; r);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	Circle(Circle c1, Circle c2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Circle::Circle(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; r, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; x, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; y)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    radius = r, xLoc = x, yLoc = y;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Circle::Circle(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; r)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    radius = r;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Circle::Circle(Circle c1, Circle c2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    radius = c1.radius + c2.radius;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    xLoc   = c1.xLOc   + c2.xLoc;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    yLoc   = c1.yLOc   + c2.yLoc;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//Samples&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Circle c1(3), c2(1, 0), c3(c1, c2);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="OOP" scheme="https://G-SS-Hacker.github.io/tags/OOP/"/>
    
      <category term="C-plus-plus" scheme="https://G-SS-Hacker.github.io/tags/C-plus-plus/"/>
    
      <category term="面向对象" scheme="https://G-SS-Hacker.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>不定积分公式</title>
    <link href="https://g-ss-hacker.github.io/%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E5%85%AC%E5%BC%8F/"/>
    <id>https://g-ss-hacker.github.io/%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E5%85%AC%E5%BC%8F/</id>
    <published>2019-12-01T12:50:06.000Z</published>
    <updated>2019-12-02T13:52:26.250Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/12/01/hMmSsvG2xVE7K5p.png" alt></p><h1 id="不定积分公式"><a href="#不定积分公式" class="headerlink" title="不定积分公式"></a>不定积分公式</h1><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><br>$(1)\int0 \mathrm{dx} = C$<p></p><p>$(2)\int1\mathrm{dx}=x+C$</p><p>$(3)\int x^\mu \mathrm{dx}=\frac1{\mu+1}x^{\mu+1}+C(\mu \ne -1)$</p><p>$(4)\int\frac1{x}\mathrm{dx}=\ln|x|+C$</p><p>$(5)\int a^x \mathrm{dx}=\frac{a^x}{\ln a}+C$</p><p>$(6)\int e^x \mathrm{dx}=e^x+C$</p><p>$(7)\int \sin x \mathrm{dx}=-\cos x +C$</p><p>$(8)\int \cos x \mathrm{dx}=\sin x +C$</p><p>$(9)\int \sec^2 x \mathrm{dx}=\int \frac1{\cos^2 x}\mathrm{dx}=\tan x+C$</p><p>$(10)\int \csc^2x\mathrm{dx}=\int \frac1{\sin^2x}\mathrm{dx}=-\cot x +C$</p><p>$(11)\int\sec x\tan x\mathrm{dx}=\sec x+C$</p><p>$(12)\int \csc x\cot x\mathrm{dx}=-\csc x +C$</p><p>$(13)\int \frac{\mathrm{dx}}{\sqrt{1-x^2}}=\arcsin x+C$</p><p>$(14)\int \frac{\mathrm{dx}}{1+x^2}=\arctan x+C$</p><p>$(15)\int \tan x\mathrm{dx}=-\ln|\cos x|+C$</p><p>$(16)\int \cot x \mathrm{dx}=\ln|\sin x|+C$</p><p>$(17)\int \sec x \mathrm{dx}=\ln|\sec x+\tan x|+C$</p><p>$(18)\int \csc x\mathrm{dx}=\ln|\csc x -\cot x|+C$</p><p>$(19)\int \frac{\mathrm{dx}}{x^2+a^2}=\frac1{a}\arctan {\frac{x}{a}}+C$</p><p>$(20)\int \frac{\mathrm{dx}}{x^2-a^2}=\frac1{2a}\ln|\frac{x-a}{x+a}|+C$</p><p>$(21)\int \frac{\mathrm{dx}}{\sqrt{a^2-x^2}}=\arcsin \frac{x}{a}+C$</p><p>$(22)\int \frac{\mathrm{dx}}{\sqrt{x^2\pm a^2}}=\ln|x+\sqrt{x^2\pm a^2}|+C$</p><p>$(23)\int \sqrt{a^2-x^2}\mathrm{dx}=\frac{x}{2}\sqrt{a^2-x^2}+\frac{a^2}{2}\arcsin \frac{x}{a}+C$</p><p>$(24)\int \sqrt{x^2\pm a^2}\mathrm{dx}=\frac{x}{2}\sqrt{x^2\pm a^2}\pm \frac{a^2}{2}\ln|x+\sqrt{x^2\pm a^2}|+C$</p><p>$(25)\int \ln x\mathrm{dx}=x\ln x-x+C$</p><a id="more"></a><hr><p>~<font color="#FF7F27"><strong>我们遇到什么困难也不要怕，微笑着面对它！消除恐惧的最好办法就是面对恐惧！坚持就是胜利！加油！奥利给！</strong></font>~</p><font color="#407600">【其他文章·微积分·线性代数】</font><ul><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/不定积分公式/">不定积分公式</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/常用泰勒展开式/">常用泰勒展开式</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/高阶求导公式/">高阶求导公式</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/高等数学公式/">高等数学公式</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/常用等价无穷小/">常用等价无穷小</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/导数基本公式/">导数基本公式</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/矩阵章节总结/">矩阵章节总结</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/行列式章节总结/">行列式章节总结</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/线性方程组章节总结/">线性方程组章节总结</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/01/hMmSsvG2xVE7K5p.png&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;不定积分公式&quot;&gt;&lt;a href=&quot;#不定积分公式&quot; class=&quot;headerlink&quot; title=&quot;不定积分公式&quot;&gt;&lt;/a&gt;不定积分公式&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;br&gt;$(1)\int0 \mathrm{dx} = C$&lt;p&gt;&lt;/p&gt;
&lt;p&gt;$(2)\int1\mathrm{dx}=x+C$&lt;/p&gt;
&lt;p&gt;$(3)\int x^\mu \mathrm{dx}=\frac1{\mu+1}x^{\mu+1}+C(\mu \ne -1)$&lt;/p&gt;
&lt;p&gt;$(4)\int\frac1{x}\mathrm{dx}=\ln|x|+C$&lt;/p&gt;
&lt;p&gt;$(5)\int a^x \mathrm{dx}=\frac{a^x}{\ln a}+C$&lt;/p&gt;
&lt;p&gt;$(6)\int e^x \mathrm{dx}=e^x+C$&lt;/p&gt;
&lt;p&gt;$(7)\int \sin x \mathrm{dx}=-\cos x +C$&lt;/p&gt;
&lt;p&gt;$(8)\int \cos x \mathrm{dx}=\sin x +C$&lt;/p&gt;
&lt;p&gt;$(9)\int \sec^2 x \mathrm{dx}=\int \frac1{\cos^2 x}\mathrm{dx}=\tan x+C$&lt;/p&gt;
&lt;p&gt;$(10)\int \csc^2x\mathrm{dx}=\int \frac1{\sin^2x}\mathrm{dx}=-\cot x +C$&lt;/p&gt;
&lt;p&gt;$(11)\int\sec x\tan x\mathrm{dx}=\sec x+C$&lt;/p&gt;
&lt;p&gt;$(12)\int \csc x\cot x\mathrm{dx}=-\csc x +C$&lt;/p&gt;
&lt;p&gt;$(13)\int \frac{\mathrm{dx}}{\sqrt{1-x^2}}=\arcsin x+C$&lt;/p&gt;
&lt;p&gt;$(14)\int \frac{\mathrm{dx}}{1+x^2}=\arctan x+C$&lt;/p&gt;
&lt;p&gt;$(15)\int \tan x\mathrm{dx}=-\ln|\cos x|+C$&lt;/p&gt;
&lt;p&gt;$(16)\int \cot x \mathrm{dx}=\ln|\sin x|+C$&lt;/p&gt;
&lt;p&gt;$(17)\int \sec x \mathrm{dx}=\ln|\sec x+\tan x|+C$&lt;/p&gt;
&lt;p&gt;$(18)\int \csc x\mathrm{dx}=\ln|\csc x -\cot x|+C$&lt;/p&gt;
&lt;p&gt;$(19)\int \frac{\mathrm{dx}}{x^2+a^2}=\frac1{a}\arctan {\frac{x}{a}}+C$&lt;/p&gt;
&lt;p&gt;$(20)\int \frac{\mathrm{dx}}{x^2-a^2}=\frac1{2a}\ln|\frac{x-a}{x+a}|+C$&lt;/p&gt;
&lt;p&gt;$(21)\int \frac{\mathrm{dx}}{\sqrt{a^2-x^2}}=\arcsin \frac{x}{a}+C$&lt;/p&gt;
&lt;p&gt;$(22)\int \frac{\mathrm{dx}}{\sqrt{x^2\pm a^2}}=\ln|x+\sqrt{x^2\pm a^2}|+C$&lt;/p&gt;
&lt;p&gt;$(23)\int \sqrt{a^2-x^2}\mathrm{dx}=\frac{x}{2}\sqrt{a^2-x^2}+\frac{a^2}{2}\arcsin \frac{x}{a}+C$&lt;/p&gt;
&lt;p&gt;$(24)\int \sqrt{x^2\pm a^2}\mathrm{dx}=\frac{x}{2}\sqrt{x^2\pm a^2}\pm \frac{a^2}{2}\ln|x+\sqrt{x^2\pm a^2}|+C$&lt;/p&gt;
&lt;p&gt;$(25)\int \ln x\mathrm{dx}=x\ln x-x+C$&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="微积分" scheme="https://G-SS-Hacker.github.io/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>线性方程组章节总结</title>
    <link href="https://g-ss-hacker.github.io/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E7%AB%A0%E8%8A%82%E6%80%BB%E7%BB%93/"/>
    <id>https://g-ss-hacker.github.io/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E7%AB%A0%E8%8A%82%E6%80%BB%E7%BB%93/</id>
    <published>2019-11-28T13:13:45.000Z</published>
    <updated>2019-12-02T13:52:12.458Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/11/28/KuIyhFR2j49xqwG.jpg" alt></p><h1 id="线性方程组章节总结"><a href="#线性方程组章节总结" class="headerlink" title="线性方程组章节总结"></a>线性方程组章节总结</h1><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><p></p><h2 id="线性方程组有解的充要条件"><a href="#线性方程组有解的充要条件" class="headerlink" title="线性方程组有解的充要条件"></a>线性方程组有解的充要条件</h2><ol><li><p>齐次线性方程组要么只有一组零解，要么有无穷多解</p></li><li><p>非齐次线性方程组有解的充要条件</p><p>$R(A)=R(A|\beta)$</p><p>注：$R(A)$和$R(A|\beta)$要么相等，要么差$1$</p></li></ol><h2 id="线性方程组解的结构"><a href="#线性方程组解的结构" class="headerlink" title="线性方程组解的结构"></a>线性方程组解的结构</h2><ol><li><p>齐次线性方程组</p><p>(1) $AX=0$只有零解 $ \Leftrightarrow R(A)$等于未知数个数$\Leftrightarrow$A为列满秩阵</p><p>(2) $AX=0$有无穷多组解 $ \Leftrightarrow R(A)$小于未知数个数</p></li><li><p>非齐次线性方程组</p><p>(1) $AX=B$ 有唯一解 $\Leftrightarrow R(A)=R(A|\beta)=n$ </p><p>(2) $AX=B$ 有无穷多组解 $\Leftrightarrow R(A)=R(A|\beta)&lt;n$</p><p>(3) $AX=B$ 无解 $\Leftrightarrow R(A) \ne R(A|\beta)$</p></li></ol><p>注：在非常严苛的条件下，以下两命题等价：$AX=B$ 有唯一解 $\Leftrightarrow $ $AX=0$只有零解（当$A$时方阵时成立）</p><h2 id="线性方程组的解"><a href="#线性方程组的解" class="headerlink" title="线性方程组的解"></a>线性方程组的解</h2><p>思想：利用矩阵初等行变换（高斯消元）</p><ol><li><p>齐次线性方程组</p><p>记$N(A)$为齐次线性方程组的全体解向量所构成的向量空间，则$\dim N(A)=n-R(A)$，称$n(A)$的基为齐次线性方程组的<strong>基础解系</strong>：</p><p>(1) 当$R(A)=n$时，齐次线性方程组只有零解，没有<strong>基础解系</strong></p><p>(2) 当$R(A)&lt;n$时，<strong>基础解系</strong>为齐次线性方程组的$n-R(A)$个线性无关的解向量</p></li><li><p>非齐次线性方程组</p><p>$AX=B$ 和 $AX=0$的解向量满足：</p><p>(1) 若$\eta_1$，$\eta_2$都是$AX=B$的解，那么$\eta_1 - \eta_2$是$AX=0$的解<del>（几乎没用）</del></p><p>(2) 若$\eta_1$是$AX=B$的解，$\eta_2$是$AX=0$的解，那么$\eta_1 + \eta_2$还是$AX=B$的解</p><a id="more"></a></li></ol><hr><p>~<font color="#FF7F27"><strong>我们遇到什么困难也不要怕，微笑着面对它！消除恐惧的最好办法就是面对恐惧！坚持就是胜利！加油！奥利给！</strong></font>~</p><font color="#407600">【其他文章·线性代数·微积分】</font><ul><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/线性方程组章节总结/">线性方程组章节总结</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/矩阵章节总结/">矩阵章节总结</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/行列式章节总结/">行列式章节总结</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/常用泰勒展开式/">常用泰勒展开式</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/高阶求导公式/">高阶求导公式</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/高等数学公式/">高等数学公式</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/常用等价无穷小/">常用等价无穷小</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/导数基本公式/">导数基本公式</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/不定积分公式/">不定积分公式</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/11/28/KuIyhFR2j49xqwG.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;线性方程组章节总结&quot;&gt;&lt;a href=&quot;#线性方程组章节总结&quot; class=&quot;headerlink&quot; title=&quot;线性方程组章节总结&quot;&gt;&lt;/a&gt;线性方程组章节总结&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;h2 id=&quot;线性方程组有解的充要条件&quot;&gt;&lt;a href=&quot;#线性方程组有解的充要条件&quot; class=&quot;headerlink&quot; title=&quot;线性方程组有解的充要条件&quot;&gt;&lt;/a&gt;线性方程组有解的充要条件&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;齐次线性方程组要么只有一组零解，要么有无穷多解&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;非齐次线性方程组有解的充要条件&lt;/p&gt;
&lt;p&gt;$R(A)=R(A|\beta)$&lt;/p&gt;
&lt;p&gt;注：$R(A)$和$R(A|\beta)$要么相等，要么差$1$&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;线性方程组解的结构&quot;&gt;&lt;a href=&quot;#线性方程组解的结构&quot; class=&quot;headerlink&quot; title=&quot;线性方程组解的结构&quot;&gt;&lt;/a&gt;线性方程组解的结构&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;齐次线性方程组&lt;/p&gt;
&lt;p&gt;(1) $AX=0$只有零解 $ \Leftrightarrow R(A)$等于未知数个数$\Leftrightarrow$A为列满秩阵&lt;/p&gt;
&lt;p&gt;(2) $AX=0$有无穷多组解 $ \Leftrightarrow R(A)$小于未知数个数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;非齐次线性方程组&lt;/p&gt;
&lt;p&gt;(1) $AX=B$ 有唯一解 $\Leftrightarrow R(A)=R(A|\beta)=n$ &lt;/p&gt;
&lt;p&gt;(2) $AX=B$ 有无穷多组解 $\Leftrightarrow R(A)=R(A|\beta)&amp;lt;n$&lt;/p&gt;
&lt;p&gt;(3) $AX=B$ 无解 $\Leftrightarrow R(A) \ne R(A|\beta)$&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注：在非常严苛的条件下，以下两命题等价：$AX=B$ 有唯一解 $\Leftrightarrow $ $AX=0$只有零解（当$A$时方阵时成立）&lt;/p&gt;
&lt;h2 id=&quot;线性方程组的解&quot;&gt;&lt;a href=&quot;#线性方程组的解&quot; class=&quot;headerlink&quot; title=&quot;线性方程组的解&quot;&gt;&lt;/a&gt;线性方程组的解&lt;/h2&gt;&lt;p&gt;思想：利用矩阵初等行变换（高斯消元）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;齐次线性方程组&lt;/p&gt;
&lt;p&gt;记$N(A)$为齐次线性方程组的全体解向量所构成的向量空间，则$\dim N(A)=n-R(A)$，称$n(A)$的基为齐次线性方程组的&lt;strong&gt;基础解系&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;(1) 当$R(A)=n$时，齐次线性方程组只有零解，没有&lt;strong&gt;基础解系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(2) 当$R(A)&amp;lt;n$时，&lt;strong&gt;基础解系&lt;/strong&gt;为齐次线性方程组的$n-R(A)$个线性无关的解向量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;非齐次线性方程组&lt;/p&gt;
&lt;p&gt;$AX=B$ 和 $AX=0$的解向量满足：&lt;/p&gt;
&lt;p&gt;(1) 若$\eta_1$，$\eta_2$都是$AX=B$的解，那么$\eta_1 - \eta_2$是$AX=0$的解&lt;del&gt;（几乎没用）&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;(2) 若$\eta_1$是$AX=B$的解，$\eta_2$是$AX=0$的解，那么$\eta_1 + \eta_2$还是$AX=B$的解&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="线性代数" scheme="https://G-SS-Hacker.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>模式匹配算法：KMP算法</title>
    <link href="https://g-ss-hacker.github.io/KMP%E7%AE%97%E6%B3%95/"/>
    <id>https://g-ss-hacker.github.io/KMP%E7%AE%97%E6%B3%95/</id>
    <published>2019-11-26T07:34:36.000Z</published>
    <updated>2019-12-10T12:21:31.980Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1574783133220&amp;di=3be2714c61c60e81640b949c940ab16a&amp;imgtype=0&amp;src=http%3A%2F%2Fimg.mp.itc.cn%2Fupload%2F20170613%2Fca5280ac60284d4cb01f4f81be3b448b_th.jpg" alt></p><h1 id="模式匹配算法：KMP算法"><a href="#模式匹配算法：KMP算法" class="headerlink" title="模式匹配算法：KMP算法"></a>模式匹配算法：KMP算法</h1><blockquote><p> 图：北京航空航天大学</p></blockquote><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><p></p><blockquote><p>模式匹配是数据结构中字符串的一种基本运算，给定一个字符串P，要求在某个字符串T中找出与字符串P相同的所有子串，这就是模式匹配。</p></blockquote><h2 id="模式匹配算法要解决的问题"><a href="#模式匹配算法要解决的问题" class="headerlink" title="模式匹配算法要解决的问题"></a>模式匹配算法要解决的问题</h2><ul><li><font color="#495DD8">detection</font> ：P<font color="#64ceaa"><strong>是否</strong></font>出现</li><li><font color="#495DD8">location</font> ：首次<font color="#64ceaa"><strong>在哪里</strong></font>出现</li><li><font color="#495DD8">counting</font> ：共有<font color="#64ceaa"><strong>几次</strong></font>出现</li><li><font color="#495DD8">enumeration</font> ：各出现<font color="#64ceaa"><strong>在哪里</strong></font>？</li></ul><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><p><code>KMP算法</code>（全称<code>Knuth-Morris-Pratt算法</code>）是一种高效的模式匹配算法。在模式匹配算法中，常见的算法包括<code>BF算法</code>（<code>朴素算法</code>）、<code>KMP算法</code>、<code>BM算法</code>、<code>RK算法</code>、<code>有限自动机算法</code>、<code>Horspool算法</code>、<code>Sunday算法</code>。在这些算法中，最经典的算法非<code>KMP算法</code>和<code>BM算法</code>莫属。这两种算法都有一个共同点：抽象，理解难度大。实际上，<code>KMP算法</code>还有一个明显特点：会者不难。本文内容默认你已经明白<code>BF算法</code>的原理和不足（因此这部分内容将简单略过），展开讲述<code>KMP算法</code>的原理、优点和<code>c++</code>代码实现。相信你在学会<code>KMP算法</code>之后将会有一种<font color="#64ceaa"><strong>“踏遍青山人未老，这边风景独好”</strong></font>的快意。让我们开始吧。</p><h2 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h2><p><code>BF算法</code>的本质就是<font color="#64ceaa">暴力搜索</font>。既然要在串<code>T</code>中找出与串<code>P</code>相同的所有子串，那不妨找出串<code>T</code>中所有与串<code>P</code>长度相同的子串，在逐个判断这个子串是否与串<code>P</code>相同。具体的例子<a href="https://www.bilibili.com/video/av11866460" target="_blank" rel="noopener">点击这里</a>或者<font color="#FF7F27">看下方的视频</font><font color="#5F2CA5">（讲得很形象了，应该不会有理解上的困难）</font>。设<code>strlen(T) == n, strlen(P) == m</code>，则<code>BF算法</code>的<font color="#64ceaa"><strong>预处理时间</strong></font>为$0$，<font color="#64ceaa"><strong>匹配时间</strong></font>为$O(mn)$，<font color="#64ceaa"><strong>总时间复杂度</strong></font>为$O(mn)$<font color="#5F2CA5">（简直是蜗速）</font>，在大部分应用场景中并不<font color="#64ceaa"><strong>优秀</strong></font>。</p><p><iframe src="//player.bilibili.com/player.html?aid=11866460&cid=19594712&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" width="780" height="520" allowfullscreen="true"> </iframe></p><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><h3 id="更高的效率"><a href="#更高的效率" class="headerlink" title="更高的效率"></a>更高的效率</h3><p>容易看出<code>BF算法</code>的效率是十分蹩脚的，而它蹩脚的原因也很明显：在一次匹配尝试中，一旦失配（某一位匹配失败），就把串<code>P</code>整体向右移动一位。在模拟算法运行过程中，我们发现如果开始匹配时第一位就失配，那么只向右移动一位的确无可厚非，毕竟说不定移动一位之后就会匹配成功呢；但是如果已经匹配了串<code>P</code>的一部分了才失配，在向右移动一位之后，有时候（而且往往是经常）我们发现依然注定会匹配失败，也就是说在上次失败之后，向右移动一位再做尝试是根本不必要的，这种<font color="#5F2CA5">“只移动一位”</font>的策略实际上造成了巨大的步骤浪费。那么有没有办法，把这些不必要的尝试舍弃，节约算法的运行时间呢？</p><p>此处我们需要考虑以下问题，以便对<code>BF算法</code>做出有效的改进：</p><ul><li><font color="#495DD8">为什么有一些尝试是注定徒劳的？</font></li><li><font color="#495DD8">如何判断哪些尝试需要舍弃？</font></li><li><font color="#495DD8">如果不是向右移动一位，又应该如何确定向右移动的位数？</font></li></ul><p>在看完<a href="https://www.bilibili.com/video/av11866460" target="_blank" rel="noopener">点击这里</a>（还是上面那个链接）之后，前两个问题都能得到答案。在链接的视频讲解中，讲述者构造了一个前缀表数组<code>prefix table</code>来确定串<code>P</code>中每个从头开始的子串的<font color="#64ceaa"><strong>最长公共前后缀</strong></font>（自身除外，以下省略此说明），一旦失配，就把串<code>P</code>向右移动到失配位置左侧子串的<font color="#64ceaa"><strong>最长前缀</strong></font>处，使它们重叠，也就是把下图中的<font color="#A349A4">1号</font>移动到<font color="#A349A4">2号</font>位置，继续从当前位置匹配，如果当前位置为串<code>T</code>的结尾，则结束匹配。</p><p><img src="https://i.loli.net/2019/11/26/eZcoQNJmPrKtklh.jpg" alt></p><p>那么问题来了：为什么要把<font color="#64ceaa"><strong>最长公共前缀</strong></font>移动至<font color="#64cceaa"><strong>最长公共后缀</strong></font>的位置？这个移动距离能不能更短？能不能更长？</p><blockquote> <font color="black">**引理**</font>  串的<font color="#64ceaa">**最长公共前后缀**</font>的<font color="#64ceaa">**最长公共前后缀**</font>是原串的<font color="#64ceaa">**次长公共前后缀**</font>。 <font color="black">**证明**</font>  略<font color="#5F2CA5">~~（逃~~</font></blockquote><p>实际上，在<code>BF算法</code>的一次匹配过程中，一旦失配，就把串<code>P</code>整体向右移动一位再次尝试匹配。假设第一次匹配时在串<code>P</code>的第<code>r + 1</code>位失配，此时已经确定串<code>P</code>失配位置的前<code>r</code>项与串<code>T</code>相应位置元素匹配，也确定了串<code>P</code>失配位置的前<code>r - 1</code>项与串<code>T</code>相应位置元素匹配。那么第二次匹配成功，当且仅当在串<code>P</code>的前<code>r</code>项组成的子串中，前<code>r - 1</code>位字符组成的前缀和后<code>r - 1</code>位字符组成的后缀相同，即某一个<font color="#64ceaa"><strong>公共前后缀</strong></font>长度为<code>r - 1</code>。也就是说，如果匹配失败向右移动<code>s</code>位，那么再次匹配成功的<font color="#64ceaa"><strong>必要条件</strong></font>是串<code>P</code>在失配位置前的子串的某一个<font color="#64ceaa"><strong>公共前后缀</strong></font>长度为<code>r - s</code>。如果串<code>P</code>在失配位置前的子串的<font color="#64ceaa"><strong>最长公共前后缀</strong></font>长度就是<code>r - s</code>，匹配失败后向右移动了不足<code>s</code>位，这意味着移动距离过短，将会做一遍无用功。</p><p>如果移动距离过长，那就有可能会错过一个成功的匹配。如果匹配失败向右移动<code>s</code>位，那么再次匹配成功的<font color="#64ceaa"><strong>必要条件</strong></font>是串<code>P</code>在失配位置前的子串的某一个<font color="#64ceaa"><strong>公共前后缀</strong></font>长度为<code>r - s</code>。注意这里是<font color="#64ceaa"><strong>必要条件</strong></font>而不是<font color="#64ceaa"><strong>充分条件</strong></font>，在把串<code>P</code>向右移动的过程中，并不是在失配位置前随便放一个<font color="#64ceaa"><strong>公共前后缀</strong></font>都能匹配成功，我们需要从<font color="#64ceaa"><strong>最长公共前后缀</strong></font>开始尝试，逐步减少原失配位置前子串的长度，直到匹配成功或者串<code>P</code>在失配位置前子串<font color="#64ceaa"><strong>最长公共前后缀</strong></font>长度变为<code>0</code>。</p><p>此处我们引入<code>next[]</code>数组来记录在失配时应该把串<code>P</code>的哪一位移动到当前位置。对于串<code>P</code>的第<code>j + 1</code>位的字符来说，<code>next[j + 1]</code>的意义是由串<code>P</code>的前<code>j</code>项的子串中<font color="#64ceaa"><strong>最长公共前后缀</strong></font>的长度。<code>next[]</code>数组是<code>KMP算法</code>降低<font color="#64ceaa"><strong>时间复杂度</strong></font>的关键，在预处理时就已经确定。下面介绍<code>next[]</code>数组求法。</p><h3 id="next数组求法"><a href="#next数组求法" class="headerlink" title="next数组求法"></a>next数组求法</h3><p>如果你直接跳过了前面看到了这里，那说明你已经看了无数多参考资料，还是搞不懂<code>next[]</code>数组求法的原理，几乎走投无路了。但是，正如B站鬼畜区某神所言：</p><p>~<font color="#FF7F27"><strong>我们遇到什么困难也不要怕，微笑着面对它！消除恐惧的最好办法就是面对恐惧！坚持就是胜利！加油！奥利给！</strong></font>~</p><a id="more"></a><p>回到正题。</p><p>先考虑求<code>next[]</code>数组的朴素算法：我们要求一个长度为<code>l</code>的串<code>S</code>的<font color="#64ceaa"><strong>最长公共前后缀</strong></font>，因为自身除外，所以把串<code>S</code>复制一遍，产生一个串<code>S&#39;</code>，并让串<code>S&#39;</code>的第<code>1</code>位对齐串<code>S</code>的第<code>2</code>位，尝试匹配剩余<code>l - 1</code>位。若匹配成功，则剩余<code>l - 1</code>位就是串<code>P</code>的<font color="#64ceaa"><strong>最长公共前后缀</strong></font>；若匹配失败，则把串<code>S&#39;</code>向右移动<code>1</code>位，再次尝试，知道匹配成功或串<code>S&#39;</code>已被移出串<code>S</code>的范围之内。</p><p>等一等，为什么这波操作如此熟悉？<font color="#5F2CA5">（战术后仰</font></p><p>是的，这就是所谓的<font color="#5F2CA5">“串<code>P</code>匹配自身”</font>，有没有办法可以优化以上的朴素算法呢？</p><p>我们的任务是求出串<code>P</code>每一个由前<code>j</code>项元素组成的子串的<font color="#64ceaa"><strong>最长公共前后缀</strong></font>的长度。假设串<code>P</code>从字符串下标<code>1</code>开始存储，规定<code>next[1] = 0</code>，并从第<code>2</code>位开始匹配。设用串<code>P&#39;</code>匹配串<code>P</code>，当前匹配位置是串<code>P&#39;</code>的第<code>j + 1</code>位，串<code>P</code>的第<code>i</code>位，如果失配，那么处理方法同上面介绍的一样，把串<code>P&#39;</code>向右移动到失配位置左侧子串的<font color="#64ceaa"><strong>最长前缀</strong></font>处，即令<code>j = next[j]</code><font color="#5F2CA5">（思想：回溯）</font>，使它们重叠，即把下图中的<font color="#A349A4">1号</font>移动到<font color="#A349A4">2号</font>位置，继续从当前位置匹配；如果第<code>j + 1</code>位匹配成功，则更新串<code>P</code>前<code>i</code>位元素组成的子串的<font color="#64ceaa"><strong>最长公共前后缀</strong></font>的长度为<code>j</code>，即令<code>next[i] = j</code>。</p><p><img src="https://i.loli.net/2019/11/26/IrptJbecBsQy16q.jpg" alt></p><p>你已经明白了<code>KMP算法</code>的原理，那么不难推算出<code>KMP算法</code>的时间复杂度：<font color="#64ceaa"><strong>预处理时间</strong></font>为$\Theta(m)$，<font color="#64ceaa"><strong>匹配时间</strong></font>为$\Theta(n)$，<font color="#64ceaa"><strong>总时间复杂度</strong></font>为$\Theta(m+n)$。与<code>BF算法</code>相比，<code>KMP算法</code>是一种<font color="#64ceaa"><strong>优秀</strong></font>的模式匹配算法。</p><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">KMP-MATCHER(T, P)</span><br><span class="line"></span><br><span class="line">n = T.length</span><br><span class="line">m = P.length</span><br><span class="line"></span><br><span class="line">next = COMPUTE-PREFIX-FUNCTION(P)</span><br><span class="line"></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> to n</span><br><span class="line"><span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> P[j + <span class="number">1</span>] != T[i]</span><br><span class="line">j = next[j]</span><br><span class="line"><span class="keyword">if</span> P[j + <span class="number">1</span>] == T[j]</span><br><span class="line">j = j + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> j == m</span><br><span class="line">    print <span class="string">"Pattern occurs with shift"</span> i - m</span><br><span class="line">    j = next[j]</span><br><span class="line">    </span><br><span class="line">COMPUTE-PREFIX-FUNCTION(P)</span><br><span class="line"></span><br><span class="line">m = P.length</span><br><span class="line">let next[<span class="number">1.</span>.m] be a <span class="keyword">new</span> <span class="built_in">array</span></span><br><span class="line">next[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">2</span> to m</span><br><span class="line"><span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> P[j + <span class="number">1</span>] != T[i]</span><br><span class="line">j = next[j]</span><br><span class="line"><span class="keyword">if</span> P[j + <span class="number">1</span>] == T[j]</span><br><span class="line">j = j + <span class="number">1</span></span><br><span class="line">    next[i] = j</span><br><span class="line"><span class="keyword">return</span> next</span><br></pre></td></tr></table></figure><h2 id="例题：KMP算法模版"><a href="#例题：KMP算法模版" class="headerlink" title="例题：KMP算法模版"></a>例题：KMP算法模版</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个字符串$s1$和$s2$（皆从下标为$1$处开始存储），$s2$为$s1$的子串，输出$s2$在$s1$中所有出现位置的下标。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行为$s1$，第二行为$s2$</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>每行一个正整数表示s2在s1中出现的位置</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">123456123</span><br><span class="line">123</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">7</span><br></pre></td></tr></table></figure><h3 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h3><ul><li><font color="#495DD8">$s1$和$s2$的长度在$1000000$之内</font></li><li><font color="#495DD8">运行速度不能太慢</font></li></ul><h3 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Presented by G-SS-Hacker</span></span><br><span class="line"><span class="comment">//cc BY-NC-SA 4.0</span></span><br><span class="line"><span class="comment">//Run on C++</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000000</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1000000</span> + <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//next,x0,x1,y0,y1,index cannot be named to variables</span></span><br><span class="line"><span class="keyword">int</span> nxt[MAXM];<span class="comment">//nxt[i]表示字串1到i最长公共前后缀的长度</span></span><br><span class="line"><span class="keyword">int</span> len1, len2;</span><br><span class="line"><span class="keyword">char</span> s1[MAXN], s2[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>, i = <span class="number">2</span>; i &lt;= len2; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(j &amp;&amp; s2[i] != s2[j + <span class="number">1</span>])</span><br><span class="line">j = nxt[j];</span><br><span class="line"><span class="keyword">if</span>(s2[i] == s2[j + <span class="number">1</span>])</span><br><span class="line">j++;</span><br><span class="line">nxt[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>, i = <span class="number">1</span>; i &lt;= len1; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(j &amp;&amp; s1[i] != s2[j + <span class="number">1</span>])</span><br><span class="line">j = nxt[j];</span><br><span class="line"><span class="keyword">if</span>(s1[i] == s2[j + <span class="number">1</span>])</span><br><span class="line">j++;</span><br><span class="line"><span class="keyword">if</span>(j == len2)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i - len2 + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>, j = nxt[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s1 + <span class="number">1</span> &gt;&gt; s2 + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">len1 = <span class="built_in">strlen</span>(s1 + <span class="number">1</span>);</span><br><span class="line">len2 = <span class="built_in">strlen</span>(s2 + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">pre();</span><br><span class="line">kmp();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>~<font color="#FF7F27"><strong>我们遇到什么困难也不要怕，微笑着面对它！消除恐惧的最好办法就是面对恐惧！坚持就是胜利！加油！奥利给！</strong></font>~</p><hr><font color="#407600">【其他文章·数据结构】</font><ul><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/拓扑排序/">拓扑排序</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/图的表示/">图的表示</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/数据结构绪论/">数据结构绪论</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1574783133220&amp;amp;di=3be2714c61c60e81640b949c940ab16a&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fimg.mp.itc.cn%2Fupload%2F20170613%2Fca5280ac60284d4cb01f4f81be3b448b_th.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;模式匹配算法：KMP算法&quot;&gt;&lt;a href=&quot;#模式匹配算法：KMP算法&quot; class=&quot;headerlink&quot; title=&quot;模式匹配算法：KMP算法&quot;&gt;&lt;/a&gt;模式匹配算法：KMP算法&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; 图：北京航空航天大学&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;模式匹配是数据结构中字符串的一种基本运算，给定一个字符串P，要求在某个字符串T中找出与字符串P相同的所有子串，这就是模式匹配。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;模式匹配算法要解决的问题&quot;&gt;&lt;a href=&quot;#模式匹配算法要解决的问题&quot; class=&quot;headerlink&quot; title=&quot;模式匹配算法要解决的问题&quot;&gt;&lt;/a&gt;模式匹配算法要解决的问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;font color=&quot;#495DD8&quot;&gt;detection&lt;/font&gt; ：P&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;是否&lt;/strong&gt;&lt;/font&gt;出现&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;#495DD8&quot;&gt;location&lt;/font&gt; ：首次&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;在哪里&lt;/strong&gt;&lt;/font&gt;出现&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;#495DD8&quot;&gt;counting&lt;/font&gt; ：共有&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;几次&lt;/strong&gt;&lt;/font&gt;出现&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;#495DD8&quot;&gt;enumeration&lt;/font&gt; ：各出现&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;在哪里&lt;/strong&gt;&lt;/font&gt;？&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;绪论&quot;&gt;&lt;a href=&quot;#绪论&quot; class=&quot;headerlink&quot; title=&quot;绪论&quot;&gt;&lt;/a&gt;绪论&lt;/h2&gt;&lt;p&gt;&lt;code&gt;KMP算法&lt;/code&gt;（全称&lt;code&gt;Knuth-Morris-Pratt算法&lt;/code&gt;）是一种高效的模式匹配算法。在模式匹配算法中，常见的算法包括&lt;code&gt;BF算法&lt;/code&gt;（&lt;code&gt;朴素算法&lt;/code&gt;）、&lt;code&gt;KMP算法&lt;/code&gt;、&lt;code&gt;BM算法&lt;/code&gt;、&lt;code&gt;RK算法&lt;/code&gt;、&lt;code&gt;有限自动机算法&lt;/code&gt;、&lt;code&gt;Horspool算法&lt;/code&gt;、&lt;code&gt;Sunday算法&lt;/code&gt;。在这些算法中，最经典的算法非&lt;code&gt;KMP算法&lt;/code&gt;和&lt;code&gt;BM算法&lt;/code&gt;莫属。这两种算法都有一个共同点：抽象，理解难度大。实际上，&lt;code&gt;KMP算法&lt;/code&gt;还有一个明显特点：会者不难。本文内容默认你已经明白&lt;code&gt;BF算法&lt;/code&gt;的原理和不足（因此这部分内容将简单略过），展开讲述&lt;code&gt;KMP算法&lt;/code&gt;的原理、优点和&lt;code&gt;c++&lt;/code&gt;代码实现。相信你在学会&lt;code&gt;KMP算法&lt;/code&gt;之后将会有一种&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;“踏遍青山人未老，这边风景独好”&lt;/strong&gt;&lt;/font&gt;的快意。让我们开始吧。&lt;/p&gt;
&lt;h2 id=&quot;BF算法&quot;&gt;&lt;a href=&quot;#BF算法&quot; class=&quot;headerlink&quot; title=&quot;BF算法&quot;&gt;&lt;/a&gt;BF算法&lt;/h2&gt;&lt;p&gt;&lt;code&gt;BF算法&lt;/code&gt;的本质就是&lt;font color=&quot;#64ceaa&quot;&gt;暴力搜索&lt;/font&gt;。既然要在串&lt;code&gt;T&lt;/code&gt;中找出与串&lt;code&gt;P&lt;/code&gt;相同的所有子串，那不妨找出串&lt;code&gt;T&lt;/code&gt;中所有与串&lt;code&gt;P&lt;/code&gt;长度相同的子串，在逐个判断这个子串是否与串&lt;code&gt;P&lt;/code&gt;相同。具体的例子&lt;a href=&quot;https://www.bilibili.com/video/av11866460&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击这里&lt;/a&gt;或者&lt;font color=&quot;#FF7F27&quot;&gt;看下方的视频&lt;/font&gt;&lt;font color=&quot;#5F2CA5&quot;&gt;（讲得很形象了，应该不会有理解上的困难）&lt;/font&gt;。设&lt;code&gt;strlen(T) == n, strlen(P) == m&lt;/code&gt;，则&lt;code&gt;BF算法&lt;/code&gt;的&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;预处理时间&lt;/strong&gt;&lt;/font&gt;为$0$，&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;匹配时间&lt;/strong&gt;&lt;/font&gt;为$O(mn)$，&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;总时间复杂度&lt;/strong&gt;&lt;/font&gt;为$O(mn)$&lt;font color=&quot;#5F2CA5&quot;&gt;（简直是蜗速）&lt;/font&gt;，在大部分应用场景中并不&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;优秀&lt;/strong&gt;&lt;/font&gt;。&lt;/p&gt;
&lt;p&gt;&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=11866460&amp;cid=19594712&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; width=&quot;780&quot; height=&quot;520&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt;&lt;/p&gt;
&lt;h2 id=&quot;KMP算法&quot;&gt;&lt;a href=&quot;#KMP算法&quot; class=&quot;headerlink&quot; title=&quot;KMP算法&quot;&gt;&lt;/a&gt;KMP算法&lt;/h2&gt;&lt;h3 id=&quot;更高的效率&quot;&gt;&lt;a href=&quot;#更高的效率&quot; class=&quot;headerlink&quot; title=&quot;更高的效率&quot;&gt;&lt;/a&gt;更高的效率&lt;/h3&gt;&lt;p&gt;容易看出&lt;code&gt;BF算法&lt;/code&gt;的效率是十分蹩脚的，而它蹩脚的原因也很明显：在一次匹配尝试中，一旦失配（某一位匹配失败），就把串&lt;code&gt;P&lt;/code&gt;整体向右移动一位。在模拟算法运行过程中，我们发现如果开始匹配时第一位就失配，那么只向右移动一位的确无可厚非，毕竟说不定移动一位之后就会匹配成功呢；但是如果已经匹配了串&lt;code&gt;P&lt;/code&gt;的一部分了才失配，在向右移动一位之后，有时候（而且往往是经常）我们发现依然注定会匹配失败，也就是说在上次失败之后，向右移动一位再做尝试是根本不必要的，这种&lt;font color=&quot;#5F2CA5&quot;&gt;“只移动一位”&lt;/font&gt;的策略实际上造成了巨大的步骤浪费。那么有没有办法，把这些不必要的尝试舍弃，节约算法的运行时间呢？&lt;/p&gt;
&lt;p&gt;此处我们需要考虑以下问题，以便对&lt;code&gt;BF算法&lt;/code&gt;做出有效的改进：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=&quot;#495DD8&quot;&gt;为什么有一些尝试是注定徒劳的？&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;#495DD8&quot;&gt;如何判断哪些尝试需要舍弃？&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;#495DD8&quot;&gt;如果不是向右移动一位，又应该如何确定向右移动的位数？&lt;/font&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在看完&lt;a href=&quot;https://www.bilibili.com/video/av11866460&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击这里&lt;/a&gt;（还是上面那个链接）之后，前两个问题都能得到答案。在链接的视频讲解中，讲述者构造了一个前缀表数组&lt;code&gt;prefix table&lt;/code&gt;来确定串&lt;code&gt;P&lt;/code&gt;中每个从头开始的子串的&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;最长公共前后缀&lt;/strong&gt;&lt;/font&gt;（自身除外，以下省略此说明），一旦失配，就把串&lt;code&gt;P&lt;/code&gt;向右移动到失配位置左侧子串的&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;最长前缀&lt;/strong&gt;&lt;/font&gt;处，使它们重叠，也就是把下图中的&lt;font color=&quot;#A349A4&quot;&gt;1号&lt;/font&gt;移动到&lt;font color=&quot;#A349A4&quot;&gt;2号&lt;/font&gt;位置，继续从当前位置匹配，如果当前位置为串&lt;code&gt;T&lt;/code&gt;的结尾，则结束匹配。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/11/26/eZcoQNJmPrKtklh.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;那么问题来了：为什么要把&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;最长公共前缀&lt;/strong&gt;&lt;/font&gt;移动至&lt;font color=&quot;#64cceaa&quot;&gt;&lt;strong&gt;最长公共后缀&lt;/strong&gt;&lt;/font&gt;的位置？这个移动距离能不能更短？能不能更长？&lt;/p&gt;
&lt;blockquote&gt;
 &lt;font color=&quot;black&quot;&gt;**引理**&lt;/font&gt;  串的&lt;font color=&quot;#64ceaa&quot;&gt;**最长公共前后缀**&lt;/font&gt;的&lt;font color=&quot;#64ceaa&quot;&gt;**最长公共前后缀**&lt;/font&gt;是原串的&lt;font color=&quot;#64ceaa&quot;&gt;**次长公共前后缀**&lt;/font&gt;。

 &lt;font color=&quot;black&quot;&gt;**证明**&lt;/font&gt;  略&lt;font color=&quot;#5F2CA5&quot;&gt;~~（逃~~&lt;/font&gt;

&lt;/blockquote&gt;
&lt;p&gt;实际上，在&lt;code&gt;BF算法&lt;/code&gt;的一次匹配过程中，一旦失配，就把串&lt;code&gt;P&lt;/code&gt;整体向右移动一位再次尝试匹配。假设第一次匹配时在串&lt;code&gt;P&lt;/code&gt;的第&lt;code&gt;r + 1&lt;/code&gt;位失配，此时已经确定串&lt;code&gt;P&lt;/code&gt;失配位置的前&lt;code&gt;r&lt;/code&gt;项与串&lt;code&gt;T&lt;/code&gt;相应位置元素匹配，也确定了串&lt;code&gt;P&lt;/code&gt;失配位置的前&lt;code&gt;r - 1&lt;/code&gt;项与串&lt;code&gt;T&lt;/code&gt;相应位置元素匹配。那么第二次匹配成功，当且仅当在串&lt;code&gt;P&lt;/code&gt;的前&lt;code&gt;r&lt;/code&gt;项组成的子串中，前&lt;code&gt;r - 1&lt;/code&gt;位字符组成的前缀和后&lt;code&gt;r - 1&lt;/code&gt;位字符组成的后缀相同，即某一个&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;公共前后缀&lt;/strong&gt;&lt;/font&gt;长度为&lt;code&gt;r - 1&lt;/code&gt;。也就是说，如果匹配失败向右移动&lt;code&gt;s&lt;/code&gt;位，那么再次匹配成功的&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;必要条件&lt;/strong&gt;&lt;/font&gt;是串&lt;code&gt;P&lt;/code&gt;在失配位置前的子串的某一个&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;公共前后缀&lt;/strong&gt;&lt;/font&gt;长度为&lt;code&gt;r - s&lt;/code&gt;。如果串&lt;code&gt;P&lt;/code&gt;在失配位置前的子串的&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;最长公共前后缀&lt;/strong&gt;&lt;/font&gt;长度就是&lt;code&gt;r - s&lt;/code&gt;，匹配失败后向右移动了不足&lt;code&gt;s&lt;/code&gt;位，这意味着移动距离过短，将会做一遍无用功。&lt;/p&gt;
&lt;p&gt;如果移动距离过长，那就有可能会错过一个成功的匹配。如果匹配失败向右移动&lt;code&gt;s&lt;/code&gt;位，那么再次匹配成功的&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;必要条件&lt;/strong&gt;&lt;/font&gt;是串&lt;code&gt;P&lt;/code&gt;在失配位置前的子串的某一个&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;公共前后缀&lt;/strong&gt;&lt;/font&gt;长度为&lt;code&gt;r - s&lt;/code&gt;。注意这里是&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;必要条件&lt;/strong&gt;&lt;/font&gt;而不是&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;充分条件&lt;/strong&gt;&lt;/font&gt;，在把串&lt;code&gt;P&lt;/code&gt;向右移动的过程中，并不是在失配位置前随便放一个&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;公共前后缀&lt;/strong&gt;&lt;/font&gt;都能匹配成功，我们需要从&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;最长公共前后缀&lt;/strong&gt;&lt;/font&gt;开始尝试，逐步减少原失配位置前子串的长度，直到匹配成功或者串&lt;code&gt;P&lt;/code&gt;在失配位置前子串&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;最长公共前后缀&lt;/strong&gt;&lt;/font&gt;长度变为&lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;此处我们引入&lt;code&gt;next[]&lt;/code&gt;数组来记录在失配时应该把串&lt;code&gt;P&lt;/code&gt;的哪一位移动到当前位置。对于串&lt;code&gt;P&lt;/code&gt;的第&lt;code&gt;j + 1&lt;/code&gt;位的字符来说，&lt;code&gt;next[j + 1]&lt;/code&gt;的意义是由串&lt;code&gt;P&lt;/code&gt;的前&lt;code&gt;j&lt;/code&gt;项的子串中&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;最长公共前后缀&lt;/strong&gt;&lt;/font&gt;的长度。&lt;code&gt;next[]&lt;/code&gt;数组是&lt;code&gt;KMP算法&lt;/code&gt;降低&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;&lt;/font&gt;的关键，在预处理时就已经确定。下面介绍&lt;code&gt;next[]&lt;/code&gt;数组求法。&lt;/p&gt;
&lt;h3 id=&quot;next数组求法&quot;&gt;&lt;a href=&quot;#next数组求法&quot; class=&quot;headerlink&quot; title=&quot;next数组求法&quot;&gt;&lt;/a&gt;next数组求法&lt;/h3&gt;&lt;p&gt;如果你直接跳过了前面看到了这里，那说明你已经看了无数多参考资料，还是搞不懂&lt;code&gt;next[]&lt;/code&gt;数组求法的原理，几乎走投无路了。但是，正如B站鬼畜区某神所言：&lt;/p&gt;
&lt;p&gt;~&lt;font color=&quot;#FF7F27&quot;&gt;&lt;strong&gt;我们遇到什么困难也不要怕，微笑着面对它！消除恐惧的最好办法就是面对恐惧！坚持就是胜利！加油！奥利给！&lt;/strong&gt;&lt;/font&gt;~&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="C-plus-plus" scheme="https://G-SS-Hacker.github.io/tags/C-plus-plus/"/>
    
      <category term="算法" scheme="https://G-SS-Hacker.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://G-SS-Hacker.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="字符串" scheme="https://G-SS-Hacker.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>常用泰勒展开式</title>
    <link href="https://g-ss-hacker.github.io/%E5%B8%B8%E7%94%A8%E6%B3%B0%E5%8B%92%E5%B1%95%E5%BC%80%E5%BC%8F/"/>
    <id>https://g-ss-hacker.github.io/%E5%B8%B8%E7%94%A8%E6%B3%B0%E5%8B%92%E5%B1%95%E5%BC%80%E5%BC%8F/</id>
    <published>2019-11-07T14:22:19.000Z</published>
    <updated>2020-01-22T03:47:03.015Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.colorhub.me/IogF4QdtTJDwNcp_7Fkx7Zw0XBgIHtR3T4Okq_bH7dU/fill/0/500/ce/0/bG9jYWw6Ly8vMDgv/MTIvNjQyYWU2NmVk/ODlmOWRlNGE3Y2Yw/ODJmYjI0NGE1ODY0/MjgzMDgxMi5qcGVn.jpg" alt></p><h1 id="常用泰勒展开"><a href="#常用泰勒展开" class="headerlink" title="常用泰勒展开"></a>常用泰勒展开</h1><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><br>$(1)e^x=1+x+\frac{x^2}{2!}+\dots +\frac{x^n}{n!}+\frac{e^{\theta x}}{(n+1)!}x^{n+1}$<p></p><p>$(2)\sin x=x-\frac{x^3}{3!}+\frac{x^5}{5!}-\dots+(-1)^m\frac{x^{2m+1}}{(2m+1)!}+(-1)^{m+1}\frac{\cos \theta x}{(2m+3!)}x^{2m+3}$</p><p>$(3)\cos x=1-\frac{x^2}{2!}+\frac{x^4}{4!}-\dots+(-1)^m\frac{x^{2m}}{(2m)!}+(-1)^{m+1}\frac{\cos \theta x}{(2m+2)!}x^{2m+2}$</p><p>$(4)\ln(1+x)=x-\frac{x^2}{2}+\frac{x^3}{3}-\dots+(-1)^{n-1}\frac{x^n}{n}+(-1)^n\frac{x^{n+1}}{(n+1)(1+\theta x)^{n+1}}$</p><p>$(5)(1+x)^\alpha=\sum_{k=0}^n C_\alpha^n x^n+C_\alpha^{n+1}x^{n+1}(1+\theta x)^{\alpha -n-1}$</p><p><iframe src="//player.bilibili.com/player.html?aid=76292879&cid=130500535&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" width="780" height="520" allowfullscreen="true"> </iframe><br><a id="more"></a></p><hr><p>~<font color="#FF7F27"><strong>我们遇到什么困难也不要怕，微笑着面对它！消除恐惧的最好办法就是面对恐惧！坚持就是胜利！加油！奥利给！</strong></font>~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.colorhub.me/IogF4QdtTJDwNcp_7Fkx7Zw0XBgIHtR3T4Okq_bH7dU/fill/0/500/ce/0/bG9jYWw6Ly8vMDgv/MTIvNjQyYWU2NmVk/ODlmOWRlNGE3Y2Yw/ODJmYjI0NGE1ODY0/MjgzMDgxMi5qcGVn.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;常用泰勒展开&quot;&gt;&lt;a href=&quot;#常用泰勒展开&quot; class=&quot;headerlink&quot; title=&quot;常用泰勒展开&quot;&gt;&lt;/a&gt;常用泰勒展开&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;br&gt;$(1)e^x=1+x+\frac{x^2}{2!}+\dots +\frac{x^n}{n!}+\frac{e^{\theta x}}{(n+1)!}x^{n+1}$&lt;p&gt;&lt;/p&gt;
&lt;p&gt;$(2)\sin x=x-\frac{x^3}{3!}+\frac{x^5}{5!}-\dots+(-1)^m\frac{x^{2m+1}}{(2m+1)!}+(-1)^{m+1}\frac{\cos \theta x}{(2m+3!)}x^{2m+3}$&lt;/p&gt;
&lt;p&gt;$(3)\cos x=1-\frac{x^2}{2!}+\frac{x^4}{4!}-\dots+(-1)^m\frac{x^{2m}}{(2m)!}+(-1)^{m+1}\frac{\cos \theta x}{(2m+2)!}x^{2m+2}$&lt;/p&gt;
&lt;p&gt;$(4)\ln(1+x)=x-\frac{x^2}{2}+\frac{x^3}{3}-\dots+(-1)^{n-1}\frac{x^n}{n}+(-1)^n\frac{x^{n+1}}{(n+1)(1+\theta x)^{n+1}}$&lt;/p&gt;
&lt;p&gt;$(5)(1+x)^\alpha=\sum_{k=0}^n C_\alpha^n x^n+C_\alpha^{n+1}x^{n+1}(1+\theta x)^{\alpha -n-1}$&lt;/p&gt;
&lt;p&gt;&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=76292879&amp;cid=130500535&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; width=&quot;780&quot; height=&quot;520&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="微积分" scheme="https://G-SS-Hacker.github.io/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>矩阵章节总结</title>
    <link href="https://g-ss-hacker.github.io/%E7%9F%A9%E9%98%B5%E7%AB%A0%E8%8A%82%E6%80%BB%E7%BB%93/"/>
    <id>https://g-ss-hacker.github.io/%E7%9F%A9%E9%98%B5%E7%AB%A0%E8%8A%82%E6%80%BB%E7%BB%93/</id>
    <published>2019-10-28T13:43:02.000Z</published>
    <updated>2019-11-28T14:49:12.849Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1573141304163&amp;di=91f3aa900d4bd602b9a233ff478c2bbc&amp;imgtype=0&amp;src=http%3A%2F%2Fdingyue.nosdn.127.net%2FvXsWUrS27VAb4s%3DrSMlMPRzjkRzux6S4Tx9RXqej1%3D%3DW51544709511256compressflag.jpg" alt></p><h1 id="矩阵章节总结"><a href="#矩阵章节总结" class="headerlink" title="矩阵章节总结"></a>矩阵章节总结</h1><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><br>矩阵（matrix）形式优美，应用广泛。但是笔者相当头痛矩阵问题。实际上，矩阵的计算绝对不能靠硬算（硬算的事交给<code>Matlab</code>就好了，实际上计算机做矩阵运算，为了避免数值不稳定问题，使用的是和人计算不同的算法），而是灵活变形后运用基本的计算公式；矩阵的证明则更离不开对公式及其推论的灵活运用。笔者从题海中抽象出矩阵计算的常用思想和性质。作者实属菜鸟，水平很菜，将就看看吧 ╮(╯_╰)╭<p></p><h2 id="运算律"><a href="#运算律" class="headerlink" title="运算律"></a>运算律</h2><ol><li><p>$ {AB}= {BA}$时，矩阵运算满足<code>交换律</code>，故以下运算皆成立</p><p>$(\mathrm{i})( {A}\pm  {B})^2= {A}^2 \pm 2 {AB} + {B}^2$</p><p>$(\mathrm{ii})( {A}+ {B})( {A}- {B})= {A}^2- {B}^2$</p><p>$(\mathrm{iii})( {AB})^2=( {BA})^2$</p></li><li><p>$ {A}^*， {A}’， {A}^{-1}$组合会产生十分令人头疼的问题，使用以下公式来缓解头疼</p><p>$(\mathrm{i})( {AB})’= {B}’ {A}’$</p><p>$(\mathrm{ii})( {AB})^{-1}= {B}^{-1} {A}^{-1}$</p><p>$(\mathrm{iii})( {A}^*)^{-1}=( {A}^{-1})^*$</p></li><li><p>带系数的情况</p><p>$(\mathrm{i})|k {A}|=k^n| {A}|$</p><p>$(\mathrm{ii})(k {A})^{-1}=\frac1{k} {A}^{-1}$</p><p>$(\mathrm{iii})(k {A})’=k {A}’$</p><p>$(\mathrm{iv})\overline{k {A}}=\overline{k}\overline{ {A}}$</p></li></ol><h2 id="共轭矩阵"><a href="#共轭矩阵" class="headerlink" title="共轭矩阵"></a>共轭矩阵</h2><p>记住以下四个公式，以备突然考到</p><p>$(\mathrm{i})\overline{ {A}+ {B}}=\overline{ {A}}+\overline{ {B}}$</p><p>$(\mathrm{ii})\overline{k {A}}=\overline{k}\overline{ {A}}$</p><p>$(\mathrm{iii})\overline{ {AB}}=\overline{ {A}}\overline{ {B}}$</p><p>$(\mathrm{iv})|\overline{ {A}}|=\overline{| {A}|}$</p><p>简单地记，凡是涉及共轭的题目，计算的时候看起来能取共轭的都取共轭</p><h2 id="伴随矩阵"><a href="#伴随矩阵" class="headerlink" title="伴随矩阵"></a>伴随矩阵</h2><ol><li><p>看到$ {A}^*$，以下公式至少用其一</p><p>$(\mathrm{i}) {A}^* {A}= {A} {A}^*=| {A}| {E}$</p><p>$(\mathrm{ii}) {A}^{-1}=\frac{ {A}^*}{| {A}|}$</p><p>$(\mathrm{iii})| {A}^*|=| {A}|^{n-1}$</p><p>$(\mathrm{iv})( {A}^*)^*=| {A}|^{n-2} {A}$</p></li><li><p>伴随矩阵的特殊性质：极端的伴随矩阵</p><script type="math/tex; mode=display">{R}({A}^*)=\begin{cases}     n,\quad {R}({A})=n\\    1,\quad {R}({A})=n-1\\    0,\quad {R}({A})<n-1\end{cases}</script></li></ol><h2 id="杂题"><a href="#杂题" class="headerlink" title="杂题"></a>杂题</h2><ol><li><p>判断矩阵可逆的方法：</p><p>$(\mathrm{i}) {AB}= {BA}=E$</p><p>$(\mathrm{ii}) {R}( {A})=n$</p><p>$(\mathrm{iii})| {A}|=0$</p><p>$(\mathrm{iv}) {A}= {P}_1 {P}_2 \dots  {P}_k$</p></li><li><p>初变不变秩，不变奇异性</p></li><li><p>行阶梯、行最简、标准形</p></li><li><p>求逆方法：公式法、辅助矩阵法</p></li></ol><h2 id="分块矩阵运算"><a href="#分块矩阵运算" class="headerlink" title="分块矩阵运算"></a>分块矩阵运算</h2><ol><li><p>对角方阵求逆（仅对对角方阵有效）：</p><script type="math/tex; mode=display">\left(\begin {array}{ccc}    {A}_{11}& & & &\\     & {A}_{22}& & &\\     & & \ddots & &\\     & & & {A}_{ss}&\end {array}\right)^m=\left(\begin {array}{ccc}    {A}_{11}^m& & & &\\     & {A}_{22}^m& & &\\     & & \ddots & &\\     & & & {A}_{ss}^m&\end {array}\right)</script></li><li><p>特殊矩阵求逆矩阵，是否还应保持原来的顺序：</p><p>$(\mathrm{i})$主对角：$\searrow$仍为$\searrow$</p><p>$(\mathrm{ii})$次对角：$\swarrow$变为$\nearrow$</p></li><li><p>思想：运用<code>第三类初等变换</code></p><script type="math/tex; mode=display">\left|\begin{array}{cccc} {A} & {C} \\ {D} & {B} \end{array} \right|=|{A}||{B}-{DA}^{-1}{C}|</script></li><li><p>分块矩阵的秩（高频使用，按重要性降序排列）：</p><p>$(\mathrm{i})R(A+B)\leq R(A)+R(B),\quad R(A-B)\leq R(A)+R(B)$</p><p>$(\mathrm{ii})R(AB)\leq min\{R(A),R(B)\}$</p><p>$(\mathrm{iii})R(A|B)\leq R(A)+R(B),\quad R(\frac{A}{B})\leq R(A)+R(B)$</p><p>$(\mathrm{iv})R \left(\begin{array}{ccc} A &amp; 0\\0 &amp; B \end{array} \right)=R(A)+R(B)$</p><p>$(\mathrm{v})R \left(\begin{array}{ccc} A &amp; C\\0 &amp; B \end{array} \right)\ge R(A)+R(B)$，若$A$，$B$其一可逆则取等</p><p>$(\mathrm{vi})$设$A$为$m\times n$矩阵，$B$为$n\times p$矩阵（有时题目条件会简化为$A$、$B$为同阶方阵），则$R(AB) \ge R(A)+R(B)-n$；特别地，当$AB=0$时，$R(A)+R(B)\le n$</p><p>$(\mathrm{iii})(\mathrm{iv})(\mathrm{v})$皆易证</p><a id="more"></a><hr><p>~<font color="#FF7F27"><strong>我们遇到什么困难也不要怕，微笑着面对它！消除恐惧的最好办法就是面对恐惧！坚持就是胜利！加油！奥利给！</strong></font>~</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1573141304163&amp;amp;di=91f3aa900d4bd602b9a233ff478c2bbc&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fdingyue.nosdn.127.net%2FvXsWUrS27VAb4s%3DrSMlMPRzjkRzux6S4Tx9RXqej1%3D%3DW51544709511256compressflag.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;矩阵章节总结&quot;&gt;&lt;a href=&quot;#矩阵章节总结&quot; class=&quot;headerlink&quot; title=&quot;矩阵章节总结&quot;&gt;&lt;/a&gt;矩阵章节总结&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;br&gt;矩阵（matrix）形式优美，应用广泛。但是笔者相当头痛矩阵问题。实际上，矩阵的计算绝对不能靠硬算（硬算的事交给&lt;code&gt;Matlab&lt;/code&gt;就好了，实际上计算机做矩阵运算，为了避免数值不稳定问题，使用的是和人计算不同的算法），而是灵活变形后运用基本的计算公式；矩阵的证明则更离不开对公式及其推论的灵活运用。笔者从题海中抽象出矩阵计算的常用思想和性质。作者实属菜鸟，水平很菜，将就看看吧 ╮(╯_╰)╭&lt;p&gt;&lt;/p&gt;
&lt;h2 id=&quot;运算律&quot;&gt;&lt;a href=&quot;#运算律&quot; class=&quot;headerlink&quot; title=&quot;运算律&quot;&gt;&lt;/a&gt;运算律&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;$ {AB}= {BA}$时，矩阵运算满足&lt;code&gt;交换律&lt;/code&gt;，故以下运算皆成立&lt;/p&gt;
&lt;p&gt;$(\mathrm{i})( {A}\pm  {B})^2= {A}^2 \pm 2 {AB} + {B}^2$&lt;/p&gt;
&lt;p&gt;$(\mathrm{ii})( {A}+ {B})( {A}- {B})= {A}^2- {B}^2$&lt;/p&gt;
&lt;p&gt;$(\mathrm{iii})( {AB})^2=( {BA})^2$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;$ {A}^*， {A}’， {A}^{-1}$组合会产生十分令人头疼的问题，使用以下公式来缓解头疼&lt;/p&gt;
&lt;p&gt;$(\mathrm{i})( {AB})’= {B}’ {A}’$&lt;/p&gt;
&lt;p&gt;$(\mathrm{ii})( {AB})^{-1}= {B}^{-1} {A}^{-1}$&lt;/p&gt;
&lt;p&gt;$(\mathrm{iii})( {A}^*)^{-1}=( {A}^{-1})^*$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;带系数的情况&lt;/p&gt;
&lt;p&gt;$(\mathrm{i})|k {A}|=k^n| {A}|$&lt;/p&gt;
&lt;p&gt;$(\mathrm{ii})(k {A})^{-1}=\frac1{k} {A}^{-1}$&lt;/p&gt;
&lt;p&gt;$(\mathrm{iii})(k {A})’=k {A}’$&lt;/p&gt;
&lt;p&gt;$(\mathrm{iv})\overline{k {A}}=\overline{k}\overline{ {A}}$&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;共轭矩阵&quot;&gt;&lt;a href=&quot;#共轭矩阵&quot; class=&quot;headerlink&quot; title=&quot;共轭矩阵&quot;&gt;&lt;/a&gt;共轭矩阵&lt;/h2&gt;&lt;p&gt;记住以下四个公式，以备突然考到&lt;/p&gt;
&lt;p&gt;$(\mathrm{i})\overline{ {A}+ {B}}=\overline{ {A}}+\overline{ {B}}$&lt;/p&gt;
&lt;p&gt;$(\mathrm{ii})\overline{k {A}}=\overline{k}\overline{ {A}}$&lt;/p&gt;
&lt;p&gt;$(\mathrm{iii})\overline{ {AB}}=\overline{ {A}}\overline{ {B}}$&lt;/p&gt;
&lt;p&gt;$(\mathrm{iv})|\overline{ {A}}|=\overline{| {A}|}$&lt;/p&gt;
&lt;p&gt;简单地记，凡是涉及共轭的题目，计算的时候看起来能取共轭的都取共轭&lt;/p&gt;
&lt;h2 id=&quot;伴随矩阵&quot;&gt;&lt;a href=&quot;#伴随矩阵&quot; class=&quot;headerlink&quot; title=&quot;伴随矩阵&quot;&gt;&lt;/a&gt;伴随矩阵&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;看到$ {A}^*$，以下公式至少用其一&lt;/p&gt;
&lt;p&gt;$(\mathrm{i}) {A}^* {A}= {A} {A}^*=| {A}| {E}$&lt;/p&gt;
&lt;p&gt;$(\mathrm{ii}) {A}^{-1}=\frac{ {A}^*}{| {A}|}$&lt;/p&gt;
&lt;p&gt;$(\mathrm{iii})| {A}^*|=| {A}|^{n-1}$&lt;/p&gt;
&lt;p&gt;$(\mathrm{iv})( {A}^*)^*=| {A}|^{n-2} {A}$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;伴随矩阵的特殊性质：极端的伴随矩阵&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
{R}({A}^*)=\begin{cases} 
    n,\quad {R}({A})=n\\
    1,\quad {R}({A})=n-1\\
    0,\quad {R}({A})&lt;n-1
\end{cases}&lt;/script&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;杂题&quot;&gt;&lt;a href=&quot;#杂题&quot; class=&quot;headerlink&quot; title=&quot;杂题&quot;&gt;&lt;/a&gt;杂题&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;判断矩阵可逆的方法：&lt;/p&gt;
&lt;p&gt;$(\mathrm{i}) {AB}= {BA}=E$&lt;/p&gt;
&lt;p&gt;$(\mathrm{ii}) {R}( {A})=n$&lt;/p&gt;
&lt;p&gt;$(\mathrm{iii})| {A}|=0$&lt;/p&gt;
&lt;p&gt;$(\mathrm{iv}) {A}= {P}_1 {P}_2 \dots  {P}_k$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;初变不变秩，不变奇异性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;行阶梯、行最简、标准形&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;求逆方法：公式法、辅助矩阵法&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;分块矩阵运算&quot;&gt;&lt;a href=&quot;#分块矩阵运算&quot; class=&quot;headerlink&quot; title=&quot;分块矩阵运算&quot;&gt;&lt;/a&gt;分块矩阵运算&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;对角方阵求逆（仅对对角方阵有效）：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\left(\begin {array}{ccc}
    {A}_{11}&amp; &amp; &amp; &amp;\\
     &amp; {A}_{22}&amp; &amp; &amp;\\
     &amp; &amp; \ddots &amp; &amp;\\
     &amp; &amp; &amp; {A}_{ss}&amp;
\end {array}\right)^m
=
\left(\begin {array}{ccc}
    {A}_{11}^m&amp; &amp; &amp; &amp;\\
     &amp; {A}_{22}^m&amp; &amp; &amp;\\
     &amp; &amp; \ddots &amp; &amp;\\
     &amp; &amp; &amp; {A}_{ss}^m&amp;
\end {array}\right)&lt;/script&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;特殊矩阵求逆矩阵，是否还应保持原来的顺序：&lt;/p&gt;
&lt;p&gt;$(\mathrm{i})$主对角：$\searrow$仍为$\searrow$&lt;/p&gt;
&lt;p&gt;$(\mathrm{ii})$次对角：$\swarrow$变为$\nearrow$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;思想：运用&lt;code&gt;第三类初等变换&lt;/code&gt;&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\left|\begin{array}{cccc} {A} &amp; {C} \\ {D} &amp; {B} \end{array} \right|=|{A}||{B}-{DA}^{-1}{C}|&lt;/script&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分块矩阵的秩（高频使用，按重要性降序排列）：&lt;/p&gt;
&lt;p&gt;$(\mathrm{i})R(A+B)\leq R(A)+R(B),\quad R(A-B)\leq R(A)+R(B)$&lt;/p&gt;
&lt;p&gt;$(\mathrm{ii})R(AB)\leq min\{R(A),R(B)\}$&lt;/p&gt;
&lt;p&gt;$(\mathrm{iii})R(A|B)\leq R(A)+R(B),\quad R(\frac{A}{B})\leq R(A)+R(B)$&lt;/p&gt;
&lt;p&gt;$(\mathrm{iv})R \left(\begin{array}{ccc} A &amp;amp; 0\\0 &amp;amp; B \end{array} \right)=R(A)+R(B)$&lt;/p&gt;
&lt;p&gt;$(\mathrm{v})R \left(\begin{array}{ccc} A &amp;amp; C\\0 &amp;amp; B \end{array} \right)\ge R(A)+R(B)$，若$A$，$B$其一可逆则取等&lt;/p&gt;
&lt;p&gt;$(\mathrm{vi})$设$A$为$m\times n$矩阵，$B$为$n\times p$矩阵（有时题目条件会简化为$A$、$B$为同阶方阵），则$R(AB) \ge R(A)+R(B)-n$；特别地，当$AB=0$时，$R(A)+R(B)\le n$&lt;/p&gt;
&lt;p&gt;$(\mathrm{iii})(\mathrm{iv})(\mathrm{v})$皆易证&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="线性代数" scheme="https://G-SS-Hacker.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>行列式章节总结</title>
    <link href="https://g-ss-hacker.github.io/%E8%A1%8C%E5%88%97%E5%BC%8F%E7%AB%A0%E8%8A%82%E6%80%BB%E7%BB%93/"/>
    <id>https://g-ss-hacker.github.io/%E8%A1%8C%E5%88%97%E5%BC%8F%E7%AB%A0%E8%8A%82%E6%80%BB%E7%BB%93/</id>
    <published>2019-10-27T06:37:35.000Z</published>
    <updated>2019-12-04T13:26:28.286Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/10/27/y2VaJbGAj3O6uxW.png" alt></p><h1 id="行列式章节总结"><a href="#行列式章节总结" class="headerlink" title="行列式章节总结"></a>行列式章节总结</h1><blockquote><p>图：刺客伍六七</p></blockquote><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><br>行列式形式优美，应用广泛。但是笔者相当头痛行列式的计算问题和行列式等式的证明问题。为了让行列式计算与证明不那么难算，笔者从题海中抽象出行列式计算和证明的常用算法和性质。作者水平不高，将就看看吧 ╮(╯_╰)╭<p></p><h2 id="行列式计算公式"><a href="#行列式计算公式" class="headerlink" title="行列式计算公式"></a>行列式计算公式</h2><p><strong>1.行列式定义</strong></p><script type="math/tex; mode=display">\left|\begin{array}{cccc}    a_{11} &    a_{12} &    \dots &     a_{1n}\\    a_{21} &    a_{22} &     \dots &     a_{2n}\\    \vdots &    \vdots &           &     \vdots\\    a_{n1} &    a_{n2} &     \dots &     a_{nn}\\\end{array}\right|= \sum(-1)^{t(p_1p_2\dots p_n)}a_{p_11}a_{p_22}\dots a_{p_nn}</script><p>特别地，对于二阶和三阶行列式，可直接用<code>对角线法则</code>求出结果。</p><p><strong>2.行列式展开定理</strong></p><p><strong>引理</strong>    如果$n$阶行列式$D$中第$i$行（列）所有元素除$a_{ij}$外都是零，那么，$D$等于$a_{ij}$与它的代数余子式$A_{ij}$的乘积，即$D=a_{ij}A_{ij}$。</p><p><strong>展开定理</strong>     行列式等于它的任一行（列）的各元素与其代数余子式的乘积之和，即</p><script type="math/tex; mode=display">D=a_{i1}A_{i1}+a_{i2}A_{i2}+\dots a_{in}A_{in},\quad i=1,2,\dots,n;\\D=a_{1j}A_{1j}+a_{2j}A_{2j}+\dots a_{nj}A_{nj},\quad j=1,2,\dots,n.</script><p><strong>推论</strong>    行列式$D$的任一行（列）元素与另一行（列）对应元素的代数余子式乘积之和等于$0$，即</p><script type="math/tex; mode=display">a_{i1}A_{j1}+a_{i2}A_{j2}+\dots a_{in}A_{jn}=0,\quad i \ne j,\quad i,j=1,2,\dots ,n;\\a_{1i}A_{1j}+a_{2i}A_{2j}+\dots a_{ni}A_{nj}=0,\quad i \ne j,\quad i,j=1,2,\dots ,n.</script><p>行列式结果等于$0$的定理常用于填空题和判断题。</p><p><strong>3.范德蒙定理</strong></p><p>范德蒙定理的证明用到了<code>第二数学归纳法</code>，在行列式和矩阵中，任何看起来可以用<code>数学归纳法</code>证明的题目（甚至包括一部分计算题），都可以用<code>数学归纳法</code>来做。</p><script type="math/tex; mode=display">D_n=\left|\begin{array}{cccc}    1 &    1 &    \dots &     1\\    x_1 &    x_2 &     \dots &     x_n\\    x_1^2& x_2^2& \dots & x_n^2\\    \vdots &    \vdots &           &     \vdots\\    x_1^{n-1} &    x_2^{n-1} &     \dots &     x_n^{n-1}\\\end{array}\right|= \prod_{1\leq j<i \leq n}(x_i-x_j),\quad n \ge 2</script><p>简单地记就是，每两个不同的项全部按顺序作差乘一遍。</p><p><strong>4.凯恩法则</strong></p><p>遇见线性方程组就上凯恩法则，把消元问题化为行列式计算问题。</p><a id="more"></a><h2 id="行列式七条性质"><a href="#行列式七条性质" class="headerlink" title="行列式七条性质"></a>行列式七条性质</h2><p>行列式七条性质常用与选择题和填空题，以及某些命题的证明，计算时得出来的结果要么为$0$，要么为题目所给行列式的值得整数倍。</p><p><strong>1.行列式与其转置相等</strong></p><p><strong>2.互换两行（列）变号</strong></p><p><strong>3.两行（列）相同为零</strong></p><p><strong>4.行（列）提公因子</strong></p><p><strong>5.两行（列）成比例为零</strong></p><p><strong>6.如果行列式的某一行（列）是两项和的形式，那么这个行列式就等于两个行列式的和</strong></p><p><strong>7.某行（列）的倍数加到另一行（列），行列式不变</strong></p><h2 id="杂题"><a href="#杂题" class="headerlink" title="杂题"></a>杂题</h2><p><strong>1.</strong> $|kA|=k^n|A|,\quad |A^m|=|A|^m,\quad A_{n \times n}$</p><p><strong>2.</strong>行列式乘法定理： $|AB|=|A||B|,\quad A_{n \times n},\quad B_{n \times n}$</p><p>然而，$|A+B|\ne|A|+|B|$</p><p><strong>3.</strong> $|A^m|=|A|^m,\quad A_{n \times n}$</p><p><strong>4.</strong> $|A’|=|A|,\quad A_{n\times n}$</p><p><strong>5.</strong> $A^*A=AA^*=|A|E$</p><p><strong>6.</strong>$A^{-1}=\frac{A^*}{|A|}$</p><p><strong>7.</strong>$|A^{*}|=|A|^{n-1},\quad A^{*}=|A|A^{-1}$</p><p><strong>8.</strong>$(A^{*})^{*}=|A|^{n-2}A$</p><p><strong>9.</strong>若$A\sim B$，则$|A|=|B|$</p><p><strong>10.</strong>$|A^{-1}|=\frac1{|A|}$</p><h2 id="分块矩阵的行列式"><a href="#分块矩阵的行列式" class="headerlink" title="分块矩阵的行列式"></a>分块矩阵的行列式</h2><p><strong>1.对角形</strong></p><p>对方阵$A_{11},A_{22},\dots A_{ss}$，若满足主对角线上的三角形，则其构成的行列式结果为</p><script type="math/tex; mode=display">|A_{11}||A_{22}|\dots |A_{ss}|</script><p>对方阵$A_{11},A_{22},\dots A_{ss}$，若满足次对角线上的三角形，则其构成的行列式结果为</p><script type="math/tex; mode=display">(-1)^{m \times n}|A_{11}||A_{22}|\dots |A_{ss}|</script><p><strong>2.在非常严苛的条件下以下等式成立。</strong></p><script type="math/tex; mode=display">\left|\begin{array}{cccc} A & B \\ C & D \end{array} \right|=|AD-CB|,\quad AC=CA</script><p><strong>3.</strong>$|\lambda E_m -AB|=\lambda^{m-n}|\lambda E_n-BA|,\quad A_{m \times n},\quad B_{n \times m},\quad m &gt; n$</p><p>该公式的证明运用了分块方阵的<code>第三类初等变换</code>（第三类初等变换不改变分块方阵的行列式的值），这是一个重要的思想，是分块矩阵行列式运算的根本方法，常用于分块方阵的计算和证明中。</p><p><strong>4.</strong>令$n=1$，$|\lambda E_m-\alpha \beta’|=\lambda^{m-1}|\lambda-\beta’\alpha|$，$\alpha$，$\beta$为$m\times 1$向量</p><p><strong>5.</strong>令$\lambda=1$，$|E_m-AB|=|En-BA|$</p><p><strong>6.</strong>令$m=n$，$|\lambda E_m-AB|=|\lambda E_n-BA|$</p><!--more--><hr><p>~<font color="#FF7F27"><strong>我们遇到什么困难也不要怕，微笑着面对它！消除恐惧的最好办法就是面对恐惧！坚持就是胜利！加油！奥利给！</strong></font>~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/10/27/y2VaJbGAj3O6uxW.png&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;行列式章节总结&quot;&gt;&lt;a href=&quot;#行列式章节总结&quot; class=&quot;headerlink&quot; title=&quot;行列式章节总结&quot;&gt;&lt;/a&gt;行列式章节总结&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;图：刺客伍六七&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;br&gt;行列式形式优美，应用广泛。但是笔者相当头痛行列式的计算问题和行列式等式的证明问题。为了让行列式计算与证明不那么难算，笔者从题海中抽象出行列式计算和证明的常用算法和性质。作者水平不高，将就看看吧 ╮(╯_╰)╭&lt;p&gt;&lt;/p&gt;
&lt;h2 id=&quot;行列式计算公式&quot;&gt;&lt;a href=&quot;#行列式计算公式&quot; class=&quot;headerlink&quot; title=&quot;行列式计算公式&quot;&gt;&lt;/a&gt;行列式计算公式&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1.行列式定义&lt;/strong&gt;&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\left|\begin{array}{cccc}
    a_{11} &amp;    a_{12} &amp;    \dots &amp;     a_{1n}\\
    a_{21} &amp;    a_{22} &amp;     \dots &amp;     a_{2n}\\
    \vdots &amp;    \vdots &amp;           &amp;     \vdots\\
    a_{n1} &amp;    a_{n2} &amp;     \dots &amp;     a_{nn}\\
\end{array}\right|
= 
\sum(-1)^{t(p_1p_2\dots p_n)}a_{p_11}a_{p_22}\dots a_{p_nn}&lt;/script&gt;&lt;p&gt;特别地，对于二阶和三阶行列式，可直接用&lt;code&gt;对角线法则&lt;/code&gt;求出结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.行列式展开定理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;引理&lt;/strong&gt;    如果$n$阶行列式$D$中第$i$行（列）所有元素除$a_{ij}$外都是零，那么，$D$等于$a_{ij}$与它的代数余子式$A_{ij}$的乘积，即$D=a_{ij}A_{ij}$。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;展开定理&lt;/strong&gt;     行列式等于它的任一行（列）的各元素与其代数余子式的乘积之和，即&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
D=a_{i1}A_{i1}+a_{i2}A_{i2}+\dots a_{in}A_{in},\quad i=1,2,\dots,n;\\
D=a_{1j}A_{1j}+a_{2j}A_{2j}+\dots a_{nj}A_{nj},\quad j=1,2,\dots,n.&lt;/script&gt;&lt;p&gt;&lt;strong&gt;推论&lt;/strong&gt;    行列式$D$的任一行（列）元素与另一行（列）对应元素的代数余子式乘积之和等于$0$，即&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
a_{i1}A_{j1}+a_{i2}A_{j2}+\dots a_{in}A_{jn}=0,\quad i \ne j,\quad i,j=1,2,\dots ,n;\\
a_{1i}A_{1j}+a_{2i}A_{2j}+\dots a_{ni}A_{nj}=0,\quad i \ne j,\quad i,j=1,2,\dots ,n.&lt;/script&gt;&lt;p&gt;行列式结果等于$0$的定理常用于填空题和判断题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.范德蒙定理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;范德蒙定理的证明用到了&lt;code&gt;第二数学归纳法&lt;/code&gt;，在行列式和矩阵中，任何看起来可以用&lt;code&gt;数学归纳法&lt;/code&gt;证明的题目（甚至包括一部分计算题），都可以用&lt;code&gt;数学归纳法&lt;/code&gt;来做。&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
D_n=
\left|\begin{array}{cccc}
    1 &amp;    1 &amp;    \dots &amp;     1\\
    x_1 &amp;    x_2 &amp;     \dots &amp;     x_n\\
    x_1^2&amp; x_2^2&amp; \dots &amp; x_n^2\\
    \vdots &amp;    \vdots &amp;           &amp;     \vdots\\
    x_1^{n-1} &amp;    x_2^{n-1} &amp;     \dots &amp;     x_n^{n-1}\\
\end{array}\right|
= 
\prod_{1\leq j&lt;i \leq n}(x_i-x_j),\quad n \ge 2&lt;/script&gt;&lt;p&gt;简单地记就是，每两个不同的项全部按顺序作差乘一遍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.凯恩法则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;遇见线性方程组就上凯恩法则，把消元问题化为行列式计算问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="线性代数" scheme="https://G-SS-Hacker.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>高阶求导公式</title>
    <link href="https://g-ss-hacker.github.io/%E9%AB%98%E9%98%B6%E6%B1%82%E5%AF%BC%E5%85%AC%E5%BC%8F/"/>
    <id>https://g-ss-hacker.github.io/%E9%AB%98%E9%98%B6%E6%B1%82%E5%AF%BC%E5%85%AC%E5%BC%8F/</id>
    <published>2019-10-21T09:42:24.000Z</published>
    <updated>2019-12-01T13:07:51.885Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/10/21/qfvbeiV7g8M6N9G.png" alt></p><h1 id="高阶求导公式"><a href="#高阶求导公式" class="headerlink" title="高阶求导公式"></a>高阶求导公式</h1><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><br>$ (1)(a^x)^{(n)}=a^x (\ln a)$<p></p><p>$ (2)(e^{ax})^{(n)} = a^n e ^{ax} $</p><p>$(3)(\sin x)^{(n)}=\sin(x+\frac {n\pi}2)$    </p><p>$(4)(\cos x)^{(n)}=\cos(x+\frac{n\pi}2)$</p><p>$(5)(x^a)^{(n)}=a(a-1)\dots(a-n+1)x^{a-n},若n&gt;a，则导数等于零$</p><p>$(6)[\ln (x+a)]^{(n)}=(-1)^n \frac{(n-1)!}{(x+a)^n}，特别地，令a=0，(\ln x)^{(n)}=(-1)^n\frac{(n-1)!}{x^n}$</p><p>$(7)(\frac1{ax+b})^{(n)}=(-a)^{n} \frac{n!}{(ax+b)^{n+1}}，特别地，令a=1,(\frac1{x+b})=(-1)^n \frac{n!}{(x+b)^{n+1}}$</p><p>$(8)Leibniz公式：[f(x)g(x)]^{(n)}=\sum_{k=0}^n C_n^kf^{(k)}(x)g^{(n-k)}(x)，C_n^k=\frac{n!}{k!(n-k)!)}$</p><a id="more"></a><p>$(9)(f(x)\pm g(x))^{(n)}=f^{(n)}(x)+g^{(n)}(x)$</p><p>$(10)(af(x))^{(n)}=af^{(n)}(x)$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/10/21/qfvbeiV7g8M6N9G.png&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;高阶求导公式&quot;&gt;&lt;a href=&quot;#高阶求导公式&quot; class=&quot;headerlink&quot; title=&quot;高阶求导公式&quot;&gt;&lt;/a&gt;高阶求导公式&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;br&gt;$ (1)(a^x)^{(n)}=a^x (\ln a)$&lt;p&gt;&lt;/p&gt;
&lt;p&gt;$ (2)(e^{ax})^{(n)} = a^n e ^{ax} $&lt;/p&gt;
&lt;p&gt;$(3)(\sin x)^{(n)}=\sin(x+\frac {n\pi}2)$    &lt;/p&gt;
&lt;p&gt;$(4)(\cos x)^{(n)}=\cos(x+\frac{n\pi}2)$&lt;/p&gt;
&lt;p&gt;$(5)(x^a)^{(n)}=a(a-1)\dots(a-n+1)x^{a-n},若n&amp;gt;a，则导数等于零$&lt;/p&gt;
&lt;p&gt;$(6)[\ln (x+a)]^{(n)}=(-1)^n \frac{(n-1)!}{(x+a)^n}，特别地，令a=0，(\ln x)^{(n)}=(-1)^n\frac{(n-1)!}{x^n}$&lt;/p&gt;
&lt;p&gt;$(7)(\frac1{ax+b})^{(n)}=(-a)^{n} \frac{n!}{(ax+b)^{n+1}}，特别地，令a=1,(\frac1{x+b})=(-1)^n \frac{n!}{(x+b)^{n+1}}$&lt;/p&gt;
&lt;p&gt;$(8)Leibniz公式：[f(x)g(x)]^{(n)}=\sum_{k=0}^n C_n^kf^{(k)}(x)g^{(n-k)}(x)，C_n^k=\frac{n!}{k!(n-k)!)}$&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="微积分" scheme="https://G-SS-Hacker.github.io/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>拓扑排序</title>
    <link href="https://g-ss-hacker.github.io/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    <id>https://g-ss-hacker.github.io/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</id>
    <published>2019-10-17T15:17:33.000Z</published>
    <updated>2019-12-04T13:27:57.360Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/10/17/Q4afFcoLyVZz91B.jpg" alt></p><h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><blockquote><p>图：索菲亚教堂</p></blockquote><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><p></p><blockquote><p>拓扑是研究几何图形或空间在连续改变形状后还能保持不变的一些性质的一个学科。它只考虑物体间的位置关系而不考虑它们的形状和大小。</p></blockquote><h2 id="AOV网"><a href="#AOV网" class="headerlink" title="AOV网"></a>AOV网</h2><p>在工程领域，一个大规模工程常被拆分为多个子工程，这些子工程被称为<strong>活动（Activity）</strong>，在有向图中以<strong>顶点（Vertex）</strong>表示活动，以有向边表示活动之间的先后关系，这样的有向图被称为<strong>AOV网（Activity On Vertex Network）</strong>。在AOV网中，如果出现了闭环，就意味着有若干个活动将被无限次重复，工程将永远无法完成；因此，一个具有实用价值的AOV网，必定是一个<strong>有向无环图（DAG，Directed Acyclic Graph）</strong>。</p><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><p>对于一个有向无环图$G=(V,E)$，其拓扑排序是其上顶点的一个线性排序：对于有向边$(u,v)\in E$，顶点$u$在排序中在顶点$v$的前面（如果$G$包含环路，则不可能产生一个线性排序）。可以将$G$上各顶点在一条水平线上从左向右排开，且图的所有边的指向也都是从左向右。拓扑排序并未各顶点上的排序，而是各顶点逻辑上的排序，这种排序可能有不止一种。在工程上，常把一个大规模工程的各个子工程抽象为一个AOV网，用拓扑排序解决工程的调度问题。下面用一个示例说明拓扑排序的具体应用：</p><p>下图（a）表示的是某教授每天早上从起床后到上班前所发生的事情的AOV网。教授必须先完成某些活动，才能完成某些活动；而另一些活动则可以以任意次序完成。在图（a）中，有向边$(u,v)$表示的就是活动$u$必须在活动$v$前完成。图（b）将拓扑排序后的有向无环图在一条水平直线上展示出来。如图（b）所示，该有向无环图所有边的指向都是从左到右。</p><p><img src="https://i.loli.net/2019/10/17/AtgWPhiQ15aXfOb.jpg" alt="a"></p><p><center>（a）</center><br><img src="https://i.loli.net/2019/10/17/ysW6329TM1YHjNF.jpg" alt="b"></p><p><center>（b）</center><br><a id="more"></a></p><h2 id="拓扑排序算法"><a href="#拓扑排序算法" class="headerlink" title="拓扑排序算法"></a>拓扑排序算法</h2><h3 id="1-基于入度的拓扑排序"><a href="#1-基于入度的拓扑排序" class="headerlink" title="1. 基于入度的拓扑排序"></a>1. 基于入度的拓扑排序</h3><p><code>基于入度的拓扑排序算法</code>，又被称为<code>Kahn算法</code>。以下摘选<a href="https://en.wikipedia.org/wiki/Topological_sorting" target="_blank" rel="noopener">维基百科</a>上关于<code>Kahn算法</code>的伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TOPOLOGICAL-SORT(G)</span></span><br><span class="line"></span><br><span class="line">L ← Empty <span class="built_in">list</span> that will contain the sorted elements</span><br><span class="line">S ← Set of all nodes with no incoming edges</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> S is non-empty <span class="keyword">do</span></span><br><span class="line">    remove a node u from S</span><br><span class="line">    insert u into L</span><br><span class="line">    <span class="keyword">for</span> each node v with an edge e from u to v <span class="keyword">do</span></span><br><span class="line">        remove edge e from the graph</span><br><span class="line">        <span class="keyword">if</span> v has no other incoming edges then</span><br><span class="line">            insert v into S</span><br><span class="line"><span class="keyword">if</span> graph has edges then</span><br><span class="line">    <span class="keyword">return</span> error (graph has at least onecycle)</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">return</span> L (a topologically sortedorder)</span><br></pre></td></tr></table></figure><p><code>Kahn算法</code>的基本思想是“走一步，看一步”。从以上伪代码不难看出<code>Kahn算法</code>的步骤：先统计所有顶点的入度，再把入度为零的顶点从图中分离出来，先放在集合$S$中，再从集合$S$中分别取出顶点放入线性表$L$中，然后把这个顶点指向的所有顶点的入度减<code>1</code>，并删除该顶点及所有与其相连的边。重复上述操作，直到所有顶点都被分离出来。若当集合$S$为空集时，线性表$L$中元素个数等于原来图中顶点的个数，则返回$L$，$L$中元素的排列即为该图的一种拓扑排序；若当集合$S$为空集时，线性表$L$中元素个数不等于原来图中顶点的个数，则意味着图中有闭环，返回错误信息，对图进行修改后再进行下一次拓扑排序。</p><p>对于图（a）的例子，首先我们找到入度为零的顶点有“刷牙”和“喂猫”，则把这两个顶点放入集合$S$中，$S=\{“刷牙”, “喂猫”\}$，$L=\varnothing$。</p><p>第一步、在$S$中选取”刷牙“并把该顶点从$S$中删除并放入线性表$L$中，”刷牙“与”洗脸“相连，删除相连的边，”洗脸“的入度减<code>1</code>，新的入度为<code>0</code>，把”洗脸“也放入$S$中。此时$S=\{“洗脸”, “喂猫”\}$，$L=“刷牙”$。</p><p><img src="https://i.loli.net/2019/10/17/ErzPGWtTIp67jMk.jpg" alt></p><p>第二步、在$S$中选取“洗脸”并把该顶点从$S$中删除并放入线性表$L$中，“洗脸”与“吃饭”“更衣”相连，删除相连的边，”吃饭““更衣”的入度减<code>1</code>，新的入度为<code>0</code>，把”吃饭“”更衣“也放入$S$中。此时$S=\{“吃饭”, “更衣”, “喂猫”\}$，$L=“刷牙”\to“洗脸”$。</p><p><img src="https://i.loli.net/2019/10/17/6IbE1rwjioKMSkQ.jpg" alt></p><p>以此类推，第三步到第五步的结果分别如图（3）（4）（5）所示（第六步时$G=\varnothing$），采用同样的步骤，直至$S=\varnothing$，算法结束。</p><p><img src="https://i.loli.net/2019/10/17/HCvbkjRUXqcMZfx.jpg" alt></p><p><center>（3）</center><br><img src="https://i.loli.net/2019/10/17/BTOl3tF974ks5ZR.jpg" alt></p><p><center>（4）</center><br><img src="https://i.loli.net/2019/10/17/ieHNnwm9pJGChd4.jpg" alt></p><p><center>（5）</center></p><h3 id="2-基于深度优先搜索的拓扑排序"><a href="#2-基于深度优先搜索的拓扑排序" class="headerlink" title="2. 基于深度优先搜索的拓扑排序"></a>2. 基于深度优先搜索的拓扑排序</h3><p><code>基于深度优先搜索的拓扑排序算法</code>同样见以下<a href="https://en.wikipedia.org/wiki/Topological_sorting" target="_blank" rel="noopener">维基百科</a>上关于该算法的伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TOPOLOGICAL-SORT(G)</span></span><br><span class="line"></span><br><span class="line">L ← Empty <span class="built_in">list</span> that will contain the sorted nodes</span><br><span class="line">S ← Set of all nodes with no outgoing edges</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> each node v in S <span class="keyword">do</span></span><br><span class="line">    visit(v) </span><br><span class="line">    </span><br><span class="line"><span class="function">function <span class="title">visit</span><span class="params">(node v)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">if</span> v has <span class="keyword">not</span> been visited yet then</span></span><br><span class="line"><span class="function">        mark v as visited</span></span><br><span class="line"><span class="function">        <span class="keyword">for</span> each node u with an edge from u to v <span class="keyword">do</span></span></span><br><span class="line"><span class="function">            <span class="title">visit</span><span class="params">(u)</span></span></span><br><span class="line"><span class="function">        add v to L</span></span><br></pre></td></tr></table></figure><p>这个算法的过程非常直观：先把出度为零的顶点从图中分离出来，放在集合$S$中，再从集合$S$中分别取出顶点，递归访问其父顶点，若该顶点未被访问，则标记为“已访问”；到达递归基础后，将当前顶点放入线性表$L$中，并逐步回溯。</p><p>下证<code>基于DFS的拓扑排序算法</code>生成的是有向无环图的拓扑排序：</p><p>在有向无环图$G=(V,E)$上运行<code>DFS</code>，只需证明对于任意一对顶点$(u,v)\in E$，$u$的返回在$v$之前即可。</p><p>对边$(u,v)\in E $，在调用<code>DFS(v)</code>时，对于即将访问的$u$，不外乎以下两种情况：</p><ol><li><code>DFS(u)</code>未被调用，即$u$未被<code>mark</code>，在当前路搜索路径的<code>DFS</code>树上，$u$是$v$的子节点。</li><li><code>DFS(u)</code>已被调用，即$u$已被<code>mark</code>，则可知<code>DFS(u)</code>在另一条已经完成的搜索路径上返回。</li></ol><p>对于这两种情况，$u$的返回都在$v$之前，得证。</p><h2 id="例题：任务排序问题"><a href="#例题：任务排序问题" class="headerlink" title="例题：任务排序问题"></a>例题：任务排序问题</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>假定你需完成$n$项任务，这些任务之间并非独立，一项任务的执行当且仅当其所有前置任务已经被全部完成。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入的数据包含若干组样例，每个样例的第一行包括两个整数$n$和$m$。$n$是任务的数量，$m$是任务之间先后关系的数量。接下来有$m$行，每行有两个整数$i$和$j$，表示任务$i$的执行必须在任务$j$之前。</p><p>输入结束的标志是一组$n=m=0$的样例。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每一组样例，在一行内输出$n$个整数，每两个整数之间用一个空格隔开，每一行数据表示一种可行的任务排序方案。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 4</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">1 3</span><br><span class="line">1 5</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 4 2 5 3</span><br></pre></td></tr></table></figure><h3 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h3><p>$1 \leq n \leq 100$</p><h3 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h3><h4 id="解法一、Kahn算法"><a href="#解法一、Kahn算法" class="headerlink" title="解法一、Kahn算法"></a>解法一、Kahn算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Run on C++</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">110</span>, MAXM = <span class="number">110</span> * <span class="number">110</span> / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> v, nxt;</span><br><span class="line">&#125;E[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, cnt;</span><br><span class="line"><span class="keyword">int</span> head[MAXN], in[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">E[++cnt].v = v;</span><br><span class="line">E[cnt].nxt = head[u];</span><br><span class="line">head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cnt = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line"><span class="built_in">memset</span>(E, <span class="number">0</span>, <span class="keyword">sizeof</span>(E));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">while</span>(n || m)</span><br><span class="line">&#123;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u, v;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">addedge(u, v);</span><br><span class="line">in[v]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span>(!in[i]) q.push(i);</span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> cur = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cur &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[cur]; i; i = E[i].nxt)</span><br><span class="line"><span class="keyword">if</span>(!--in[E[i].v]) q.push(E[i].v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解法二、DFS"><a href="#解法二、DFS" class="headerlink" title="解法二、DFS"></a>解法二、DFS</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Run on C++</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">110</span>, MAXM = <span class="number">110</span> * <span class="number">110</span> / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> u, nxt;</span><br><span class="line">&#125;E[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, cnt;</span><br><span class="line"><span class="keyword">int</span> head[MAXN], out[MAXN];</span><br><span class="line"><span class="keyword">bool</span> flag[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">E[++cnt].u = u;</span><br><span class="line">E[cnt].nxt = head[v];</span><br><span class="line">head[v] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cnt = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line"><span class="built_in">memset</span>(E, <span class="number">0</span>, <span class="keyword">sizeof</span>(E));</span><br><span class="line"><span class="built_in">memset</span>(out, <span class="number">0</span>, <span class="keyword">sizeof</span>(out));</span><br><span class="line"><span class="built_in">memset</span>(flag, <span class="number">0</span>, <span class="keyword">sizeof</span>(flag));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!flag[V]) </span><br><span class="line">&#123;</span><br><span class="line">flag[V] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[V]; i; i = E[i].nxt)</span><br><span class="line">dfs(E[i].u);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; V &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">while</span>(n || m)</span><br><span class="line">&#123;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u, v;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">addedge(u, v);</span><br><span class="line">out[u]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span>(!out[i]) q.push(i);</span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">dfs(q.front());</span><br><span class="line">q.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/10/17/Q4afFcoLyVZz91B.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;拓扑排序&quot;&gt;&lt;a href=&quot;#拓扑排序&quot; class=&quot;headerlink&quot; title=&quot;拓扑排序&quot;&gt;&lt;/a&gt;拓扑排序&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;图：索菲亚教堂&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;拓扑是研究几何图形或空间在连续改变形状后还能保持不变的一些性质的一个学科。它只考虑物体间的位置关系而不考虑它们的形状和大小。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;AOV网&quot;&gt;&lt;a href=&quot;#AOV网&quot; class=&quot;headerlink&quot; title=&quot;AOV网&quot;&gt;&lt;/a&gt;AOV网&lt;/h2&gt;&lt;p&gt;在工程领域，一个大规模工程常被拆分为多个子工程，这些子工程被称为&lt;strong&gt;活动（Activity）&lt;/strong&gt;，在有向图中以&lt;strong&gt;顶点（Vertex）&lt;/strong&gt;表示活动，以有向边表示活动之间的先后关系，这样的有向图被称为&lt;strong&gt;AOV网（Activity On Vertex Network）&lt;/strong&gt;。在AOV网中，如果出现了闭环，就意味着有若干个活动将被无限次重复，工程将永远无法完成；因此，一个具有实用价值的AOV网，必定是一个&lt;strong&gt;有向无环图（DAG，Directed Acyclic Graph）&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;绪论&quot;&gt;&lt;a href=&quot;#绪论&quot; class=&quot;headerlink&quot; title=&quot;绪论&quot;&gt;&lt;/a&gt;绪论&lt;/h2&gt;&lt;p&gt;对于一个有向无环图$G=(V,E)$，其拓扑排序是其上顶点的一个线性排序：对于有向边$(u,v)\in E$，顶点$u$在排序中在顶点$v$的前面（如果$G$包含环路，则不可能产生一个线性排序）。可以将$G$上各顶点在一条水平线上从左向右排开，且图的所有边的指向也都是从左向右。拓扑排序并未各顶点上的排序，而是各顶点逻辑上的排序，这种排序可能有不止一种。在工程上，常把一个大规模工程的各个子工程抽象为一个AOV网，用拓扑排序解决工程的调度问题。下面用一个示例说明拓扑排序的具体应用：&lt;/p&gt;
&lt;p&gt;下图（a）表示的是某教授每天早上从起床后到上班前所发生的事情的AOV网。教授必须先完成某些活动，才能完成某些活动；而另一些活动则可以以任意次序完成。在图（a）中，有向边$(u,v)$表示的就是活动$u$必须在活动$v$前完成。图（b）将拓扑排序后的有向无环图在一条水平直线上展示出来。如图（b）所示，该有向无环图所有边的指向都是从左到右。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/10/17/AtgWPhiQ15aXfOb.jpg&quot; alt=&quot;a&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;（a）&lt;/center&gt;&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2019/10/17/ysW6329TM1YHjNF.jpg&quot; alt=&quot;b&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;（b）&lt;/center&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="C-plus-plus" scheme="https://G-SS-Hacker.github.io/tags/C-plus-plus/"/>
    
      <category term="算法" scheme="https://G-SS-Hacker.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="https://G-SS-Hacker.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="数据结构" scheme="https://G-SS-Hacker.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="图论" scheme="https://G-SS-Hacker.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>高等数学公式</title>
    <link href="https://g-ss-hacker.github.io/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"/>
    <id>https://g-ss-hacker.github.io/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</id>
    <published>2019-10-13T14:49:17.000Z</published>
    <updated>2019-12-02T12:54:14.059Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1570988493976&amp;di=831446d27114ecbfec8880afa48584ea&amp;imgtype=0&amp;src=http%3A%2F%2Fimg.mp.itc.cn%2Fupload%2F20160511%2F28084d3cb772429b8546dbd5b302ff89_th.jpg" alt></p><h1 id="高等数学公式"><a href="#高等数学公式" class="headerlink" title="高等数学公式"></a>高等数学公式</h1><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><p></p><h2 id="立方公式"><a href="#立方公式" class="headerlink" title="立方公式"></a>立方公式</h2><h3 id="1-立方和公式"><a href="#1-立方和公式" class="headerlink" title="1.立方和公式"></a>1.立方和公式</h3><p>$a^3+b^3=(a+b)(a^2-ab+b^2)$</p><h3 id="2-立方差公式"><a href="#2-立方差公式" class="headerlink" title="2.立方差公式"></a>2.立方差公式</h3><p>$a^3-b^3=(a-b)(a^2+ab+b^2)$</p><h3 id="3-三项立方和公式"><a href="#3-三项立方和公式" class="headerlink" title="3.三项立方和公式"></a>3.三项立方和公式</h3><p>$a^3+b^3+c^3-abc=(a+b+c)(a^2+b^2+c^2-ab-bc-ac)$</p><h3 id="4-完全立方和公式"><a href="#4-完全立方和公式" class="headerlink" title="4.完全立方和公式"></a>4.完全立方和公式</h3><p>$(a+b)^3=a^3+3a^2b+3ab^2+b^3$</p><p>$(a-b)^3=a^3-3a^2b+3ab^2-b^3$</p><h3 id="5-立方和累加"><a href="#5-立方和累加" class="headerlink" title="5.立方和累加"></a>5.立方和累加</h3><p>$1^3+2^3+\ldots +n^3=[\frac{n(n+1)}{2}]^2=(1+2+\ldots+n)^2$</p><hr><h2 id="和差化积公式"><a href="#和差化积公式" class="headerlink" title="和差化积公式"></a>和差化积公式</h2><p>$\sin \alpha+\sin \beta=2\sin \frac{\alpha+ \beta}{2} \cos \frac{\alpha- \beta}{2}$</p><p>$\sin \alpha-\sin\beta=2\cos \frac{\alpha+ \beta}{2}\sin \frac{\alpha- \beta}{2}$</p><p>$\cos \alpha+\cos \beta=2\cos \frac{\alpha + \beta}{2}\cos \frac{\alpha- \beta}{2}$</p><p>$\cos \alpha - \cos \beta=-2\sin \frac{\alpha+ \beta}{2}\sin \frac{\alpha- \beta}{2}$</p><hr><h2 id="积化和差公式"><a href="#积化和差公式" class="headerlink" title="积化和差公式"></a>积化和差公式</h2><p>$\sin \alpha \sin \beta=\frac12[\sin(\alpha + \beta)+\sin(\alpha - \beta)]$</p><p>$\sin \alpha \cos \beta=\frac12[\sin(\alpha + \beta)-\sin(\alpha - \beta)]$</p><p>$\cos \alpha \sin \beta=\frac12[\cos(\alpha + \beta)+\cos(\alpha - \beta)]$</p><p>$\cos \alpha \cos \beta=\frac12[cos(\alpha + \beta)-cos(\alpha - \beta)]$</p><hr><a id="more"></a><h2 id="万能公式"><a href="#万能公式" class="headerlink" title="万能公式"></a>万能公式</h2><p>$\sin \theta=\frac{2\tan \frac{\theta}{2}}{1+\tan^2\frac{\theta}{2}}$</p><p>$\cos \theta=\frac{1-\tan^2\frac{\theta}{2}}{1+\tan^2\frac{\theta}{2}}$</p><p>$\tan \theta=\frac{2\tan \frac{\theta}{2}}{1-\tan^2 \frac{\theta}{2}}$</p><hr><p>​    </p><h2 id="平方和拓展"><a href="#平方和拓展" class="headerlink" title="平方和拓展"></a>平方和拓展</h2><p>$1^2+2^2+\ldots+n^2=\frac1{6}n(n+1)(2n+1)$</p><p>$1\times2+2\times3+\ldots+n(n+1)=n(n+1)(n+2)$</p><hr><h2 id="裂项相消"><a href="#裂项相消" class="headerlink" title="裂项相消"></a>裂项相消</h2><p>$\frac1{n(n+1)(n+2)}=\frac12[\frac1{n(n+1)}-\frac1{(n+1)(n+2)}]$</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1570988493976&amp;amp;di=831446d27114ecbfec8880afa48584ea&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fimg.mp.itc.cn%2Fupload%2F20160511%2F28084d3cb772429b8546dbd5b302ff89_th.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;高等数学公式&quot;&gt;&lt;a href=&quot;#高等数学公式&quot; class=&quot;headerlink&quot; title=&quot;高等数学公式&quot;&gt;&lt;/a&gt;高等数学公式&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;h2 id=&quot;立方公式&quot;&gt;&lt;a href=&quot;#立方公式&quot; class=&quot;headerlink&quot; title=&quot;立方公式&quot;&gt;&lt;/a&gt;立方公式&lt;/h2&gt;&lt;h3 id=&quot;1-立方和公式&quot;&gt;&lt;a href=&quot;#1-立方和公式&quot; class=&quot;headerlink&quot; title=&quot;1.立方和公式&quot;&gt;&lt;/a&gt;1.立方和公式&lt;/h3&gt;&lt;p&gt;$a^3+b^3=(a+b)(a^2-ab+b^2)$&lt;/p&gt;
&lt;h3 id=&quot;2-立方差公式&quot;&gt;&lt;a href=&quot;#2-立方差公式&quot; class=&quot;headerlink&quot; title=&quot;2.立方差公式&quot;&gt;&lt;/a&gt;2.立方差公式&lt;/h3&gt;&lt;p&gt;$a^3-b^3=(a-b)(a^2+ab+b^2)$&lt;/p&gt;
&lt;h3 id=&quot;3-三项立方和公式&quot;&gt;&lt;a href=&quot;#3-三项立方和公式&quot; class=&quot;headerlink&quot; title=&quot;3.三项立方和公式&quot;&gt;&lt;/a&gt;3.三项立方和公式&lt;/h3&gt;&lt;p&gt;$a^3+b^3+c^3-abc=(a+b+c)(a^2+b^2+c^2-ab-bc-ac)$&lt;/p&gt;
&lt;h3 id=&quot;4-完全立方和公式&quot;&gt;&lt;a href=&quot;#4-完全立方和公式&quot; class=&quot;headerlink&quot; title=&quot;4.完全立方和公式&quot;&gt;&lt;/a&gt;4.完全立方和公式&lt;/h3&gt;&lt;p&gt;$(a+b)^3=a^3+3a^2b+3ab^2+b^3$&lt;/p&gt;
&lt;p&gt;$(a-b)^3=a^3-3a^2b+3ab^2-b^3$&lt;/p&gt;
&lt;h3 id=&quot;5-立方和累加&quot;&gt;&lt;a href=&quot;#5-立方和累加&quot; class=&quot;headerlink&quot; title=&quot;5.立方和累加&quot;&gt;&lt;/a&gt;5.立方和累加&lt;/h3&gt;&lt;p&gt;$1^3+2^3+\ldots +n^3=[\frac{n(n+1)}{2}]^2=(1+2+\ldots+n)^2$&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;和差化积公式&quot;&gt;&lt;a href=&quot;#和差化积公式&quot; class=&quot;headerlink&quot; title=&quot;和差化积公式&quot;&gt;&lt;/a&gt;和差化积公式&lt;/h2&gt;&lt;p&gt;$\sin \alpha+\sin \beta=2\sin \frac{\alpha+ \beta}{2} \cos \frac{\alpha- \beta}{2}$&lt;/p&gt;
&lt;p&gt;$\sin \alpha-\sin\beta=2\cos \frac{\alpha+ \beta}{2}\sin \frac{\alpha- \beta}{2}$&lt;/p&gt;
&lt;p&gt;$\cos \alpha+\cos \beta=2\cos \frac{\alpha + \beta}{2}\cos \frac{\alpha- \beta}{2}$&lt;/p&gt;
&lt;p&gt;$\cos \alpha - \cos \beta=-2\sin \frac{\alpha+ \beta}{2}\sin \frac{\alpha- \beta}{2}$&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;积化和差公式&quot;&gt;&lt;a href=&quot;#积化和差公式&quot; class=&quot;headerlink&quot; title=&quot;积化和差公式&quot;&gt;&lt;/a&gt;积化和差公式&lt;/h2&gt;&lt;p&gt;$\sin \alpha \sin \beta=\frac12[\sin(\alpha + \beta)+\sin(\alpha - \beta)]$&lt;/p&gt;
&lt;p&gt;$\sin \alpha \cos \beta=\frac12[\sin(\alpha + \beta)-\sin(\alpha - \beta)]$&lt;/p&gt;
&lt;p&gt;$\cos \alpha \sin \beta=\frac12[\cos(\alpha + \beta)+\cos(\alpha - \beta)]$&lt;/p&gt;
&lt;p&gt;$\cos \alpha \cos \beta=\frac12[cos(\alpha + \beta)-cos(\alpha - \beta)]$&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="微积分" scheme="https://G-SS-Hacker.github.io/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>常用等价无穷小</title>
    <link href="https://g-ss-hacker.github.io/%E5%B8%B8%E7%94%A8%E7%AD%89%E4%BB%B7%E6%97%A0%E7%A9%B7%E5%B0%8F/"/>
    <id>https://g-ss-hacker.github.io/%E5%B8%B8%E7%94%A8%E7%AD%89%E4%BB%B7%E6%97%A0%E7%A9%B7%E5%B0%8F/</id>
    <published>2019-10-13T13:43:36.000Z</published>
    <updated>2019-10-15T16:48:29.195Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/10/13/z8NK7uv6wXtTFS5.jpg" alt></p><h1 id="常用等价无穷小"><a href="#常用等价无穷小" class="headerlink" title="常用等价无穷小"></a>常用等价无穷小</h1><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><p></p><h2 id="基础版"><a href="#基础版" class="headerlink" title="基础版"></a>基础版</h2><p>当$x\to0$时，</p><p>$(1)\sin x \sim x$</p><p>$(2)\tan x \sim x$</p><p>$(3)\arcsin x \sim x$</p><p>$(4)\arctan x \sim x$</p><p>$(5)1-\cos x \sim \frac12 x^2$</p><p>$(6)a^x-1 \sim x \ln a$</p><p>$(7)e^x-1 \sim x$</p><p>$(8)(1+x)^a-1 \sim ax$<sup><a href="#fn_ *" id="reffn_ *"> *</a></sup></p><p>$(9)\ln (1+x) \sim x$</p><p>$(10)\sqrt{1+x}-1 \sim \frac12x$</p><a id="more"></a><h2 id="进阶版"><a href="#进阶版" class="headerlink" title="进阶版"></a>进阶版</h2><p>当$x\to0$时，</p><p>$(11)\log_a(1+x) \sim \frac{x}{\ln a}$</p><p>$(12)\sqrt[n]{1+x}-1\sim \frac{x}{n}$</p><p>$(13)x-\sin x\sim \frac16x^3$</p><p>$(14)\tan x-x\sim\frac13x^3$</p><p>$(15)\arcsin x-x\sim\frac16x^3$</p><p>$(16)x-\arctan x\sim \frac13x^3$</p><p>$(17)\tan x-\sin x\sim \frac12x^3$</p><hr><blockquote id="fn_ *"><sup> *</sup>. 见<code>Bernoulli</code>不等式：$(1+x)^n \ge 1+nx$<a href="#reffn_ *" title="Jump back to footnote [ *] in the text."> &#8617;</a></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/10/13/z8NK7uv6wXtTFS5.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;常用等价无穷小&quot;&gt;&lt;a href=&quot;#常用等价无穷小&quot; class=&quot;headerlink&quot; title=&quot;常用等价无穷小&quot;&gt;&lt;/a&gt;常用等价无穷小&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;h2 id=&quot;基础版&quot;&gt;&lt;a href=&quot;#基础版&quot; class=&quot;headerlink&quot; title=&quot;基础版&quot;&gt;&lt;/a&gt;基础版&lt;/h2&gt;&lt;p&gt;当$x\to0$时，&lt;/p&gt;
&lt;p&gt;$(1)\sin x \sim x$&lt;/p&gt;
&lt;p&gt;$(2)\tan x \sim x$&lt;/p&gt;
&lt;p&gt;$(3)\arcsin x \sim x$&lt;/p&gt;
&lt;p&gt;$(4)\arctan x \sim x$&lt;/p&gt;
&lt;p&gt;$(5)1-\cos x \sim \frac12 x^2$&lt;/p&gt;
&lt;p&gt;$(6)a^x-1 \sim x \ln a$&lt;/p&gt;
&lt;p&gt;$(7)e^x-1 \sim x$&lt;/p&gt;
&lt;p&gt;$(8)(1+x)^a-1 \sim ax$&lt;sup&gt;&lt;a href=&quot;#fn_ *&quot; id=&quot;reffn_ *&quot;&gt; *&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;$(9)\ln (1+x) \sim x$&lt;/p&gt;
&lt;p&gt;$(10)\sqrt{1+x}-1 \sim \frac12x$&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="微积分" scheme="https://G-SS-Hacker.github.io/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>导数基本公式</title>
    <link href="https://g-ss-hacker.github.io/%E5%AF%BC%E6%95%B0%E5%9F%BA%E6%9C%AC%E5%85%AC%E5%BC%8F/"/>
    <id>https://g-ss-hacker.github.io/%E5%AF%BC%E6%95%B0%E5%9F%BA%E6%9C%AC%E5%85%AC%E5%BC%8F/</id>
    <published>2019-10-13T08:47:40.000Z</published>
    <updated>2019-10-13T13:27:20.998Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/10/13/e4F7haguPTV1UrG.jpg" alt></p><h1 id="导数基本公式"><a href="#导数基本公式" class="headerlink" title="导数基本公式"></a>导数基本公式</h1><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><br>$(1)(C)’ = 0$<p></p><p>$(2)(x^a)’=ax^{a-1}$</p><p>$(3)(a^x)’=a^x\ln a    (a&gt;0且a\not=1)$</p><p>$(4)(e^x)’=e^x$</p><p>$(5)(\log_ax)’=\frac{1}{x\ln a}(a&gt;0且a\not=1)$</p><p>$(6)(\ln x)’=\frac1{x}$</p><p>$(7)(\sin x)’=\cos x$</p><p>$(8)(\cos x)’=-\sin x$</p><p>$(9)(\tan x)’=\frac1{\cos^2x}=\sec^2x$</p><p>$(10)(\cot x)’=\frac1{-\sin^x}=-\csc^2x$</p><a id="more"></a><p>$(11)(\sec x)’=\sec x\tan x$</p><p>$(12)(\csc x)’=-\csc x\cot x$</p><p>$(13)(\arcsin x)’=\frac1{\sqrt{1-x^2}}$</p><p>$(14)(\arccos x)’=-\frac1{\sqrt{1-x^2}}$</p><p>$(15)(\arctan x)’=\frac1{1+x^2}$</p><p>$(16)(\mathrm{arccot} x)’=-\frac1{1+x^2}$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/10/13/e4F7haguPTV1UrG.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;导数基本公式&quot;&gt;&lt;a href=&quot;#导数基本公式&quot; class=&quot;headerlink&quot; title=&quot;导数基本公式&quot;&gt;&lt;/a&gt;导数基本公式&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;br&gt;$(1)(C)’ = 0$&lt;p&gt;&lt;/p&gt;
&lt;p&gt;$(2)(x^a)’=ax^{a-1}$&lt;/p&gt;
&lt;p&gt;$(3)(a^x)’=a^x\ln a    (a&amp;gt;0且a\not=1)$&lt;/p&gt;
&lt;p&gt;$(4)(e^x)’=e^x$&lt;/p&gt;
&lt;p&gt;$(5)(\log_ax)’=\frac{1}{x\ln a}(a&amp;gt;0且a\not=1)$&lt;/p&gt;
&lt;p&gt;$(6)(\ln x)’=\frac1{x}$&lt;/p&gt;
&lt;p&gt;$(7)(\sin x)’=\cos x$&lt;/p&gt;
&lt;p&gt;$(8)(\cos x)’=-\sin x$&lt;/p&gt;
&lt;p&gt;$(9)(\tan x)’=\frac1{\cos^2x}=\sec^2x$&lt;/p&gt;
&lt;p&gt;$(10)(\cot x)’=\frac1{-\sin^x}=-\csc^2x$&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="微积分" scheme="https://G-SS-Hacker.github.io/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
</feed>
