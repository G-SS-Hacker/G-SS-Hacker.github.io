<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>G-SS-Hacker</title>
  
  <subtitle>---A Cyber Driver---</subtitle>
  <link href="/G-SS-Hacker.github.io/atom.xml" rel="self"/>
  
  <link href="https://g-ss-hacker.github.io/"/>
  <updated>2020-02-09T04:36:12.150Z</updated>
  <id>https://g-ss-hacker.github.io/</id>
  
  <author>
    <name>G-SS-Hacker</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C语言基础学习笔记（2）：格式化输入与输出</title>
    <link href="https://g-ss-hacker.github.io/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%EF%BC%9A%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"/>
    <id>https://g-ss-hacker.github.io/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%EF%BC%9A%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/</id>
    <published>2020-02-09T04:35:51.000Z</published>
    <updated>2020-02-09T04:36:12.150Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2020/02/09/1faKYV.png" alt></p><h1 id="C语言基础学习笔记（2）：格式化输入与输出"><a href="#C语言基础学习笔记（2）：格式化输入与输出" class="headerlink" title="C语言基础学习笔记（2）：格式化输入与输出"></a>C语言基础学习笔记（2）：格式化输入与输出</h1><blockquote><p>图：乞力马扎罗山（Kilimanjaro）</p></blockquote><p><font color="grey"> <em>Guderian出品</em> </font></p><ol><li><p><code>C</code>语言格式化屏幕输出：<code>printf(格式控制字符串, 输出值参数表);</code></p><p><code>C</code>语言格式化屏幕输入：<code>scanf(格式控制字符串, 输入地址表);</code></p></li><li><p>问题：<code>printf()</code>用<code>%</code>作为格式字符的标识，那么如何输出<code>%</code>呢？<code>C</code>规定，连续两个百分号出现在格式控制字符串中就表示要输出一个百分号</p></li><li><p>如何分隔多个输入数据？</p><p>1）空格、<code>Tab</code>或回车</p><p>2）达到输入位宽</p><p>3）遇到非法字符</p></li><li><p>如何判断<code>scanf()</code>函数读入了正确的数据项数呢？</p><p>事实上，<code>scanf()</code>是有返回值的，它的返回值就是正确读入的数据项数。现在明白<code>while(scanf(...))</code>为什么正确了吧？</p></li><li><p><code>scanf()</code>格式控制字符串中的普通字符原样输入。注意格式字符为<code>%f, %e</code>为输入<code>float</code>型且不能指定精度，格式字符为<code>%c</code>为一个字符包括空白字符（如空格和制表符）。</p></li><li><p><code>scanf()</code>格式修饰符</p></li></ol><p><img src="https://i.loli.net/2020/02/08/NJ3vn2TEYZcFXx4.png" alt></p><ol><li><p>字符型常量：所有的<code>ASCII</code>码都可以通过转义方式表示，其中<code>\ddd</code>为<code>1</code>到<code>3</code>位八进制<code>ASCII</code>码值所代表的字符，<code>\xhh</code>为<code>1</code>到<code>2</code>为十六进制<code>ASCII</code>码值所代表的字符。如：<code>&#39;B&#39;</code>等价于<code>&#39;\102&#39;</code>等价于<code>&#39;\x42&#39;</code>。</p></li><li><p>大小写英文字母的<code>ASCII</code>值相差<code>32</code>，即<code>大写字母+32=小写字母</code>。</p></li><li><p>单个字符的输入输出：</p><p><code>putchar(ch)</code>：向屏幕输出一个字符，字符型变量<code>ch</code>的值</p><p><code>ch = getchar()</code>：从键盘接受的字符作为<code>getchar()</code>的函数值，无参数</p></li><li><p>用<code>getchar()</code>输入时应注意的问题：<code>getchar()</code>函数并不是直接读取用户输入的字符，而是将输入字符先放在输入缓冲队列中，再从缓冲队列读取字符，直到输入回车符或文件结束符<code>EOF</code>时，程序才认为输入结束；一行输入结束，<code>getchar()</code>才开始从输入缓冲队列读取字符，前面函数没读取的数据仍在缓冲队列中，将被下一个<code>getchar()</code>函数读取。</p></li><li><p>在<code>Linux/Unix</code>下键入<code>Ctrl + D</code>或在<code>Windows</code>下键入<code>Ctrl + Z</code>，<code>getchar()</code>函数的确是会返回<code>-1</code>即<code>EOF</code>（<code>End Of File</code>）的，严格意义上应该用<code>int</code>类型来接收<code>getchar()</code>的返回值。</p></li><li><p>注意用<code>%c</code>格式读入字符时，空格和回车等空白字符都会被当做有效字符读入，在<code>%c</code>前加一个空格可以忽略缓冲区中的空白字符。</p></li></ol><a id="more"></a><hr><font color="#407600">【更多C语言系列】</font><ul><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/C和C-基本数据类型取值范围/">C &amp; C++基本数据类型取值范围</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/C和C-中memset用法/">C &amp; C++ memset</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/野指针的产生及其危害/">野指针的产生及其危害</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/02/09/1faKYV.png&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;C语言基础学习笔记（2）：格式化输入与输出&quot;&gt;&lt;a href=&quot;#C语言基础学习笔记（2）：格式化输入与输出&quot; class=&quot;headerlink&quot; title=&quot;C语言基础学习笔记（2）：格式化输入与输出&quot;&gt;&lt;/a&gt;C语言基础学习笔记（2）：格式化输入与输出&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;图：乞力马扎罗山（Kilimanjaro）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;C&lt;/code&gt;语言格式化屏幕输出：&lt;code&gt;printf(格式控制字符串, 输出值参数表);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;C&lt;/code&gt;语言格式化屏幕输入：&lt;code&gt;scanf(格式控制字符串, 输入地址表);&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;问题：&lt;code&gt;printf()&lt;/code&gt;用&lt;code&gt;%&lt;/code&gt;作为格式字符的标识，那么如何输出&lt;code&gt;%&lt;/code&gt;呢？&lt;code&gt;C&lt;/code&gt;规定，连续两个百分号出现在格式控制字符串中就表示要输出一个百分号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如何分隔多个输入数据？&lt;/p&gt;
&lt;p&gt;1）空格、&lt;code&gt;Tab&lt;/code&gt;或回车&lt;/p&gt;
&lt;p&gt;2）达到输入位宽&lt;/p&gt;
&lt;p&gt;3）遇到非法字符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如何判断&lt;code&gt;scanf()&lt;/code&gt;函数读入了正确的数据项数呢？&lt;/p&gt;
&lt;p&gt;事实上，&lt;code&gt;scanf()&lt;/code&gt;是有返回值的，它的返回值就是正确读入的数据项数。现在明白&lt;code&gt;while(scanf(...))&lt;/code&gt;为什么正确了吧？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;scanf()&lt;/code&gt;格式控制字符串中的普通字符原样输入。注意格式字符为&lt;code&gt;%f, %e&lt;/code&gt;为输入&lt;code&gt;float&lt;/code&gt;型且不能指定精度，格式字符为&lt;code&gt;%c&lt;/code&gt;为一个字符包括空白字符（如空格和制表符）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;scanf()&lt;/code&gt;格式修饰符&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/02/08/NJ3vn2TEYZcFXx4.png&quot; alt&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;字符型常量：所有的&lt;code&gt;ASCII&lt;/code&gt;码都可以通过转义方式表示，其中&lt;code&gt;\ddd&lt;/code&gt;为&lt;code&gt;1&lt;/code&gt;到&lt;code&gt;3&lt;/code&gt;位八进制&lt;code&gt;ASCII&lt;/code&gt;码值所代表的字符，&lt;code&gt;\xhh&lt;/code&gt;为&lt;code&gt;1&lt;/code&gt;到&lt;code&gt;2&lt;/code&gt;为十六进制&lt;code&gt;ASCII&lt;/code&gt;码值所代表的字符。如：&lt;code&gt;&amp;#39;B&amp;#39;&lt;/code&gt;等价于&lt;code&gt;&amp;#39;\102&amp;#39;&lt;/code&gt;等价于&lt;code&gt;&amp;#39;\x42&amp;#39;&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;大小写英文字母的&lt;code&gt;ASCII&lt;/code&gt;值相差&lt;code&gt;32&lt;/code&gt;，即&lt;code&gt;大写字母+32=小写字母&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;单个字符的输入输出：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;putchar(ch)&lt;/code&gt;：向屏幕输出一个字符，字符型变量&lt;code&gt;ch&lt;/code&gt;的值&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ch = getchar()&lt;/code&gt;：从键盘接受的字符作为&lt;code&gt;getchar()&lt;/code&gt;的函数值，无参数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用&lt;code&gt;getchar()&lt;/code&gt;输入时应注意的问题：&lt;code&gt;getchar()&lt;/code&gt;函数并不是直接读取用户输入的字符，而是将输入字符先放在输入缓冲队列中，再从缓冲队列读取字符，直到输入回车符或文件结束符&lt;code&gt;EOF&lt;/code&gt;时，程序才认为输入结束；一行输入结束，&lt;code&gt;getchar()&lt;/code&gt;才开始从输入缓冲队列读取字符，前面函数没读取的数据仍在缓冲队列中，将被下一个&lt;code&gt;getchar()&lt;/code&gt;函数读取。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在&lt;code&gt;Linux/Unix&lt;/code&gt;下键入&lt;code&gt;Ctrl + D&lt;/code&gt;或在&lt;code&gt;Windows&lt;/code&gt;下键入&lt;code&gt;Ctrl + Z&lt;/code&gt;，&lt;code&gt;getchar()&lt;/code&gt;函数的确是会返回&lt;code&gt;-1&lt;/code&gt;即&lt;code&gt;EOF&lt;/code&gt;（&lt;code&gt;End Of File&lt;/code&gt;）的，严格意义上应该用&lt;code&gt;int&lt;/code&gt;类型来接收&lt;code&gt;getchar()&lt;/code&gt;的返回值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注意用&lt;code&gt;%c&lt;/code&gt;格式读入字符时，空格和回车等空白字符都会被当做有效字符读入，在&lt;code&gt;%c&lt;/code&gt;前加一个空格可以忽略缓冲区中的空白字符。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="C" scheme="https://G-SS-Hacker.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C语言基础学习笔记（1）：变量、算术运算与赋值运算</title>
    <link href="https://g-ss-hacker.github.io/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E5%8F%98%E9%87%8F%E3%80%81%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E4%B8%8E%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97/"/>
    <id>https://g-ss-hacker.github.io/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E5%8F%98%E9%87%8F%E3%80%81%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E4%B8%8E%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97/</id>
    <published>2020-02-07T08:43:47.000Z</published>
    <updated>2020-02-09T04:35:15.050Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2020/02/07/1gDzsH.png" alt></p><h1 id="C语言基础学习笔记（1）：变量、算术运算与赋值运算"><a href="#C语言基础学习笔记（1）：变量、算术运算与赋值运算" class="headerlink" title="C语言基础学习笔记（1）：变量、算术运算与赋值运算"></a>C语言基础学习笔记（1）：变量、算术运算与赋值运算</h1><blockquote><p>图：西安城墙</p></blockquote><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><p></p><ol><li><p><code>C</code>中取余运算的结果符号与被除数符号相同。</p></li><li><p><code>C</code>中数字后面带个<code>U</code>， <code>u</code>, <code>L</code>, <code>l</code>, <code>F</code>,<code>f</code>的含义：</p><p><code>U</code>和<code>u</code>表示该数值是<strong>无符号整型</strong>（<code>unsigned int</code>）；<code>L</code>和<code>l</code>表示该数值是<strong>长整型</strong>（<code>long</code>）；<code>F</code>和<code>f</code>表示该数值是<strong>浮点型</strong>（<code>float</code>）。</p></li><li><p><code>C</code>中数字后面带个<code>H</code>, <code>h</code>, <code>B</code>, <code>b</code>或数字前面带个<code>0</code>, <code>0x</code>的含义：</p><p><code>H</code>和<code>h</code>表示该数值是<strong>十六进制数</strong>；<code>B</code>和<code>b</code>表示该数值是<strong>二进制数</strong>；前面带<code>0</code>表示该数值是<strong>八进制数</strong>；前面带<code>0x</code>表示该数值是<strong>十六进制数</strong>。</p></li><li><p><code>C</code>标准常用数学函数：</p></li></ol><p><img src="https://i.loli.net/2020/02/05/1qDpHvlmyeo8dE7.png" alt></p><ol><li><code>C</code>中的多重赋值表达式：<strong>变量1 = 变量2 = 表达式</strong>。如<code>a = b = 3</code>，两个赋值运算符的优先级相同，在优先级相同的情况下考虑赋值表达式的结合性，赋值运算符的结合性是右结合的，即从右往左进行计算，即先执行右边的赋值运算<code>b = 3</code>，再执行<code>a = (b = 3)</code>。</li><li><code>C</code>的算术表达式中不同类型数据的运算结果的类型是<strong>取值范围较大</strong>的那种类型。<code>C</code>编译器将所有操作数都转换成取值范围较大的操作数的类型，这一过程称为<strong>类型提升（Type Promotion）</strong>。其规则如下：</li></ol><p><img src="https://i.loli.net/2020/02/06/VSHPOLQfYxlgZ5G.png" alt></p><a id="more"></a><hr><font color="#407600">【更多C语言系列】</font><ul><li><p><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/C和C-基本数据类型取值范围/">C &amp; C++基本数据类型取值范围</a></p></li><li><p><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/C和C-中memset用法/">C &amp; C++ memset</a></p></li><li><p><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/野指针的产生及其危害/">野指针的产生及其危害</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/02/07/1gDzsH.png&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;C语言基础学习笔记（1）：变量、算术运算与赋值运算&quot;&gt;&lt;a href=&quot;#C语言基础学习笔记（1）：变量、算术运算与赋值运算&quot; class=&quot;headerlink&quot; title=&quot;C语言基础学习笔记（1）：变量、算术运算与赋值运算&quot;&gt;&lt;/a&gt;C语言基础学习笔记（1）：变量、算术运算与赋值运算&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;图：西安城墙&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;C&lt;/code&gt;中取余运算的结果符号与被除数符号相同。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;C&lt;/code&gt;中数字后面带个&lt;code&gt;U&lt;/code&gt;， &lt;code&gt;u&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;l&lt;/code&gt;, &lt;code&gt;F&lt;/code&gt;,&lt;code&gt;f&lt;/code&gt;的含义：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;U&lt;/code&gt;和&lt;code&gt;u&lt;/code&gt;表示该数值是&lt;strong&gt;无符号整型&lt;/strong&gt;（&lt;code&gt;unsigned int&lt;/code&gt;）；&lt;code&gt;L&lt;/code&gt;和&lt;code&gt;l&lt;/code&gt;表示该数值是&lt;strong&gt;长整型&lt;/strong&gt;（&lt;code&gt;long&lt;/code&gt;）；&lt;code&gt;F&lt;/code&gt;和&lt;code&gt;f&lt;/code&gt;表示该数值是&lt;strong&gt;浮点型&lt;/strong&gt;（&lt;code&gt;float&lt;/code&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;C&lt;/code&gt;中数字后面带个&lt;code&gt;H&lt;/code&gt;, &lt;code&gt;h&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;或数字前面带个&lt;code&gt;0&lt;/code&gt;, &lt;code&gt;0x&lt;/code&gt;的含义：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;H&lt;/code&gt;和&lt;code&gt;h&lt;/code&gt;表示该数值是&lt;strong&gt;十六进制数&lt;/strong&gt;；&lt;code&gt;B&lt;/code&gt;和&lt;code&gt;b&lt;/code&gt;表示该数值是&lt;strong&gt;二进制数&lt;/strong&gt;；前面带&lt;code&gt;0&lt;/code&gt;表示该数值是&lt;strong&gt;八进制数&lt;/strong&gt;；前面带&lt;code&gt;0x&lt;/code&gt;表示该数值是&lt;strong&gt;十六进制数&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;C&lt;/code&gt;标准常用数学函数：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/02/05/1qDpHvlmyeo8dE7.png&quot; alt&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;C&lt;/code&gt;中的多重赋值表达式：&lt;strong&gt;变量1 = 变量2 = 表达式&lt;/strong&gt;。如&lt;code&gt;a = b = 3&lt;/code&gt;，两个赋值运算符的优先级相同，在优先级相同的情况下考虑赋值表达式的结合性，赋值运算符的结合性是右结合的，即从右往左进行计算，即先执行右边的赋值运算&lt;code&gt;b = 3&lt;/code&gt;，再执行&lt;code&gt;a = (b = 3)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C&lt;/code&gt;的算术表达式中不同类型数据的运算结果的类型是&lt;strong&gt;取值范围较大&lt;/strong&gt;的那种类型。&lt;code&gt;C&lt;/code&gt;编译器将所有操作数都转换成取值范围较大的操作数的类型，这一过程称为&lt;strong&gt;类型提升（Type Promotion）&lt;/strong&gt;。其规则如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/02/06/VSHPOLQfYxlgZ5G.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="C" scheme="https://G-SS-Hacker.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>机器学习中的评价指标：F1-score</title>
    <link href="https://g-ss-hacker.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87%EF%BC%9AF1-score/"/>
    <id>https://g-ss-hacker.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87%EF%BC%9AF1-score/</id>
    <published>2020-02-06T11:12:29.000Z</published>
    <updated>2020-02-07T06:12:29.528Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2015/08/01/13/47/seattle-870282_1280.jpg" alt></p><h1 id="机器学习中的评价指标：F1-score"><a href="#机器学习中的评价指标：F1-score" class="headerlink" title="机器学习中的评价指标：F1-score"></a>机器学习中的评价指标：F1-score</h1><blockquote><p>图：西雅图（Seattle）</p></blockquote><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><p></p><h2 id="回顾：F1-score的计算过程"><a href="#回顾：F1-score的计算过程" class="headerlink" title="回顾：F1-score的计算过程"></a>回顾：F1-score的计算过程</h2><h3 id="混淆矩阵（Confusion-Matrix）"><a href="#混淆矩阵（Confusion-Matrix）" class="headerlink" title="混淆矩阵（Confusion Matrix）"></a>混淆矩阵（Confusion Matrix）</h3><blockquote><p>混淆矩阵也称误差矩阵，是表示精度评价的一种标准格式，用n行n列的矩阵形式来表示。</p></blockquote><p>在机器学习领域，混淆矩阵用于衡量一个分类器的准确程度。对于二分类问题，将其样例根据真实类别和分类器的预测类别的组合划分为真正例$\mathrm{(True \, Positive)}$、假正例$\mathrm{(False \, Positive)}$、真反例$\mathrm{(True \, Negative)}$、假反例$\mathrm{(False \, Negative)}$四种情形。</p><p>对应混淆矩阵$\mathrm{(Confusion \, Matrix)}$如下表：</p><p><style type="text/css"><br>.tg  {border-collapse:collapse;border-spacing:0;}<br>.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}<br>.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}<br>.tg .tg-0lax{text-align:left;vertical-align:top}<br>.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}</style></p><table class="tg">  <tr>    <th class="tg-0lax" rowspan="2"><center>真实情况</center></th>    <th class="tg-0lax" colspan="2"><center>预测结果</center></th>  </tr>  <tr>    <td class="tg-0lax"><center>真</center></td>    <td class="tg-0lax"><center>假</center></td>  </tr>  <tr>    <td class="tg-0lax"><center>真</center></td>    <td class="tg-0lax"><center>TP（真正例）</center></td>    <td class="tg-0lax"><center>FN（假反例）</center></td>  </tr>  <tr>    <td class="tg-0pky"><center>假</center></td>    <td class="tg-0pky"><center>FP（假正例）</center></td>    <td class="tg-0lax"><center>TN（真反例）</center></td>  </tr></table><h3 id="精确率（Precision）与召回率（Recall）"><a href="#精确率（Precision）与召回率（Recall）" class="headerlink" title="精确率（Precision）与召回率（Recall）"></a>精确率（Precision）与召回率（Recall）</h3><p>根据混淆矩阵，我们可以得到如下定义：</p><ul><li><strong>精确率</strong>$\mathrm{(Precision)}$   <font size="4rem">$\mathrm{P=\frac{TP}{TP+FP} \times 100\%}$</font>，表示<strong>真实情况和预测结果皆为真/预测结果为真</strong></li><li><strong>召回率</strong>$\mathrm{(Recall)}$   <font size="4rem">$\mathrm{R=\frac{TP}{TP+FN} \times 100 \%}$</font>，表示<strong>真实情况和预测结果皆为真/真实情况为真</strong></li></ul><h3 id="F1分数（F1-score）"><a href="#F1分数（F1-score）" class="headerlink" title="F1分数（F1-score）"></a>F1分数（F1-score）</h3><blockquote><p>F1分数（$\mathrm{F1-score}$）即精确率与召回率的调和平均数（$\mathrm{Harmonic \, Mean}$），比算术平均数（$\mathrm{Arithmetic \, Mean}$）的评价效果更好。</p></blockquote><font size="5rem">$\mathrm{F1=\frac{2}{\frac1{P}+\frac1{R}}=\frac{2PR}{P+R}}$</font><a id="more"></a><h2 id="直观理解为什么F1-score能评价模型优劣"><a href="#直观理解为什么F1-score能评价模型优劣" class="headerlink" title="直观理解为什么F1-score能评价模型优劣"></a>直观理解为什么F1-score能评价模型优劣</h2><p>在你训练的机器学习模型过程中，你往往希望能够兼顾<strong>精确率</strong>和<strong>召回率</strong>，并使用一个统一的<strong>单值评价指标来评价</strong>你的机器学习模型的训练效果。我们之所以使用<strong>调和平均</strong>而不是<strong>算术平均</strong>，是因为在<strong>算术平均</strong>中，任何一方对数值增长的贡献相当，任何一方对数值下降的责任也相当；而<strong>调和平均</strong>在增长的时候会偏袒较小值，也会惩罚<strong>精确率</strong>和<strong>召回率</strong>相差巨大的极端情况，很好地兼顾了<strong>精确率</strong>和<strong>召回率</strong>。</p><h3 id="几何观点"><a href="#几何观点" class="headerlink" title="几何观点"></a>几何观点</h3><p><img src="https://i.loli.net/2020/02/06/12cwKpjqIAumLJ6.jpg" alt></p><p>上图为函数图象<font size="5" rem>$z=f(x, y)=\frac{2xy}{x+y}$</font>。显而易见当<font size="4" rem>$x=1$</font>，<font size="4" rem>$y=0$</font>或者<font size="4" rem>$y=1$</font>，<font size="4" rem>$x=0$</font>时，<font size="4" rem>$z=0$</font>，说明<strong>调和平均</strong>惩罚<strong>精确率</strong>和<strong>召回率</strong>相差很大的极端情况。当<font size="4" rem>$x&lt;y$</font>时，梯度<font size="4" rem>$\mathrm{grad} \, z $</font>在<font size="4" rem>$x$</font>方向增长比<font size="4" rem>$y$</font>方向快；当<font size="4" rem>$y&lt;x$</font>时，梯度<font size="4" rem>$\mathrm{grad} \, z$</font>在<font size="4" rem>$y$</font>方向增长比<font size="4" rem>$x$</font>方向快，即<strong>调和平均</strong>在增长的时候会偏袒较小值。</p><h3 id="代数观点"><a href="#代数观点" class="headerlink" title="代数观点"></a>代数观点</h3><p>对函数<font size="5" rem>$f(x, y)=\frac{2xy}{x+y}$</font>，其图象关于平面<font size="4" rem>$x=y$</font>对称。分别求<font size="4rem">$f(x,y)$</font>对<font size="4rem">$x$</font>和<font size="4rem">$y$</font>的偏导数：</p><p>​     <font size="5" rem>$\frac{\partial f(x,y)}{\partial x}=\frac{2y^2}{(x+y)^2}$</font></p><p>​     <font size="5" rem>$\frac{\partial f(x,y)}{\partial y}=\frac{2x^2}{(x+y)^2}$</font></p><p>当<font size="4" rem>$x&lt;y$</font>时，<font size="5" rem>$\frac{\partial f(x,y)}{\partial x}&gt;\frac{\partial f(x,y)}{\partial y}$</font>，梯度<font size="4" rem>$\mathrm{grad} \, z $</font>在<font size="4" rem>$x$</font>方向增长比<font size="4" rem>$y$</font>方向快；</p><p>当<font size="4" rem>$y&lt;x$</font>时，<font size="5" rem>$\frac{\partial f(x,y)}{\partial y}&gt;\frac{\partial f(x,y)}{\partial x}$</font>，梯度<font size="4" rem>$\mathrm{grad} \, z$</font>在<font size="4" rem>$y$</font>方向增长比<font size="4" rem>$x$</font>方向快，即<strong>调和平均</strong>在增长的时候会偏袒较小值。</p><p>可以看出，<font size="4" rem>$\mathrm{F1-score}$</font>是一种综合的评价指标,它要求总体高指标必须建立在同时满足高<strong>精确率</strong>和高<strong>召回率</strong>的情况之上。使得我们可以更方便快速地对不同模型进行比较，从而选择最优的那个模型。</p><hr><blockquote><p>Reference and lots of thanks：<a href="https://blog.csdn.net/otengyue/article/details/89426004" target="_blank" rel="noopener">https://blog.csdn.net/otengyue/article/details/89426004</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.pixabay.com/photo/2015/08/01/13/47/seattle-870282_1280.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;机器学习中的评价指标：F1-score&quot;&gt;&lt;a href=&quot;#机器学习中的评价指标：F1-score&quot; class=&quot;headerlink&quot; title=&quot;机器学习中的评价指标：F1-score&quot;&gt;&lt;/a&gt;机器学习中的评价指标：F1-score&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;图：西雅图（Seattle）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;h2 id=&quot;回顾：F1-score的计算过程&quot;&gt;&lt;a href=&quot;#回顾：F1-score的计算过程&quot; class=&quot;headerlink&quot; title=&quot;回顾：F1-score的计算过程&quot;&gt;&lt;/a&gt;回顾：F1-score的计算过程&lt;/h2&gt;&lt;h3 id=&quot;混淆矩阵（Confusion-Matrix）&quot;&gt;&lt;a href=&quot;#混淆矩阵（Confusion-Matrix）&quot; class=&quot;headerlink&quot; title=&quot;混淆矩阵（Confusion Matrix）&quot;&gt;&lt;/a&gt;混淆矩阵（Confusion Matrix）&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;混淆矩阵也称误差矩阵，是表示精度评价的一种标准格式，用n行n列的矩阵形式来表示。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在机器学习领域，混淆矩阵用于衡量一个分类器的准确程度。对于二分类问题，将其样例根据真实类别和分类器的预测类别的组合划分为真正例$\mathrm{(True \, Positive)}$、假正例$\mathrm{(False \, Positive)}$、真反例$\mathrm{(True \, Negative)}$、假反例$\mathrm{(False \, Negative)}$四种情形。&lt;/p&gt;
&lt;p&gt;对应混淆矩阵$\mathrm{(Confusion \, Matrix)}$如下表：&lt;/p&gt;
&lt;p&gt;&lt;style type=&quot;text/css&quot;&gt;&lt;br&gt;.tg  {border-collapse:collapse;border-spacing:0;}&lt;br&gt;.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}&lt;br&gt;.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}&lt;br&gt;.tg .tg-0lax{text-align:left;vertical-align:top}&lt;br&gt;.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
&lt;/style&gt;&lt;/p&gt;
&lt;table class=&quot;tg&quot;&gt;
  &lt;tr&gt;
    &lt;th class=&quot;tg-0lax&quot; rowspan=&quot;2&quot;&gt;&lt;center&gt;真实情况&lt;/center&gt;&lt;/th&gt;
    &lt;th class=&quot;tg-0lax&quot; colspan=&quot;2&quot;&gt;&lt;center&gt;预测结果&lt;/center&gt;&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;&lt;center&gt;真&lt;/center&gt;&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;&lt;center&gt;假&lt;/center&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;&lt;center&gt;真&lt;/center&gt;&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;&lt;center&gt;TP（真正例）&lt;/center&gt;&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;&lt;center&gt;FN（假反例）&lt;/center&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;&lt;center&gt;假&lt;/center&gt;&lt;/td&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;&lt;center&gt;FP（假正例）&lt;/center&gt;&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;&lt;center&gt;TN（真反例）&lt;/center&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3 id=&quot;精确率（Precision）与召回率（Recall）&quot;&gt;&lt;a href=&quot;#精确率（Precision）与召回率（Recall）&quot; class=&quot;headerlink&quot; title=&quot;精确率（Precision）与召回率（Recall）&quot;&gt;&lt;/a&gt;精确率（Precision）与召回率（Recall）&lt;/h3&gt;&lt;p&gt;根据混淆矩阵，我们可以得到如下定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;精确率&lt;/strong&gt;$\mathrm{(Precision)}$   &lt;font size=&quot;4rem&quot;&gt;$\mathrm{P=\frac{TP}{TP+FP} \times 100\%}$&lt;/font&gt;，表示&lt;strong&gt;真实情况和预测结果皆为真/预测结果为真&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;召回率&lt;/strong&gt;$\mathrm{(Recall)}$   &lt;font size=&quot;4rem&quot;&gt;$\mathrm{R=\frac{TP}{TP+FN} \times 100 \%}$&lt;/font&gt;，表示&lt;strong&gt;真实情况和预测结果皆为真/真实情况为真&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;F1分数（F1-score）&quot;&gt;&lt;a href=&quot;#F1分数（F1-score）&quot; class=&quot;headerlink&quot; title=&quot;F1分数（F1-score）&quot;&gt;&lt;/a&gt;F1分数（F1-score）&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;F1分数（$\mathrm{F1-score}$）即精确率与召回率的调和平均数（$\mathrm{Harmonic \, Mean}$），比算术平均数（$\mathrm{Arithmetic \, Mean}$）的评价效果更好。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;font size=&quot;5rem&quot;&gt;$\mathrm{F1=\frac{2}{\frac1{P}+\frac1{R}}=\frac{2PR}{P+R}}$&lt;/font&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="机器学习" scheme="https://G-SS-Hacker.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="微积分" scheme="https://G-SS-Hacker.github.io/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>C &amp; C++基本数据类型取值范围</title>
    <link href="https://g-ss-hacker.github.io/C%E5%92%8CC-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4/"/>
    <id>https://g-ss-hacker.github.io/C%E5%92%8CC-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4/</id>
    <published>2020-02-05T09:01:37.000Z</published>
    <updated>2020-02-05T09:11:10.856Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.pexels.com/photos/34609/pexels-photo.jpg?auto=compress&amp;cs=tinysrgb&amp;dpr=2&amp;h=750&amp;w=1260" alt></p><h1 id="C-amp-C-基本数据类型取值范围"><a href="#C-amp-C-基本数据类型取值范围" class="headerlink" title="C &amp; C++基本数据类型取值范围"></a>C &amp; C++基本数据类型取值范围</h1><blockquote><p>图：伦敦（London）</p></blockquote><p></p><p><font color="grey"><em>Guderian</em>出品 </font></p><p></p><p><style type="text/css"><br>.tg  {border-collapse:collapse;border-spacing:0;}<br>.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}<br>.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}<br>.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}</style></p><table class="tg">  <tr>    <th class="tg-0pky" colspan="2">基本数据类型</th>    <th class="tg-0pky">关键字</th>    <th class="tg-0pky">存储大小</th>    <th class="tg-0pky">取数范围</th>  </tr>  <tr>    <td class="tg-0pky">整型</td>    <td class="tg-0pky">基本整型</td>    <td class="tg-0pky">int</td>    <td class="tg-0pky">4字节</td>    <td class="tg-0pky">-2^31 ~ 2^31-1</td>  </tr>  <tr>    <td class="tg-0pky" rowspan="3">实型</td>    <td class="tg-0pky">长整型</td>    <td class="tg-0pky">long</td>    <td class="tg-0pky">4字节</td>    <td class="tg-0pky">-2^31 ~ 2^31-1</td>  </tr>  <tr>    <td class="tg-0pky">短整型</td>    <td class="tg-0pky">short</td>    <td class="tg-0pky">2字节</td>    <td class="tg-0pky">-2^15 ~ 2^15-1</td>  </tr>  <tr>    <td class="tg-0pky">无符号整型</td>    <td class="tg-0pky">unsigned</td>    <td class="tg-0pky">unsigned int 4字节<br>unsigned long 4字节<br>unsigned short 2字节<br></td>    <td class="tg-0pky">unsigned int : 0 ~ 2^32-1<br>unsigned long : 0 ~ 2^32-1<br>unsigned short : 0 ~ 2^16-1<br></td>  </tr>  <tr>    <td class="tg-0pky" rowspan="3">实型</td>    <td class="tg-0pky">单精度实型</td>    <td class="tg-0pky">float</td>    <td class="tg-0pky">4字节</td>    <td class="tg-0pky">1.2E-38 ~ 3.4E+38 精度6位小数</td>  </tr>  <tr>    <td class="tg-0pky">双精度实型</td>    <td class="tg-0pky">double</td>    <td class="tg-0pky">8字节</td>    <td class="tg-0pky">2.3E-308 ~ 1.7E+308 精度15位小数</td>  </tr>  <tr>    <td class="tg-0pky">长双精度实型</td>    <td class="tg-0pky">long double</td>    <td class="tg-0pky">16字节</td>    <td class="tg-0pky">3.4E-4932 ~ 1.1E+4932 精度19位小数</td>  </tr>  <tr>    <td class="tg-0pky" colspan="2">字符型</td>    <td class="tg-0pky">char</td>    <td class="tg-0pky">1字节</td>    <td class="tg-0pky">0 ~ 2^8-1</td>  </tr>  <tr>    <td class="tg-0pky" colspan="2">枚举类型</td>    <td class="tg-0pky">enum</td>    <td class="tg-0pky"></td>    <td class="tg-0pky"></td>  </tr></table><a id="more"></a><hr><font color="orange"><strong>我们不管遇到多复杂的数据类型都不要怕，我们戴口罩面对它。消除恐惧的最好办法就是面对恐惧！坚持就是胜利！学好C语言！奥利给！</strong></font>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://images.pexels.com/photos/34609/pexels-photo.jpg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;dpr=2&amp;amp;h=750&amp;amp;w=1260&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;C-amp-C-基本数据类型取值范围&quot;&gt;&lt;a href=&quot;#C-amp-C-基本数据类型取值范围&quot; class=&quot;headerlink&quot; title=&quot;C &amp;amp; C++基本数据类型取值范围&quot;&gt;&lt;/a&gt;C &amp;amp; C++基本数据类型取值范围&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;图：伦敦（London）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt;&lt;em&gt;Guderian&lt;/em&gt;出品 &lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;style type=&quot;text/css&quot;&gt;&lt;br&gt;.tg  {border-collapse:collapse;border-spacing:0;}&lt;br&gt;.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}&lt;br&gt;.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}&lt;br&gt;.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
&lt;/style&gt;&lt;/p&gt;
&lt;table class=&quot;tg&quot;&gt;
  &lt;tr&gt;
    &lt;th class=&quot;tg-0pky&quot; colspan=&quot;2&quot;&gt;基本数据类型&lt;/th&gt;
    &lt;th class=&quot;tg-0pky&quot;&gt;关键字&lt;/th&gt;
    &lt;th class=&quot;tg-0pky&quot;&gt;存储大小&lt;/th&gt;
    &lt;th class=&quot;tg-0pky&quot;&gt;取数范围&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;整型&lt;/td&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;基本整型&lt;/td&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;int&lt;/td&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;4字节&lt;/td&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;-2^31 ~ 2^31-1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-0pky&quot; rowspan=&quot;3&quot;&gt;实型&lt;/td&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;长整型&lt;/td&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;long&lt;/td&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;4字节&lt;/td&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;-2^31 ~ 2^31-1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;短整型&lt;/td&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;short&lt;/td&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;2字节&lt;/td&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;-2^15 ~ 2^15-1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;无符号整型&lt;/td&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;unsigned&lt;/td&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;unsigned int 4字节&lt;br&gt;unsigned long 4字节&lt;br&gt;unsigned short 2字节&lt;br&gt;&lt;/td&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;unsigned int : 0 ~ 2^32-1&lt;br&gt;unsigned long : 0 ~ 2^32-1&lt;br&gt;unsigned short : 0 ~ 2^16-1&lt;br&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-0pky&quot; rowspan=&quot;3&quot;&gt;实型&lt;/td&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;单精度实型&lt;/td&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;float&lt;/td&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;4字节&lt;/td&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;1.2E-38 ~ 3.4E+38 精度6位小数&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;双精度实型&lt;/td&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;double&lt;/td&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;8字节&lt;/td&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;2.3E-308 ~ 1.7E+308 精度15位小数&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;长双精度实型&lt;/td&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;long double&lt;/td&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;16字节&lt;/td&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;3.4E-4932 ~ 1.1E+4932 精度19位小数&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-0pky&quot; colspan=&quot;2&quot;&gt;字符型&lt;/td&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;char&lt;/td&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;1字节&lt;/td&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;0 ~ 2^8-1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-0pky&quot; colspan=&quot;2&quot;&gt;枚举类型&lt;/td&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;enum&lt;/td&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;&lt;/td&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="C-plus-plus" scheme="https://G-SS-Hacker.github.io/tags/C-plus-plus/"/>
    
      <category term="C" scheme="https://G-SS-Hacker.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Softmax函数反向传播求导详细过程</title>
    <link href="https://g-ss-hacker.github.io/Softmax%E5%87%BD%E6%95%B0%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E6%B1%82%E5%AF%BC%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B/"/>
    <id>https://g-ss-hacker.github.io/Softmax%E5%87%BD%E6%95%B0%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E6%B1%82%E5%AF%BC%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B/</id>
    <published>2020-02-04T14:22:46.000Z</published>
    <updated>2020-02-06T11:14:56.608Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2020/02/05/1rU0Fs.png" alt></p><h1 id="Softmax函数反向传播求导详细过程"><a href="#Softmax函数反向传播求导详细过程" class="headerlink" title="Softmax函数反向传播求导详细过程"></a>Softmax函数反向传播求导详细过程</h1><blockquote><p>图：纽约，曼哈顿（Manhattan, New York）</p></blockquote><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><p></p><h2 id="回顾：Softmax函数正向传播"><a href="#回顾：Softmax函数正向传播" class="headerlink" title="回顾：Softmax函数正向传播"></a>回顾：Softmax函数正向传播</h2><h3 id="第一步：计算Z函数"><a href="#第一步：计算Z函数" class="headerlink" title="第一步：计算Z函数"></a>第一步：计算Z函数</h3><p>对神经网络输出层（即第<font size="4rem">$ L $</font>层）有<font size="4rem">$Z^{[L]}=W^{[L]}a^{[L-1]}+b^{[L]}$</font>，其中<font size="4rem">$a^{[L-1]}$</font>为上一层输出值。</p><h3 id="第二步：计算Softmax函数"><a href="#第二步：计算Softmax函数" class="headerlink" title="第二步：计算Softmax函数"></a>第二步：计算Softmax函数</h3><font size="4rem," face="consolas">for i in range(1, C + 1):</font> <p>​    <font size="5rem">$\quad a_i^{[L]}=\frac{e^{Z_i^{[L]}}}{\sum_{k=1}^C e^{Z_k^{[L]}}}$</font></p><p>其中<font size="4rem">$C$</font>表示要预测的类别数，上式满足<font size="4rem">$\sum_{i=1}^C a_i{[L]}=1$</font>，即输入样本属于各类别的概率和为<font size="4rem">$1$</font>。</p><h3 id="第三步：计算损失函数"><a href="#第三步：计算损失函数" class="headerlink" title="第三步：计算损失函数"></a>第三步：计算损失函数</h3><p>单个样本的损失函数为<font size="4rem">$L(a,y)=-\sum_{i=1}^C y_i\log{a_i}$</font>，其中<font size="4rem">$y$</font>为目标输出。</p><h2 id="求导"><a href="#求导" class="headerlink" title="求导"></a>求导</h2><h3 id="第一步：对Softmax函数求导"><a href="#第一步：对Softmax函数求导" class="headerlink" title="第一步：对Softmax函数求导"></a>第一步：对Softmax函数求导</h3><p>​    对<font size="4rem">$\mathrm{Softmax}$</font>函数求导，即求<font size="5rem">$\frac{\partial a_i}{\partial z_j}$</font>：第<font size="4rem">$\mathrm{i}$</font>项输出对第<font size="4rem">$\mathrm{j}$</font>项输入的偏导数。</p><p>​    <font size="5rem">$\frac{\partial a_i}{\partial z_j}=\frac{\partial\frac{e^{z_i}}{\sum_{k=1}^C e^{z_k}}}{\partial z_j}$</font>（省略<font size="4rem">$[ L ]$</font>标记，默认为第<font size="4rem">$ L $</font>层，下同），分类讨论：</p><p>​    $(1)$当<font size="4rem">$\mathrm{i=j}$</font>时，把<font size="4rem">$a_i$</font>分母中除<font size="4rem">$e^{z_j}$</font>项外视作常量</p><p>​    <font size="5rem">$\frac{\partial a_i}{\partial z_j}=\frac{\partial\frac{e^{z_j}}{\sum_{k=1}^C e^{z_k}}}{\partial z_j}=(\frac{e^{z_j}}{e^{z_j}+\sum_{k\ne j}^C e^{z_k}})^\prime=a_j(1-a_j)$</font></p><p>​    $(2)$当<font size="4rem">$\mathrm{i\ne j}$</font>时，把<font size="4rem">$a_i$</font>分子和分母中除<font size="4rem">$e^{z_j}$</font>项外视作常量</p><p>​    <font size="5rem">$\frac{\partial a_i}{\partial z_j}=\frac{\partial\frac{e^{z_i}}{\sum_{k=1}^C e^{z_k}}}{\partial z_j}=(\frac{e^{z_i}}{e^{z_j}+\sum_{k\ne j}^C e^{z_k}})^\prime=\frac{e^{z_i}e^{z_j}}{\sum_{k=1}^C e^{z_k}}=-a_i a_j$</font></p><a id="more"></a><h3 id="第二步：对损失函数求导"><a href="#第二步：对损失函数求导" class="headerlink" title="第二步：对损失函数求导"></a>第二步：对损失函数求导</h3><p>对损失函数求导，即求<font size="5rem">$\frac{\partial L}{\partial z_j}$</font>：损失函数对第<font size="4rem">$\mathrm{j}$</font>项输入的偏导数。</p><p>​    <font size="4rem">$\because L(a,y)=-\sum_{i=1}^C y_i\log{a_i}$</font> </p><p>​    <font size="5rem">$\therefore \frac{\partial L}{\partial z_j}=-\sum_{i=1}^C y_i\frac{\partial \log a_i}{\partial z_j}=-\sum_{i=1}^C \frac{y_i}{a_i}\frac{\partial a_i}{\partial z_j}$</font></p><p>（把<font size="4rem">$y_i$</font>视作常量，再用链导法则转化为对<font size="4rem">$\mathrm{Softmax}$</font>函数求导）</p><p>分别代入$(1)(2)$得：</p><font size="5rem">$-\sum_{i=1}^C \frac{y_i}{a_i}\frac{\partial a_i}{\partial z_j}=-\frac{y_i}{a_i}\frac{\partial a_i}{\partial z_j} \, -\sum_{i=1,i \ne j}^C \frac{y_i}{a_i}\frac{\partial a_i}{\partial z_j}$</font> <p>​        <font size="1rem"> </font></p><p>​                                <font size="5rem">$\quad =$</font> <font size="5rem">$-\frac{y_j}{a_j}a_j(1-a_j)\,+\sum_{i=1,i \ne j}^C \frac{y_i}{a_i}a_ia_j$</font> </p><p>​                                <font size="5rem">$\quad =$</font> <font size="4rem">$-y_j\, +y_ja_j\, +\sum_{i=1,i \ne j}^C y_ia_j$</font> </p><p>​                                <font size="5rem">$\quad =$</font> <font size="4rem">$-y_j\, +\sum_{i=1}^C y_ia_j$</font> （合并<font size="4rem">$y_ja_j$</font>至<font size="4rem">$\sum_{i=1,i \ne j}^C y_ia_j$</font>中） </p><p>​                                <font size="5rem">$\quad =$</font> <font size="4rem">$-y_i\, +a_j\sum_{i=1}^C y_i$</font> （提出<font size="4rem">$a_j$</font>） </p><p>​                                <font size="5rem">$\quad =$</font> <font size="4rem">$a_j-y_j$</font> </p><p>从上述结果可以看出，<font size="4rem">$\mathrm{Softmax}$</font>回归和<font size="4rem">$\mathrm{Logistic}$</font>回归中损失函数求导后具有相同的形式，这也说明了<font size="4rem">$\mathrm{Softmax}$</font>回归和<font size="4rem">$\mathrm{Logistic}$</font>回归具有相同的本质，<font size="4rem">$\mathrm{Softmax}$</font>回归是<font size="4rem">$\mathrm{Logistic}$</font>的推广。</p><hr><blockquote><p>Reference and lots of thanks：<a href="https://www.cnblogs.com/zhaopAC/p/9539118.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhaopAC/p/9539118.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/02/05/1rU0Fs.png&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;Softmax函数反向传播求导详细过程&quot;&gt;&lt;a href=&quot;#Softmax函数反向传播求导详细过程&quot; class=&quot;headerlink&quot; title=&quot;Softmax函数反向传播求导详细过程&quot;&gt;&lt;/a&gt;Softmax函数反向传播求导详细过程&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;图：纽约，曼哈顿（Manhattan, New York）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;h2 id=&quot;回顾：Softmax函数正向传播&quot;&gt;&lt;a href=&quot;#回顾：Softmax函数正向传播&quot; class=&quot;headerlink&quot; title=&quot;回顾：Softmax函数正向传播&quot;&gt;&lt;/a&gt;回顾：Softmax函数正向传播&lt;/h2&gt;&lt;h3 id=&quot;第一步：计算Z函数&quot;&gt;&lt;a href=&quot;#第一步：计算Z函数&quot; class=&quot;headerlink&quot; title=&quot;第一步：计算Z函数&quot;&gt;&lt;/a&gt;第一步：计算Z函数&lt;/h3&gt;&lt;p&gt;对神经网络输出层（即第&lt;font size=&quot;4rem&quot;&gt;$ L $&lt;/font&gt;层）有&lt;font size=&quot;4rem&quot;&gt;$Z^{[L]}=W^{[L]}a^{[L-1]}+b^{[L]}$&lt;/font&gt;，其中&lt;font size=&quot;4rem&quot;&gt;$a^{[L-1]}$&lt;/font&gt;为上一层输出值。&lt;/p&gt;
&lt;h3 id=&quot;第二步：计算Softmax函数&quot;&gt;&lt;a href=&quot;#第二步：计算Softmax函数&quot; class=&quot;headerlink&quot; title=&quot;第二步：计算Softmax函数&quot;&gt;&lt;/a&gt;第二步：计算Softmax函数&lt;/h3&gt;&lt;font size=&quot;4rem,&quot; face=&quot;consolas&quot;&gt;for i in range(1, C + 1):&lt;/font&gt; 

&lt;p&gt;​    &lt;font size=&quot;5rem&quot;&gt;$\quad a_i^{[L]}=\frac{e^{Z_i^{[L]}}}{\sum_{k=1}^C e^{Z_k^{[L]}}}$&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;font size=&quot;4rem&quot;&gt;$C$&lt;/font&gt;表示要预测的类别数，上式满足&lt;font size=&quot;4rem&quot;&gt;$\sum_{i=1}^C a_i{[L]}=1$&lt;/font&gt;，即输入样本属于各类别的概率和为&lt;font size=&quot;4rem&quot;&gt;$1$&lt;/font&gt;。&lt;/p&gt;
&lt;h3 id=&quot;第三步：计算损失函数&quot;&gt;&lt;a href=&quot;#第三步：计算损失函数&quot; class=&quot;headerlink&quot; title=&quot;第三步：计算损失函数&quot;&gt;&lt;/a&gt;第三步：计算损失函数&lt;/h3&gt;&lt;p&gt;单个样本的损失函数为&lt;font size=&quot;4rem&quot;&gt;$L(a,y)=-\sum_{i=1}^C y_i\log{a_i}$&lt;/font&gt;，其中&lt;font size=&quot;4rem&quot;&gt;$y$&lt;/font&gt;为目标输出。&lt;/p&gt;
&lt;h2 id=&quot;求导&quot;&gt;&lt;a href=&quot;#求导&quot; class=&quot;headerlink&quot; title=&quot;求导&quot;&gt;&lt;/a&gt;求导&lt;/h2&gt;&lt;h3 id=&quot;第一步：对Softmax函数求导&quot;&gt;&lt;a href=&quot;#第一步：对Softmax函数求导&quot; class=&quot;headerlink&quot; title=&quot;第一步：对Softmax函数求导&quot;&gt;&lt;/a&gt;第一步：对Softmax函数求导&lt;/h3&gt;&lt;p&gt;​    对&lt;font size=&quot;4rem&quot;&gt;$\mathrm{Softmax}$&lt;/font&gt;函数求导，即求&lt;font size=&quot;5rem&quot;&gt;$\frac{\partial a_i}{\partial z_j}$&lt;/font&gt;：第&lt;font size=&quot;4rem&quot;&gt;$\mathrm{i}$&lt;/font&gt;项输出对第&lt;font size=&quot;4rem&quot;&gt;$\mathrm{j}$&lt;/font&gt;项输入的偏导数。&lt;/p&gt;
&lt;p&gt;​    &lt;font size=&quot;5rem&quot;&gt;$\frac{\partial a_i}{\partial z_j}=\frac{\partial\frac{e^{z_i}}{\sum_{k=1}^C e^{z_k}}}{\partial z_j}$&lt;/font&gt;（省略&lt;font size=&quot;4rem&quot;&gt;$[ L ]$&lt;/font&gt;标记，默认为第&lt;font size=&quot;4rem&quot;&gt;$ L $&lt;/font&gt;层，下同），分类讨论：&lt;/p&gt;
&lt;p&gt;​    $(1)$当&lt;font size=&quot;4rem&quot;&gt;$\mathrm{i=j}$&lt;/font&gt;时，把&lt;font size=&quot;4rem&quot;&gt;$a_i$&lt;/font&gt;分母中除&lt;font size=&quot;4rem&quot;&gt;$e^{z_j}$&lt;/font&gt;项外视作常量&lt;/p&gt;
&lt;p&gt;​    &lt;font size=&quot;5rem&quot;&gt;$\frac{\partial a_i}{\partial z_j}=\frac{\partial\frac{e^{z_j}}{\sum_{k=1}^C e^{z_k}}}{\partial z_j}=(\frac{e^{z_j}}{e^{z_j}+\sum_{k\ne j}^C e^{z_k}})^\prime=a_j(1-a_j)$&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;​    $(2)$当&lt;font size=&quot;4rem&quot;&gt;$\mathrm{i\ne j}$&lt;/font&gt;时，把&lt;font size=&quot;4rem&quot;&gt;$a_i$&lt;/font&gt;分子和分母中除&lt;font size=&quot;4rem&quot;&gt;$e^{z_j}$&lt;/font&gt;项外视作常量&lt;/p&gt;
&lt;p&gt;​    &lt;font size=&quot;5rem&quot;&gt;$\frac{\partial a_i}{\partial z_j}=\frac{\partial\frac{e^{z_i}}{\sum_{k=1}^C e^{z_k}}}{\partial z_j}=(\frac{e^{z_i}}{e^{z_j}+\sum_{k\ne j}^C e^{z_k}})^\prime=\frac{e^{z_i}e^{z_j}}{\sum_{k=1}^C e^{z_k}}=-a_i a_j$&lt;/font&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="机器学习" scheme="https://G-SS-Hacker.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="神经网络" scheme="https://G-SS-Hacker.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="微积分" scheme="https://G-SS-Hacker.github.io/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>UML状态图</title>
    <link href="https://g-ss-hacker.github.io/UML%E7%8A%B6%E6%80%81%E5%9B%BE/"/>
    <id>https://g-ss-hacker.github.io/UML%E7%8A%B6%E6%80%81%E5%9B%BE/</id>
    <published>2020-02-03T13:56:57.000Z</published>
    <updated>2020-02-04T03:25:19.383Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.pexels.com/photos/313032/pexels-photo-313032.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=2&amp;h=750&amp;w=1260" alt></p><font color="#407600">【面向对象分析UML建模工具全部文章】</font><ul><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E7%94%A8%E4%BE%8B%E5%9B%BE/">UML建模工具(1)——用例图</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E6%B4%BB%E5%8A%A8%E5%9B%BE/">UML建模工具(2)——活动图</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E7%B1%BB%E5%9B%BE/">UML建模工具(3)——类图</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E9%A1%BA%E5%BA%8F%E5%9B%BE/">UML建模工具(4)——顺序图</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E9%80%9A%E4%BF%A1%E5%9B%BE/">UML建模工具(5)——通信图</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E7%8A%B6%E6%80%81%E5%9B%BE/">UML建模工具(6)——状态图</a></li></ul><h1 id="UML建模工具——状态图"><a href="#UML建模工具——状态图" class="headerlink" title="UML建模工具——状态图"></a>UML建模工具——状态图</h1><blockquote><p>图：马来西亚，吉隆坡（Kapa Lumpur）</p></blockquote><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><p></p><blockquote><p>状态图(Statechart Diagram)是描述一个实体（对象）基于事件反应的动态行为</p></blockquote><h2 id="完整的状态图例子"><a href="#完整的状态图例子" class="headerlink" title="完整的状态图例子"></a>完整的状态图例子</h2><p><img src="https://i.loli.net/2020/02/03/9ves8PrpAUhfT6E.png" alt></p><a id="more"></a><h2 id="状态图的建模元素"><a href="#状态图的建模元素" class="headerlink" title="状态图的建模元素"></a>状态图的建模元素</h2><h3 id="状态（State）"><a href="#状态（State）" class="headerlink" title="状态（State）"></a>状态（State）</h3><p><img src="https://i.loli.net/2020/02/03/AL8rJ1mUebfPH7Z.png" alt></p><p>状态<strong>亮灯</strong>如上图所示，状态用圆角矩形表示，其中可以包括：</p><ul><li>名称</li><li>进入动作</li><li>退出动作</li><li>内部迁移</li><li>子状态</li></ul><h3 id="事件（Event）"><a href="#事件（Event）" class="headerlink" title="事件（Event）"></a>事件（Event）</h3><blockquote><p> 事件可视作引起一个状态迁移至另一个状态的激励条件</p></blockquote><p>如以上状态图中，事件<strong>会员收货</strong>使得状态<strong>订单发货</strong>迁移至<strong>订单收货</strong>。</p><p>事件必须有意义，只有有意义的事件才会促成状态迁移，无意义的事件对状态不产生影响。</p><h3 id="迁移（Transition）"><a href="#迁移（Transition）" class="headerlink" title="迁移（Transition）"></a>迁移（Transition）</h3><p><img src="https://i.loli.net/2020/02/03/elGnTOKpmiSHhN2.png" alt></p><p>如上图所示，迁移为状态之间的关联，且必须有事件触发器并满足一定触发条件才会产生状态间的迁移。</p><p>迁移由5部分组成：</p><ul><li>源状态</li><li>事件触发器</li><li>触发条件</li><li>效应</li><li>目标状态</li></ul><h2 id="状态图建模注意事项"><a href="#状态图建模注意事项" class="headerlink" title="状态图建模注意事项"></a>状态图建模注意事项</h2><ul><li>一个状态必须与其他状态有关联，不允许孤立存在</li><li>不允许只进不出或只出不进的迁移</li><li>不允许没有事件的迁移</li></ul><hr><blockquote><p>Reference：<a href="https://edu.csdn.net/course/play/24559/273459" target="_blank" rel="noopener">https://edu.csdn.net/course/play/24559/273459</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://images.pexels.com/photos/313032/pexels-photo-313032.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;dpr=2&amp;amp;h=750&amp;amp;w=1260&quot; alt&gt;&lt;/p&gt;
&lt;font color=&quot;#407600&quot;&gt;【面向对象分析UML建模工具全部文章】&lt;/font&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E7%94%A8%E4%BE%8B%E5%9B%BE/&quot;&gt;UML建模工具(1)——用例图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E6%B4%BB%E5%8A%A8%E5%9B%BE/&quot;&gt;UML建模工具(2)——活动图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E7%B1%BB%E5%9B%BE/&quot;&gt;UML建模工具(3)——类图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E9%A1%BA%E5%BA%8F%E5%9B%BE/&quot;&gt;UML建模工具(4)——顺序图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E9%80%9A%E4%BF%A1%E5%9B%BE/&quot;&gt;UML建模工具(5)——通信图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E7%8A%B6%E6%80%81%E5%9B%BE/&quot;&gt;UML建模工具(6)——状态图&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;UML建模工具——状态图&quot;&gt;&lt;a href=&quot;#UML建模工具——状态图&quot; class=&quot;headerlink&quot; title=&quot;UML建模工具——状态图&quot;&gt;&lt;/a&gt;UML建模工具——状态图&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;图：马来西亚，吉隆坡（Kapa Lumpur）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;状态图(Statechart Diagram)是描述一个实体（对象）基于事件反应的动态行为&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;完整的状态图例子&quot;&gt;&lt;a href=&quot;#完整的状态图例子&quot; class=&quot;headerlink&quot; title=&quot;完整的状态图例子&quot;&gt;&lt;/a&gt;完整的状态图例子&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/02/03/9ves8PrpAUhfT6E.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="面向对象" scheme="https://G-SS-Hacker.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="软件工程" scheme="https://G-SS-Hacker.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="UML" scheme="https://G-SS-Hacker.github.io/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>UML通信图</title>
    <link href="https://g-ss-hacker.github.io/UML%E9%80%9A%E4%BF%A1%E5%9B%BE/"/>
    <id>https://g-ss-hacker.github.io/UML%E9%80%9A%E4%BF%A1%E5%9B%BE/</id>
    <published>2020-02-02T00:40:00.000Z</published>
    <updated>2020-02-04T03:25:42.670Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.pexels.com/photos/417054/pexels-photo-417054.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=2&amp;w=500" alt></p><font color="#407600">【面向对象分析UML建模工具全部文章】</font><ul><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E7%94%A8%E4%BE%8B%E5%9B%BE/">UML建模工具(1)——用例图</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E6%B4%BB%E5%8A%A8%E5%9B%BE/">UML建模工具(2)——活动图</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E7%B1%BB%E5%9B%BE/">UML建模工具(3)——类图</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E9%A1%BA%E5%BA%8F%E5%9B%BE/">UML建模工具(4)——顺序图</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E9%80%9A%E4%BF%A1%E5%9B%BE/">UML建模工具(5)——通信图</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E7%8A%B6%E6%80%81%E5%9B%BE/">UML建模工具(6)——状态图</a></li></ul><h1 id="UML建模工具——通信图"><a href="#UML建模工具——通信图" class="headerlink" title="UML建模工具——通信图"></a>UML建模工具——通信图</h1><blockquote><p>图：旧金山湾，黑夜中的金门大桥（Golden Gate Bridge）</p></blockquote><p><font color="grey"> <em>Guderian出品</em> </font></p><blockquote><p>通信图（Communication diagram）和顺序图都属于UML交互图，与顺序图本质上是一样的，可以互换</p><p>但二者建模的角度不同<sup><a href="#fn_ 1" id="reffn_ 1"> 1</a></sup></p><ul><li><font color="red">通信图 强调随着时间的推移，各对象是如何交互的</font></li><li><font color="red">通信图 强调对象之间的结构关系</font></li></ul></blockquote><h2 id="通信图的组成元素"><a href="#通信图的组成元素" class="headerlink" title="通信图的组成元素"></a>通信图的组成元素</h2><ul><li>对象（object）</li><li>链接（link）</li></ul><blockquote><p>注意虽然链接和关联的图形都是一条实线，但是此处的链接是对象之间的关系，而关联是类之间的关系</p></blockquote><ul><li>消息（message）</li></ul><a id="more"></a><h2 id="完整的通信图例子"><a href="#完整的通信图例子" class="headerlink" title="完整的通信图例子"></a>完整的通信图例子</h2><p><img src="https://i.loli.net/2020/02/01/gc7X8V9qkzBKDEL.png" alt></p><ol><li><p>技术员张三创建了一个工具</p></li><li><p>技术员张三使用了这个工具</p><p>2.1 工具检查了A103号锅炉</p><p>2.2 工具维修了A103号锅炉</p></li><li><p>技术员张三销毁了这个工具</p></li></ol><hr><blockquote><blockquote id="fn_ 1"><sup> 1</sup>. <a href="http://coursehome.zhihuishu.com/courseHome/2049439#teachTeam" target="_blank" rel="noopener">http://coursehome.zhihuishu.com/courseHome/2049439#teachTeam</a><a href="#reffn_ 1" title="Jump back to footnote [ 1] in the text."> &#8617;</a></blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://images.pexels.com/photos/417054/pexels-photo-417054.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;dpr=2&amp;amp;w=500&quot; alt&gt;&lt;/p&gt;
&lt;font color=&quot;#407600&quot;&gt;【面向对象分析UML建模工具全部文章】&lt;/font&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E7%94%A8%E4%BE%8B%E5%9B%BE/&quot;&gt;UML建模工具(1)——用例图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E6%B4%BB%E5%8A%A8%E5%9B%BE/&quot;&gt;UML建模工具(2)——活动图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E7%B1%BB%E5%9B%BE/&quot;&gt;UML建模工具(3)——类图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E9%A1%BA%E5%BA%8F%E5%9B%BE/&quot;&gt;UML建模工具(4)——顺序图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E9%80%9A%E4%BF%A1%E5%9B%BE/&quot;&gt;UML建模工具(5)——通信图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E7%8A%B6%E6%80%81%E5%9B%BE/&quot;&gt;UML建模工具(6)——状态图&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;UML建模工具——通信图&quot;&gt;&lt;a href=&quot;#UML建模工具——通信图&quot; class=&quot;headerlink&quot; title=&quot;UML建模工具——通信图&quot;&gt;&lt;/a&gt;UML建模工具——通信图&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;图：旧金山湾，黑夜中的金门大桥（Golden Gate Bridge）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;通信图（Communication diagram）和顺序图都属于UML交互图，与顺序图本质上是一样的，可以互换&lt;/p&gt;
&lt;p&gt;但二者建模的角度不同&lt;sup&gt;&lt;a href=&quot;#fn_ 1&quot; id=&quot;reffn_ 1&quot;&gt; 1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=&quot;red&quot;&gt;通信图 强调随着时间的推移，各对象是如何交互的&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;red&quot;&gt;通信图 强调对象之间的结构关系&lt;/font&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;通信图的组成元素&quot;&gt;&lt;a href=&quot;#通信图的组成元素&quot; class=&quot;headerlink&quot; title=&quot;通信图的组成元素&quot;&gt;&lt;/a&gt;通信图的组成元素&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;对象（object）&lt;/li&gt;
&lt;li&gt;链接（link）&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;注意虽然链接和关联的图形都是一条实线，但是此处的链接是对象之间的关系，而关联是类之间的关系&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;消息（message）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="面向对象" scheme="https://G-SS-Hacker.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="软件工程" scheme="https://G-SS-Hacker.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="UML" scheme="https://G-SS-Hacker.github.io/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>UML顺序图</title>
    <link href="https://g-ss-hacker.github.io/UML%E9%A1%BA%E5%BA%8F%E5%9B%BE/"/>
    <id>https://g-ss-hacker.github.io/UML%E9%A1%BA%E5%BA%8F%E5%9B%BE/</id>
    <published>2020-02-01T02:33:40.000Z</published>
    <updated>2020-02-05T02:49:55.348Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.pexels.com/photos/208589/pexels-photo-208589.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=2&amp;h=750&amp;w=1260" alt></p><font color="#407600">【面向对象分析UML建模工具全部文章】</font><ul><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E7%94%A8%E4%BE%8B%E5%9B%BE/">UML建模工具(1)——用例图</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E6%B4%BB%E5%8A%A8%E5%9B%BE/">UML建模工具(2)——活动图</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E7%B1%BB%E5%9B%BE/">UML建模工具(3)——类图</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E9%A1%BA%E5%BA%8F%E5%9B%BE/">UML建模工具(4)——顺序图</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E9%80%9A%E4%BF%A1%E5%9B%BE/">UML建模工具(5)——通信图</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E7%8A%B6%E6%80%81%E5%9B%BE/">UML建模工具(6)——状态图</a></li></ul><h1 id="UML建模工具——顺序图"><a href="#UML建模工具——顺序图" class="headerlink" title="UML建模工具——顺序图"></a>UML建模工具——顺序图</h1><blockquote><p>图：旧金山湾区，晚霞下的泛美金字塔（Transamerica Pyramid）</p></blockquote><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><p></p><blockquote><p>顺序图和通信图都属于UML交互图</p><p>顺序图（Sequence）是场景（Scenario）的图形化表示，描述了以时间顺序组织的<strong>对象</strong>之间的交互活动</p></blockquote><h2 id="完整的UML顺序图例子"><a href="#完整的UML顺序图例子" class="headerlink" title="完整的UML顺序图例子"></a>完整的UML顺序图例子</h2><p><img src="https://i.loli.net/2020/01/31/lanCLPDjYKHqd9t.png" alt></p><h2 id="基本建模元素"><a href="#基本建模元素" class="headerlink" title="基本建模元素"></a>基本建模元素</h2><ul><li>对象</li><li>对象生命线</li><li>控制焦点</li><li>消息：调用消息、返回消息、异步消息、自关联消息</li><li>对象销毁</li><li>结构化控制</li></ul><a id="more"></a><p><img src="https://i.loli.net/2020/01/31/AgkLjs9dYD6HCyn.png" alt></p><p><img src="https://i.loli.net/2020/01/31/UQL236c7RsKi5St.png" alt></p><h2 id="同步消息与异步消息"><a href="#同步消息与异步消息" class="headerlink" title="同步消息与异步消息"></a>同步消息与异步消息</h2><h3 id="同步消息"><a href="#同步消息" class="headerlink" title="同步消息"></a>同步消息</h3><blockquote><p>发送方向接收方发送消息，接收方接收此消息并回复发送方。发送者在收到接收者的回复之前不会发送另一条消息。</p></blockquote><p>如：老师想张三问了一个问题，张三必须当场给予回复，老师才会问下一个同学问题。</p><h3 id="异步消息"><a href="#异步消息" class="headerlink" title="异步消息"></a>异步消息</h3><blockquote><p>发送方向接收方发送消息，发送者在收到接收者的回复之前可以进行其他活动。</p></blockquote><p>如：老师给张三布置了一个问题，让张三课后思考一下如何解决，然后问其他同学问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://images.pexels.com/photos/208589/pexels-photo-208589.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;dpr=2&amp;amp;h=750&amp;amp;w=1260&quot; alt&gt;&lt;/p&gt;
&lt;font color=&quot;#407600&quot;&gt;【面向对象分析UML建模工具全部文章】&lt;/font&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E7%94%A8%E4%BE%8B%E5%9B%BE/&quot;&gt;UML建模工具(1)——用例图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E6%B4%BB%E5%8A%A8%E5%9B%BE/&quot;&gt;UML建模工具(2)——活动图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E7%B1%BB%E5%9B%BE/&quot;&gt;UML建模工具(3)——类图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E9%A1%BA%E5%BA%8F%E5%9B%BE/&quot;&gt;UML建模工具(4)——顺序图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E9%80%9A%E4%BF%A1%E5%9B%BE/&quot;&gt;UML建模工具(5)——通信图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E7%8A%B6%E6%80%81%E5%9B%BE/&quot;&gt;UML建模工具(6)——状态图&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;UML建模工具——顺序图&quot;&gt;&lt;a href=&quot;#UML建模工具——顺序图&quot; class=&quot;headerlink&quot; title=&quot;UML建模工具——顺序图&quot;&gt;&lt;/a&gt;UML建模工具——顺序图&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;图：旧金山湾区，晚霞下的泛美金字塔（Transamerica Pyramid）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;顺序图和通信图都属于UML交互图&lt;/p&gt;
&lt;p&gt;顺序图（Sequence）是场景（Scenario）的图形化表示，描述了以时间顺序组织的&lt;strong&gt;对象&lt;/strong&gt;之间的交互活动&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;完整的UML顺序图例子&quot;&gt;&lt;a href=&quot;#完整的UML顺序图例子&quot; class=&quot;headerlink&quot; title=&quot;完整的UML顺序图例子&quot;&gt;&lt;/a&gt;完整的UML顺序图例子&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/01/31/lanCLPDjYKHqd9t.png&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;基本建模元素&quot;&gt;&lt;a href=&quot;#基本建模元素&quot; class=&quot;headerlink&quot; title=&quot;基本建模元素&quot;&gt;&lt;/a&gt;基本建模元素&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;对象&lt;/li&gt;
&lt;li&gt;对象生命线&lt;/li&gt;
&lt;li&gt;控制焦点&lt;/li&gt;
&lt;li&gt;消息：调用消息、返回消息、异步消息、自关联消息&lt;/li&gt;
&lt;li&gt;对象销毁&lt;/li&gt;
&lt;li&gt;结构化控制&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="面向对象" scheme="https://G-SS-Hacker.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="软件工程" scheme="https://G-SS-Hacker.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="UML" scheme="https://G-SS-Hacker.github.io/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>UML类图</title>
    <link href="https://g-ss-hacker.github.io/UML%E7%B1%BB%E5%9B%BE/"/>
    <id>https://g-ss-hacker.github.io/UML%E7%B1%BB%E5%9B%BE/</id>
    <published>2020-01-31T01:58:03.000Z</published>
    <updated>2020-02-07T06:33:33.324Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1580395950609&amp;di=f6e13ac0c889517e41f2d4bbdbf4e3c1&amp;imgtype=0&amp;src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201311%2F02%2F20131102140834_Rnsec.jpeg" alt></p><font color="#407600">【面向对象分析UML建模工具全部文章】</font><ul><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E7%94%A8%E4%BE%8B%E5%9B%BE/">UML建模工具(1)——用例图</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E6%B4%BB%E5%8A%A8%E5%9B%BE/">UML建模工具(2)——活动图</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E7%B1%BB%E5%9B%BE/">UML建模工具(3)——类图</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E9%A1%BA%E5%BA%8F%E5%9B%BE/">UML建模工具(4)——顺序图</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E9%80%9A%E4%BF%A1%E5%9B%BE/">UML建模工具(5)——通信图</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E7%8A%B6%E6%80%81%E5%9B%BE/">UML建模工具(6)——状态图</a></li></ul><h1 id="UML建模工具——类图"><a href="#UML建模工具——类图" class="headerlink" title="UML建模工具——类图"></a>UML建模工具——类图</h1><blockquote><p>图：巴尔的摩（Baltimore）</p></blockquote><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><p></p><font color="orange">本文部分内容（已用上标[1]标注）演绎自：https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html</font><font color="orange">© Copyright 2014, Colin http://blog.me115.com</font><blockquote><p>用例图和活动图用于需求分析，当需求明确之后，则需要用类图进行设计。</p></blockquote><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><h3 id="什么是类（Class）？"><a href="#什么是类（Class）？" class="headerlink" title="什么是类（Class）？"></a>什么是类（Class）？</h3><blockquote><p>具有相同属性、方法的一组对象的描述符</p></blockquote><h3 id="什么是对象（Object）？"><a href="#什么是对象（Object）？" class="headerlink" title="什么是对象（Object）？"></a>什么是对象（Object）？</h3><blockquote><p>对象是类的实例</p></blockquote><h3 id="什么是类图（Class-diagram）？"><a href="#什么是类图（Class-diagram）？" class="headerlink" title="什么是类图（Class diagram）？"></a>什么是类图（Class diagram）？</h3><blockquote><p>把类相关的元素画在一起，即为类图</p></blockquote><font color="grey">（玄之又玄，众妙之门）</font><h2 id="完整的类图例子-1"><a href="#完整的类图例子-1" class="headerlink" title="完整的类图例子 1"></a>完整的类图例子<sup><a href="#fn_ 1" id="reffn_ 1"> 1</a></sup></h2><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_class_struct.jpg" alt></p><ul><li>车的类图结构为<code>&lt;&lt;abstract&gt;&gt;</code>，表示车是一个抽象类；</li><li>它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示；</li><li>小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示；</li><li>小汽车与发动机之间是组合关系，使用带实心箭头的实线表示；</li><li>学生与班级之间是聚合关系，使用带空心箭头的实线表示；</li><li>学生与身份证之间为关联关系，使用一根实线表示；</li><li>学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示；</li></ul><a id="more"></a><h2 id="类图中的元素"><a href="#类图中的元素" class="headerlink" title="类图中的元素"></a>类图中的元素</h2><ul><li>类</li><li>接口</li><li>协作</li><li>类之间的关系</li></ul><div class="table-container"><table><thead><tr><th>关系类型</th><th>说明</th><th>表示符号</th></tr></thead><tbody><tr><td>依赖（Dependency）</td><td>独立事物发生变化会影响依赖事物</td><td><img src="https://i.loli.net/2020/01/30/4Hti1muvxPNZM3p.png" alt></td></tr><tr><td>关联（Association）</td><td>整体与部分关系</td><td><img src="https://i.loli.net/2020/01/29/Kztkm5aJZRAPErp.png" alt></td></tr><tr><td>泛化（Generalization）</td><td>特殊/一般关系</td><td><img src="https://i.loli.net/2020/01/29/fxqJKuU3DnMCVv1.png" alt></td></tr><tr><td>实现（Realization）</td><td>实现表示一个class类实现interface接口（可以是多个）的功能</td><td><img src="https://i.loli.net/2020/01/30/j7b49S3OUmglCYX.png" alt></td></tr><tr><td>聚合（Aggregation）</td><td>A has B，B是A的一部分，但A不控制B的生命周期</td><td><img src="https://s.plantuml.com/sym03.png" alt></td></tr><tr><td>组合（Composition）</td><td>A has B，B是A的一部分，且A控制B的生命周期</td><td><img src="https://s.plantuml.com/sym01.png" alt></td></tr></tbody></table></div><h3 id="依赖（Dependency）-1"><a href="#依赖（Dependency）-1" class="headerlink" title="依赖（Dependency） 1"></a>依赖（Dependency）<sup><a href="#fn_ 1" id="reffn_ 1"> 1</a></sup></h3><p>依赖关系是用一套带箭头的虚线表示的；如下图表示A依赖于B；他描述一个对象在运行期间会用到另一个对象的关系；</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_dependency.jpg" alt="_images/uml_dependency.jpg"></p><p>与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化； 依赖关系也可能发生变化；</p><p>显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生；</p><p>注：在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方外，还是“使用”对方的方法和属性；</p><h3 id="关联（Association）-1"><a href="#关联（Association）-1" class="headerlink" title="关联（Association） 1"></a>关联（Association）<sup><a href="#fn_ 1" id="reffn_ 1"> 1</a></sup></h3><p>关联关系是用一条直线表示的；它描述不同类的对象之间的结构关系；它是一种静态关系， 通常与运行状态无关，一般由常识等因素决定的；它一般用来定义对象之间静态的、天然的结构； 所以，关联关系是一种“强关联”的关系；</p><p>比如，乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系；</p><p>关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如下图，表示A知道B，但 B不知道A；</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_association.jpg" alt="_images/uml_association.jpg"></p><p>注：在最终代码中，关联对象通常是以成员变量的形式实现的；</p><h3 id="泛化（Generalization）-1"><a href="#泛化（Generalization）-1" class="headerlink" title="泛化（Generalization） 1"></a>泛化（Generalization）<sup><a href="#fn_ 1" id="reffn_ 1"> 1</a></sup></h3><p>类的继承结构表现在UML中为：泛化(generalize)与实现(realize)：</p><p>继承关系为 is-a的关系；两个对象之间如果可以用 is-a 来表示，就是继承关系：（..是..)</p><p>eg：自行车是车、猫是动物</p><p>泛化关系用一条带空心箭头的直接表示；如下图表示（A继承自B）；</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_generalization.jpg" alt="_images/uml_generalization.jpg"></p><p>eg：汽车在现实中有实现，可用汽车定义具体的对象；汽车与SUV之间为泛化关系；</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_generalize.jpg" alt="_images/uml_generalize.jpg"></p><p>注：最终代码中，泛化关系表现为继承非抽象类；</p><h3 id="实现（Realization）-1"><a href="#实现（Realization）-1" class="headerlink" title="实现（Realization） 1"></a>实现（Realization）<sup><a href="#fn_ 1" id="reffn_ 1"> 1</a></sup></h3><p>实现关系用一条带空心箭头的虚线表示；</p><p>eg：”车”为一个抽象概念，在现实中并无法直接用来定义对象；只有指明具体的子类(汽车还是自行车)，才 可以用来定义对象（”车”这个类在C++中用抽象类表示，在JAVA中有接口这个概念，更容易理解）</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_realize.jpg" alt="_images/uml_realize.jpg"></p><p>注：最终代码中，实现关系表现为继承抽象类；</p><h3 id="聚合（Aggregation）-1"><a href="#聚合（Aggregation）-1" class="headerlink" title="聚合（Aggregation） 1"></a>聚合（Aggregation）<sup><a href="#fn_ 1" id="reffn_ 1"> 1</a></sup></h3><p>聚合关系用一条带空心菱形箭头的直线表示，如下图表示A聚合到B上，或者说B由A组成；</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_aggregation.jpg" alt="_images/uml_aggregation.jpg"></p><p>聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义；例如一个部门由多个员工组成；</p><p>与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如， 部门撤销了，人员不会消失，他们依然存在；</p><h3 id="组合（Composition）-1"><a href="#组合（Composition）-1" class="headerlink" title="组合（Composition） 1"></a>组合（Composition）<sup><a href="#fn_ 1" id="reffn_ 1"> 1</a></sup></h3><p>组合关系用一条带实心菱形箭头直线表示，如下图表示A组成B，或者B由A组成；</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_composition.jpg" alt="_images/uml_composition.jpg"></p><p>与聚合关系一样，组合关系同样表示整体由部分构成的语义；比如公司由多个部门组成；</p><p>但组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了；例如， 公司不存在了，部门也将不存在了；</p><h2 id="关联关系的修饰"><a href="#关联关系的修饰" class="headerlink" title="关联关系的修饰"></a>关联关系的修饰</h2><h3 id="名称及其方向"><a href="#名称及其方向" class="headerlink" title="名称及其方向"></a>名称及其方向</h3><p><img src="https://i.loli.net/2020/01/30/Sj8GdFpH4zf1gwP.png" alt></p><h3 id="角色及可见性"><a href="#角色及可见性" class="headerlink" title="角色及可见性"></a>角色及可见性</h3><blockquote><p>在关联的每一端，表明相连的类在该关联关系中的作用</p></blockquote><p><img src="https://i.loli.net/2020/01/30/v96Lc3Rtkmq2nw4.png" alt></p><h3 id="多重性（Multiplicity）"><a href="#多重性（Multiplicity）" class="headerlink" title="多重性（Multiplicity）"></a>多重性（Multiplicity）</h3><div class="table-container"><table><thead><tr><th>修饰（Adornment）</th><th>语义（Semantics）</th></tr></thead><tbody><tr><td><code>0..1</code></td><td><code>0</code>or<code>1</code></td></tr><tr><td><code>1</code></td><td>Exactly <code>1</code></td></tr><tr><td><code>0..*</code></td><td><code>0</code> or more</td></tr><tr><td><code>1..*</code></td><td><code>1</code> or more</td></tr><tr><td><code>m..n</code></td><td><code>m</code> to <code>n</code></td></tr><tr><td><code>m..n, p..q</code></td><td><code>m</code> to <code>n</code> or <code>p</code> to <code>q</code></td></tr><tr><td><code>*</code></td><td><code>0</code> or more</td></tr></tbody></table></div><p><img src="https://i.loli.net/2020/02/07/QkcFx2zNuwHagT5.png" alt></p><p>名词说明：</p><ul><li><code>Fighter Jet</code>：战斗机</li><li><code>Pilot</code>：飞行员</li><li><code>Missile</code>：导弹</li><li><code>Engine</code>：发动机</li></ul><p>在图中：</p><ol><li>一架战斗机有一个飞行员</li><li>一架战斗机能携带零或多枚导弹</li><li>一架战斗机有两台发动机</li></ol><hr><blockquote id="fn_ 1"><sup> 1</sup>. Reference and lots of thanks：<a href="https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html" target="_blank" rel="noopener">https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html</a><a href="#reffn_ 1" title="Jump back to footnote [ 1] in the text."> &#8617;</a></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1580395950609&amp;amp;di=f6e13ac0c889517e41f2d4bbdbf4e3c1&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201311%2F02%2F20131102140834_Rnsec.jpeg&quot; alt&gt;&lt;/p&gt;
&lt;font color=&quot;#407600&quot;&gt;【面向对象分析UML建模工具全部文章】&lt;/font&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E7%94%A8%E4%BE%8B%E5%9B%BE/&quot;&gt;UML建模工具(1)——用例图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E6%B4%BB%E5%8A%A8%E5%9B%BE/&quot;&gt;UML建模工具(2)——活动图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E7%B1%BB%E5%9B%BE/&quot;&gt;UML建模工具(3)——类图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E9%A1%BA%E5%BA%8F%E5%9B%BE/&quot;&gt;UML建模工具(4)——顺序图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E9%80%9A%E4%BF%A1%E5%9B%BE/&quot;&gt;UML建模工具(5)——通信图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E7%8A%B6%E6%80%81%E5%9B%BE/&quot;&gt;UML建模工具(6)——状态图&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;UML建模工具——类图&quot;&gt;&lt;a href=&quot;#UML建模工具——类图&quot; class=&quot;headerlink&quot; title=&quot;UML建模工具——类图&quot;&gt;&lt;/a&gt;UML建模工具——类图&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;图：巴尔的摩（Baltimore）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;font color=&quot;orange&quot;&gt;本文部分内容（已用上标[1]标注）演绎自：https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html&lt;/font&gt;

&lt;font color=&quot;orange&quot;&gt;© Copyright 2014, Colin http://blog.me115.com&lt;/font&gt;

&lt;blockquote&gt;
&lt;p&gt;用例图和活动图用于需求分析，当需求明确之后，则需要用类图进行设计。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;回顾&quot;&gt;&lt;a href=&quot;#回顾&quot; class=&quot;headerlink&quot; title=&quot;回顾&quot;&gt;&lt;/a&gt;回顾&lt;/h2&gt;&lt;h3 id=&quot;什么是类（Class）？&quot;&gt;&lt;a href=&quot;#什么是类（Class）？&quot; class=&quot;headerlink&quot; title=&quot;什么是类（Class）？&quot;&gt;&lt;/a&gt;什么是类（Class）？&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;具有相同属性、方法的一组对象的描述符&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;什么是对象（Object）？&quot;&gt;&lt;a href=&quot;#什么是对象（Object）？&quot; class=&quot;headerlink&quot; title=&quot;什么是对象（Object）？&quot;&gt;&lt;/a&gt;什么是对象（Object）？&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;对象是类的实例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;什么是类图（Class-diagram）？&quot;&gt;&lt;a href=&quot;#什么是类图（Class-diagram）？&quot; class=&quot;headerlink&quot; title=&quot;什么是类图（Class diagram）？&quot;&gt;&lt;/a&gt;什么是类图（Class diagram）？&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;把类相关的元素画在一起，即为类图&lt;/p&gt;
&lt;/blockquote&gt;
&lt;font color=&quot;grey&quot;&gt;（玄之又玄，众妙之门）&lt;/font&gt;



&lt;h2 id=&quot;完整的类图例子-1&quot;&gt;&lt;a href=&quot;#完整的类图例子-1&quot; class=&quot;headerlink&quot; title=&quot;完整的类图例子 1&quot;&gt;&lt;/a&gt;完整的类图例子&lt;sup&gt;&lt;a href=&quot;#fn_ 1&quot; id=&quot;reffn_ 1&quot;&gt; 1&lt;/a&gt;&lt;/sup&gt;&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_class_struct.jpg&quot; alt&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;车的类图结构为&lt;code&gt;&amp;lt;&amp;lt;abstract&amp;gt;&amp;gt;&lt;/code&gt;，表示车是一个抽象类；&lt;/li&gt;
&lt;li&gt;它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示；&lt;/li&gt;
&lt;li&gt;小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示；&lt;/li&gt;
&lt;li&gt;小汽车与发动机之间是组合关系，使用带实心箭头的实线表示；&lt;/li&gt;
&lt;li&gt;学生与班级之间是聚合关系，使用带空心箭头的实线表示；&lt;/li&gt;
&lt;li&gt;学生与身份证之间为关联关系，使用一根实线表示；&lt;/li&gt;
&lt;li&gt;学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="面向对象" scheme="https://G-SS-Hacker.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="软件工程" scheme="https://G-SS-Hacker.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="UML" scheme="https://G-SS-Hacker.github.io/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>UML活动图</title>
    <link href="https://g-ss-hacker.github.io/UML%E6%B4%BB%E5%8A%A8%E5%9B%BE/"/>
    <id>https://g-ss-hacker.github.io/UML%E6%B4%BB%E5%8A%A8%E5%9B%BE/</id>
    <published>2020-01-30T02:28:34.000Z</published>
    <updated>2020-02-04T03:26:13.617Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2020/01/30/QTqVWaAG6pmMPtY.jpg" alt></p><font color="#407600">【面向对象分析UML建模工具全部文章】</font><ul><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E7%94%A8%E4%BE%8B%E5%9B%BE/">UML建模工具(1)——用例图</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E6%B4%BB%E5%8A%A8%E5%9B%BE/">UML建模工具(2)——活动图</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E7%B1%BB%E5%9B%BE/">UML建模工具(3)——类图</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E9%A1%BA%E5%BA%8F%E5%9B%BE/">UML建模工具(4)——顺序图</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E9%80%9A%E4%BF%A1%E5%9B%BE/">UML建模工具(5)——通信图</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E7%8A%B6%E6%80%81%E5%9B%BE/">UML建模工具(6)——状态图</a></li></ul><h1 id="UML建模工具——活动图"><a href="#UML建模工具——活动图" class="headerlink" title="UML建模工具——活动图"></a>UML建模工具——活动图</h1><blockquote><p>图：香港九龙(Kowloon, Hong Kong)</p></blockquote><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><p></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>活动图（Activity Diagram）是一种特殊的状态图，它展现了在系统内从一个活动到另一个活动的流程</p></blockquote><p>活动图与用例图互为补充，主要用于需求分析阶段</p><h2 id="基本建模元素"><a href="#基本建模元素" class="headerlink" title="基本建模元素"></a>基本建模元素</h2><ul><li>开始（Initial Node）、结束（Final Node）、对象（Objects）</li><li>动作（Actions）</li><li>分支（Decision Nodes）</li><li>分岔和汇合（Forking and Joining）</li><li>泳道（Partition）</li></ul><h3 id="开始、结束、对象"><a href="#开始、结束、对象" class="headerlink" title="开始、结束、对象"></a>开始、结束、对象</h3><p><img src="https://i.loli.net/2020/01/30/feKLcOm78I2sHq6.png" alt></p><h3 id="动作-活动节点"><a href="#动作-活动节点" class="headerlink" title="动作/活动节点"></a>动作/活动节点</h3><blockquote><p>一个活动节点是一个过程中进行的非原子的执行单元，活动的执行最终延伸为一些独立动作的（Action）的执行</p></blockquote><p><img src="https://i.loli.net/2020/01/30/nMR7g8bOk4JIVCw.png" alt></p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><blockquote><p>分支相当于编程语言中的<code>if</code>语句，可以有一个<strong>进入流</strong>和多个<strong>离去流</strong></p></blockquote><p><img src="https://i.loli.net/2020/01/30/wJICE1RnY63gjzv.png" alt></p><h3 id="分岔和汇合"><a href="#分岔和汇合" class="headerlink" title="分岔和汇合"></a>分岔和汇合</h3><blockquote><p>分差表示把一个单独的控制流分成两个或多个并发的控制流。汇合表示两个或多个并发控制流的同步发生，一个汇合可以有两个或多个进入转移和一个输出转移。用同步棒来说明并行控制流的分岔和汇合。</p></blockquote><p><img src="https://i.loli.net/2020/01/30/l36JHnw8mhaVuE2.png" alt></p><h3 id="泳道"><a href="#泳道" class="headerlink" title="泳道"></a>泳道</h3><blockquote><p>将一个活动图中的活动分组，每一组表示一个特定的类别、人或部门，他们负责组内的活动，每个组被称为一个泳道，用一条垂直的实线把它们分开。每个活动严格属于每一个泳道，转移（流）和同步棒（分差与汇合）可以跨越泳道。</p></blockquote><p><img src="https://i.loli.net/2020/01/30/GtJph7T481s3VKn.png" alt></p><a id="more"></a><h2 id="完整的活动图例子"><a href="#完整的活动图例子" class="headerlink" title="完整的活动图例子"></a>完整的活动图例子</h2><h3 id="电商平台"><a href="#电商平台" class="headerlink" title="电商平台"></a>电商平台</h3><p><img src="https://i.loli.net/2020/01/30/NTCoV7Zq2LzEBIQ.png" alt></p><h3 id="货物交易"><a href="#货物交易" class="headerlink" title="货物交易"></a>货物交易</h3><p><img src="https://i.loli.net/2020/01/29/kTVaWsJpgLmDdQ3.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/01/30/QTqVWaAG6pmMPtY.jpg&quot; alt&gt;&lt;/p&gt;
&lt;font color=&quot;#407600&quot;&gt;【面向对象分析UML建模工具全部文章】&lt;/font&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E7%94%A8%E4%BE%8B%E5%9B%BE/&quot;&gt;UML建模工具(1)——用例图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E6%B4%BB%E5%8A%A8%E5%9B%BE/&quot;&gt;UML建模工具(2)——活动图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E7%B1%BB%E5%9B%BE/&quot;&gt;UML建模工具(3)——类图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E9%A1%BA%E5%BA%8F%E5%9B%BE/&quot;&gt;UML建模工具(4)——顺序图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E9%80%9A%E4%BF%A1%E5%9B%BE/&quot;&gt;UML建模工具(5)——通信图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E7%8A%B6%E6%80%81%E5%9B%BE/&quot;&gt;UML建模工具(6)——状态图&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;UML建模工具——活动图&quot;&gt;&lt;a href=&quot;#UML建模工具——活动图&quot; class=&quot;headerlink&quot; title=&quot;UML建模工具——活动图&quot;&gt;&lt;/a&gt;UML建模工具——活动图&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;图：香港九龙(Kowloon, Hong Kong)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;活动图（Activity Diagram）是一种特殊的状态图，它展现了在系统内从一个活动到另一个活动的流程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;活动图与用例图互为补充，主要用于需求分析阶段&lt;/p&gt;
&lt;h2 id=&quot;基本建模元素&quot;&gt;&lt;a href=&quot;#基本建模元素&quot; class=&quot;headerlink&quot; title=&quot;基本建模元素&quot;&gt;&lt;/a&gt;基本建模元素&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;开始（Initial Node）、结束（Final Node）、对象（Objects）&lt;/li&gt;
&lt;li&gt;动作（Actions）&lt;/li&gt;
&lt;li&gt;分支（Decision Nodes）&lt;/li&gt;
&lt;li&gt;分岔和汇合（Forking and Joining）&lt;/li&gt;
&lt;li&gt;泳道（Partition）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;开始、结束、对象&quot;&gt;&lt;a href=&quot;#开始、结束、对象&quot; class=&quot;headerlink&quot; title=&quot;开始、结束、对象&quot;&gt;&lt;/a&gt;开始、结束、对象&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/01/30/feKLcOm78I2sHq6.png&quot; alt&gt;&lt;/p&gt;
&lt;h3 id=&quot;动作-活动节点&quot;&gt;&lt;a href=&quot;#动作-活动节点&quot; class=&quot;headerlink&quot; title=&quot;动作/活动节点&quot;&gt;&lt;/a&gt;动作/活动节点&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;一个活动节点是一个过程中进行的非原子的执行单元，活动的执行最终延伸为一些独立动作的（Action）的执行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/01/30/nMR7g8bOk4JIVCw.png&quot; alt&gt;&lt;/p&gt;
&lt;h3 id=&quot;分支&quot;&gt;&lt;a href=&quot;#分支&quot; class=&quot;headerlink&quot; title=&quot;分支&quot;&gt;&lt;/a&gt;分支&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;分支相当于编程语言中的&lt;code&gt;if&lt;/code&gt;语句，可以有一个&lt;strong&gt;进入流&lt;/strong&gt;和多个&lt;strong&gt;离去流&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/01/30/wJICE1RnY63gjzv.png&quot; alt&gt;&lt;/p&gt;
&lt;h3 id=&quot;分岔和汇合&quot;&gt;&lt;a href=&quot;#分岔和汇合&quot; class=&quot;headerlink&quot; title=&quot;分岔和汇合&quot;&gt;&lt;/a&gt;分岔和汇合&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;分差表示把一个单独的控制流分成两个或多个并发的控制流。汇合表示两个或多个并发控制流的同步发生，一个汇合可以有两个或多个进入转移和一个输出转移。用同步棒来说明并行控制流的分岔和汇合。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/01/30/l36JHnw8mhaVuE2.png&quot; alt&gt;&lt;/p&gt;
&lt;h3 id=&quot;泳道&quot;&gt;&lt;a href=&quot;#泳道&quot; class=&quot;headerlink&quot; title=&quot;泳道&quot;&gt;&lt;/a&gt;泳道&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;将一个活动图中的活动分组，每一组表示一个特定的类别、人或部门，他们负责组内的活动，每个组被称为一个泳道，用一条垂直的实线把它们分开。每个活动严格属于每一个泳道，转移（流）和同步棒（分差与汇合）可以跨越泳道。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/01/30/GtJph7T481s3VKn.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="面向对象" scheme="https://G-SS-Hacker.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="软件工程" scheme="https://G-SS-Hacker.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="UML" scheme="https://G-SS-Hacker.github.io/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>UML用例图</title>
    <link href="https://g-ss-hacker.github.io/UML%E7%94%A8%E4%BE%8B%E5%9B%BE/"/>
    <id>https://g-ss-hacker.github.io/UML%E7%94%A8%E4%BE%8B%E5%9B%BE/</id>
    <published>2020-01-29T07:18:11.000Z</published>
    <updated>2020-02-04T03:25:59.672Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1580292501613&amp;di=8e0a699a6038f2b93f35402fd489905e&amp;imgtype=0&amp;src=http%3A%2F%2Fimg8.9158.com%2F200909%2F04%2F13%2F13%2F200909049381645.jpg" alt></p><font color="#407600">【面向对象分析UML建模工具全部文章】</font><ul><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E7%94%A8%E4%BE%8B%E5%9B%BE/">UML建模工具(1)——用例图</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E6%B4%BB%E5%8A%A8%E5%9B%BE/">UML建模工具(2)——活动图</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E7%B1%BB%E5%9B%BE/">UML建模工具(3)——类图</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E9%A1%BA%E5%BA%8F%E5%9B%BE/">UML建模工具(4)——顺序图</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E9%80%9A%E4%BF%A1%E5%9B%BE/">UML建模工具(5)——通信图</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E7%8A%B6%E6%80%81%E5%9B%BE/">UML建模工具(6)——状态图</a></li></ul><h1 id="UML建模工具——用例图"><a href="#UML建模工具——用例图" class="headerlink" title="UML建模工具——用例图"></a>UML建模工具——用例图</h1><blockquote><p>图：歼15双机编队</p></blockquote><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><br><img src="https://i.loli.net/2020/01/29/gORWzAFpmDh5LBU.png" alt><p></p><ul><li>系统 System</li><li>参与者 Actors</li><li>用例 Use Cases</li><li>关系 Relationships</li></ul><h2 id="系统（System）"><a href="#系统（System）" class="headerlink" title="系统（System）"></a>系统（System）</h2><blockquote><p>一个系统就是你开发的所有东西，可以是网站、软件组件、业务流程、应用程序、etc.</p></blockquote><p>用一个矩形代表一个系统，然后将系统名称放在顶部。矩形用于定义系统的范围，矩形内的所有内容都在系统内发生，矩形外的所有内容都不会在系统外发生。</p><p><img src="https://i.loli.net/2020/01/29/io6EJzfYRcytlVh.png" alt></p><p>如图所示，灰色区域即为飞行控制系统，而副驾驶、机长都是系统外内容，属于参与者。</p><h2 id="参与者（Actor）"><a href="#参与者（Actor）" class="headerlink" title="参与者（Actor）"></a>参与者（Actor）</h2><blockquote><p>使用我们的系统（与系统交互）实现目标的某人或某物，可以是<strong>一个人、一个组织、另一个系统或一个外部设备</strong></p></blockquote><p>参与者的普通图形用火柴人表示；当另一个系统充当参与者时，参与者的图形用矩形表示。</p><p><img src="https://i.loli.net/2020/01/29/CyH3Gt5FvwiAd9U.png" alt></p><p>在软件工程中，参与者告诉我们我们这个系统应该具有的功能。不同的参与者希望获得不同的功能，我们需要找到重要的参与者，认真调查他们的需求，并根据不同参与者的需求完善系统。</p><h2 id="用例（Use-Case）"><a href="#用例（Use-Case）" class="headerlink" title="用例（Use Case）"></a>用例（Use Case）</h2><blockquote><p>系统为响应参与者引发的一个事件而执行的一系列的处理/动作，而这些处理应该为参与者产生一种有价值的结果</p></blockquote><p>用椭圆形容一个用例，代表要系统做的一个任务。</p><p><img src="https://i.loli.net/2020/01/29/JPxRlemypEr7zKT.png" alt></p><h2 id="关系（Relationship）"><a href="#关系（Relationship）" class="headerlink" title="关系（Relationship）"></a>关系（Relationship）</h2><p>用例图中涉及的关系有：<strong>关联</strong>、<strong>泛化</strong>、<strong>包含</strong>、<strong>扩展</strong></p><div class="table-container"><table><thead><tr><th>关系类型</th><th>说明</th><th>表示符号</th></tr></thead><tbody><tr><td>关联（Association）</td><td>参与者与用例之间的关系</td><td><img src="https://i.loli.net/2020/01/29/Kztkm5aJZRAPErp.png" alt></td></tr><tr><td>泛化（Inheritance）</td><td>参与者之间或用例之间的关系</td><td><img src="https://i.loli.net/2020/01/29/fxqJKuU3DnMCVv1.png" alt></td></tr><tr><td>包含（Include）</td><td>用例之间的关系</td><td><img src="https://i.loli.net/2020/01/29/RJMG6S9aVZ3Hoq5.png" alt></td></tr><tr><td>扩展（Extend）</td><td>用例之间的关系</td><td><img src="https://i.loli.net/2020/01/29/FyOQcZR9EnLUoNW.png" alt></td></tr></tbody></table></div><a id="more"></a><h3 id="关联（Association）"><a href="#关联（Association）" class="headerlink" title="关联（Association）"></a>关联（Association）</h3><blockquote><p>关联关系，用实线表示。表示参与者与用例之间的通信，任何一方都可以发送和接受信息。</p></blockquote><p><img src="http://www.plantuml.com/plantuml/png/SoWkIImgAStDuSf9JIjHACbNACfCpoXHICaiIaqkoSpFut9CBialKj3LLT08BKvLS4uiJjNaSaZDIm7g0G00" alt></p><p>参与者<code>Actor</code>与用例<code>Use Case</code>相关联，参与者既要向用例发送信息，也要就收用例反馈的信息。</p><h3 id="泛化（Inheritance）"><a href="#泛化（Inheritance）" class="headerlink" title="泛化（Inheritance）"></a>泛化（Inheritance）</h3><blockquote><p>泛化关系，实现+空心箭头，从子类指向父类。</p></blockquote><p><img src="http://www.plantuml.com/plantuml/png/SoWkIImgAStDuR8ABKujibAmgT7LLR0AymomGXLnBqqjBh7YujBmoKzNoCpJX0X3UGf9bGgfkOcPEPguvGC35HAJyqlpIZIv75BpKe1M0W00" alt></p><font color="grey">（account拼错了）</font><p>如上图所示，用户<code>User</code>可以被细分为<code>VIP</code>用户和游客<code>Guest</code>；登录<code>Log in</code>也可以被细分为邮箱登录<code>Log in by email</code>和QQ登录<code>Log in by QQ account</code>。</p><h3 id="包含（Include）"><a href="#包含（Include）" class="headerlink" title="包含（Include）"></a>包含（Include）</h3><blockquote><p>包含关系，把一个较复杂用例所表示的功能分解成较小的步骤，是上一个用例执行过程中必不可少的。箭头指向包含的子用例。</p></blockquote><p><img src="https://i.loli.net/2020/01/29/EDBxno8OdYuZaRg.png" alt></p><p>如上图所示，系统维护<code>System Maintenance</code>的工作包含了添加<code>Add</code>、删除<code>Remove</code>和修正<code>Modify</code>。</p><h3 id="扩展（Extend）"><a href="#扩展（Extend）" class="headerlink" title="扩展（Extend）"></a>扩展（Extend）</h3><blockquote><p>扩展关系，用例功能的延伸，相当于为基础用例提供一个附加功能，不是必不可少的。箭头指向被扩展的父用例。</p></blockquote><p><img src="https://i.loli.net/2020/01/29/p5rmtwzIgYKayq6.png" alt></p><p>如上图所示，打喷嚏<code>Sneeze</code>必然包含闭眼<code>Close Eyes</code>的过程，因此<code>Sneeze</code>和<code>Close Eyes</code>是包含关系；打完喷嚏<code>Sneeze</code>之后不一定需要道歉<code>Say Excuse Me</code>，因此<code>Sneeze</code>和<code>Say Excuse Me</code>是扩展关系。</p><h2 id="完整的用例图例子"><a href="#完整的用例图例子" class="headerlink" title="完整的用例图例子"></a>完整的用例图例子</h2><p><img src="https://i.loli.net/2020/01/29/X6iBYlnecLb3Vax.png" alt></p><p>这是一个<code>Bank app</code>系统，参与者包括用户<code>Customer</code>和银行数据库<code>Bank</code>，用户可以进行的操作包括登录<code>Log in</code>、验证余额<code>Check Balance</code>、转账<code>Transfer Funds</code>、支付<code>Make Payment</code>和建立档案<code>Set Up Profile</code>。</p><p>用户登录后，需要验证密码<code>Verify Password</code>，因此<code>Log in</code>和<code>Verify Password</code>是包含关系；如果用户输入密码错误，则展示错误信息<code>Display Login Error</code>，因此<code>Log in</code>和<code>Display Login Error</code>是扩展关系（用户不一定会输错密码）。</p><p>用户验证余额、转账和支付都需要银行数据库来帮助实现，因此验证余额、转账和支付和<code>Bank</code>都是关联关系。而用户进行转账和支付操作时，都必须验证用户账户资金是否足够<code>Veirify Sufficient Funds</code>，因此转账、支付和<code>Verify Sufficient Funds</code>是包含关系。</p><p>用户在支付时，可以选择使用支票支付<code>Pay from Checking</code>或余额支付<code>Pay from Savings</code>，故支票支付和余额支付与支付是泛化关系。</p><p>此处有一个带有扩展点<code>Extension Points</code>的用例：建立档案<code>Set Up Profile</code>。用例名称在上方，扩展点在下方。扩展点是扩展关系的详细叙述。这个用例表明用户可以再<code>Banking App</code>中建立自己的档案，当用户在建立他们的档案是，可以选择转移至几个不同的屏幕。如果用户感到困惑，他们可以转到档案帮助页面<code>Go to Profile Help</code>；如果用户希望了解隐私信息，他们可以转到隐私信息页面<code>Show Privacy Info</code>。还可以添加注释，以写明导致扩展的情况发生的条件。</p><hr><blockquote><p>Reference：<a href="https://www.youtube.com/watch?v=zid-MVo7M-E" target="_blank" rel="noopener">https://www.youtube.com/watch?v=zid-MVo7M-E</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1580292501613&amp;amp;di=8e0a699a6038f2b93f35402fd489905e&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fimg8.9158.com%2F200909%2F04%2F13%2F13%2F200909049381645.jpg&quot; alt&gt;&lt;/p&gt;
&lt;font color=&quot;#407600&quot;&gt;【面向对象分析UML建模工具全部文章】&lt;/font&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E7%94%A8%E4%BE%8B%E5%9B%BE/&quot;&gt;UML建模工具(1)——用例图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E6%B4%BB%E5%8A%A8%E5%9B%BE/&quot;&gt;UML建模工具(2)——活动图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E7%B1%BB%E5%9B%BE/&quot;&gt;UML建模工具(3)——类图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E9%A1%BA%E5%BA%8F%E5%9B%BE/&quot;&gt;UML建模工具(4)——顺序图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E9%80%9A%E4%BF%A1%E5%9B%BE/&quot;&gt;UML建模工具(5)——通信图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://g-ss-hacker.github.io/G-SS-Hacker.github.io/UML%E7%8A%B6%E6%80%81%E5%9B%BE/&quot;&gt;UML建模工具(6)——状态图&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;UML建模工具——用例图&quot;&gt;&lt;a href=&quot;#UML建模工具——用例图&quot; class=&quot;headerlink&quot; title=&quot;UML建模工具——用例图&quot;&gt;&lt;/a&gt;UML建模工具——用例图&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;图：歼15双机编队&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2020/01/29/gORWzAFpmDh5LBU.png&quot; alt&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统 System&lt;/li&gt;
&lt;li&gt;参与者 Actors&lt;/li&gt;
&lt;li&gt;用例 Use Cases&lt;/li&gt;
&lt;li&gt;关系 Relationships&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;系统（System）&quot;&gt;&lt;a href=&quot;#系统（System）&quot; class=&quot;headerlink&quot; title=&quot;系统（System）&quot;&gt;&lt;/a&gt;系统（System）&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;一个系统就是你开发的所有东西，可以是网站、软件组件、业务流程、应用程序、etc.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用一个矩形代表一个系统，然后将系统名称放在顶部。矩形用于定义系统的范围，矩形内的所有内容都在系统内发生，矩形外的所有内容都不会在系统外发生。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/01/29/io6EJzfYRcytlVh.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;如图所示，灰色区域即为飞行控制系统，而副驾驶、机长都是系统外内容，属于参与者。&lt;/p&gt;
&lt;h2 id=&quot;参与者（Actor）&quot;&gt;&lt;a href=&quot;#参与者（Actor）&quot; class=&quot;headerlink&quot; title=&quot;参与者（Actor）&quot;&gt;&lt;/a&gt;参与者（Actor）&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;使用我们的系统（与系统交互）实现目标的某人或某物，可以是&lt;strong&gt;一个人、一个组织、另一个系统或一个外部设备&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参与者的普通图形用火柴人表示；当另一个系统充当参与者时，参与者的图形用矩形表示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/01/29/CyH3Gt5FvwiAd9U.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;在软件工程中，参与者告诉我们我们这个系统应该具有的功能。不同的参与者希望获得不同的功能，我们需要找到重要的参与者，认真调查他们的需求，并根据不同参与者的需求完善系统。&lt;/p&gt;
&lt;h2 id=&quot;用例（Use-Case）&quot;&gt;&lt;a href=&quot;#用例（Use-Case）&quot; class=&quot;headerlink&quot; title=&quot;用例（Use Case）&quot;&gt;&lt;/a&gt;用例（Use Case）&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;系统为响应参与者引发的一个事件而执行的一系列的处理/动作，而这些处理应该为参与者产生一种有价值的结果&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用椭圆形容一个用例，代表要系统做的一个任务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/01/29/JPxRlemypEr7zKT.png&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;关系（Relationship）&quot;&gt;&lt;a href=&quot;#关系（Relationship）&quot; class=&quot;headerlink&quot; title=&quot;关系（Relationship）&quot;&gt;&lt;/a&gt;关系（Relationship）&lt;/h2&gt;&lt;p&gt;用例图中涉及的关系有：&lt;strong&gt;关联&lt;/strong&gt;、&lt;strong&gt;泛化&lt;/strong&gt;、&lt;strong&gt;包含&lt;/strong&gt;、&lt;strong&gt;扩展&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;关系类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;表示符号&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;关联（Association）&lt;/td&gt;
&lt;td&gt;参与者与用例之间的关系&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://i.loli.net/2020/01/29/Kztkm5aJZRAPErp.png&quot; alt&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;泛化（Inheritance）&lt;/td&gt;
&lt;td&gt;参与者之间或用例之间的关系&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://i.loli.net/2020/01/29/fxqJKuU3DnMCVv1.png&quot; alt&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;包含（Include）&lt;/td&gt;
&lt;td&gt;用例之间的关系&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://i.loli.net/2020/01/29/RJMG6S9aVZ3Hoq5.png&quot; alt&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;扩展（Extend）&lt;/td&gt;
&lt;td&gt;用例之间的关系&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://i.loli.net/2020/01/29/FyOQcZR9EnLUoNW.png&quot; alt&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="面向对象" scheme="https://G-SS-Hacker.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="软件工程" scheme="https://G-SS-Hacker.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="UML" scheme="https://G-SS-Hacker.github.io/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>面向对象绪论</title>
    <link href="https://g-ss-hacker.github.io/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%AA%E8%AE%BA/"/>
    <id>https://g-ss-hacker.github.io/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%AA%E8%AE%BA/</id>
    <published>2020-01-28T06:25:40.000Z</published>
    <updated>2020-01-30T02:27:59.734Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1580203723216&amp;di=8aed87a08dfaee482cb60caaaed0998a&amp;imgtype=0&amp;src=http%3A%2F%2F01.minipic.eastday.com%2F20170705%2F20170705072438_f5cc5771dd19389bacdba25fcfa1ee80_4.jpeg" alt></p><h1 id="面向对象绪论"><a href="#面向对象绪论" class="headerlink" title="面向对象绪论"></a>面向对象绪论</h1><blockquote><p>图：歼15航母降落</p></blockquote><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><p></p><h2 id="面向对象的基本概念"><a href="#面向对象的基本概念" class="headerlink" title="面向对象的基本概念"></a>面向对象的基本概念</h2><ul><li>类 Class</li><li>对象 Object</li></ul><blockquote><p>浅显理解：类是抽象的对象，对象是具体的类</p></blockquote><h2 id="概念之间的互用"><a href="#概念之间的互用" class="headerlink" title="概念之间的互用"></a>概念之间的互用</h2><ul><li>属性 Attribute == 数据 Data == 状态 State == 信息 Information</li><li>操作 Operation == 方法 Method == 行为 Behavior == 职责 Responsibility</li><li>对象 Object == 实例 Instance</li></ul><h2 id="面向对象的核心特征"><a href="#面向对象的核心特征" class="headerlink" title="面向对象的核心特征"></a>面向对象的核心特征</h2><ul><li>封装 Encapsulation</li><li>继承 Inheritance</li><li>多态 Polymorphism</li></ul><blockquote><p>封装、继承和多态被称为所谓的“面向对象三大特征”</p></blockquote><ul><li>聚合/组合 Aggregation / Composition</li><li>接口/实现 Interface / Implementation</li><li>抽象 Abstraction</li></ul><h3 id="封装-Encapsulation"><a href="#封装-Encapsulation" class="headerlink" title="封装 Encapsulation"></a>封装 Encapsulation</h3><blockquote><p>是指隐藏对象的属性和实现细节，仅对外提供公共访问方式</p></blockquote><ol><li><strong>封装什么？</strong></li></ol><ul><li>内部的、不想让其他人随意了解的信息</li><li>类的属性 Attribute</li><li>类的方法 Method</li></ul><ol><li><strong>为什么要封装？</strong></li></ol><ul><li>保护隐私</li><li>保护数据安全</li><li>隔离复杂度</li></ul><ol><li><strong>面向对象的封装有四种方式</strong></li></ol><ul><li>Public</li><li>Private</li><li>Protected</li><li>Package</li></ul><h3 id="继承-Inheritance"><a href="#继承-Inheritance" class="headerlink" title="继承 Inheritance"></a>继承 Inheritance</h3><blockquote><p>一个类从其他类获得它的状态和行为，同时还可以加上自己额外的状态和行为</p></blockquote><p>父类中的属性和方法，在子类中可以重复使用，子类就不需要再定义了，这样即可实现代码的可重用性。如以下类图例子，定义类<code>C1Dobject</code>一维物体，它有一个属性<code>x</code>对应x轴上的一个坐标，两个方法<code>getx()</code>和<code>setx(int)</code>分别表示x坐标的获取和设置。如果我们需要定义二维物体，就没有必要把x坐标重复定义。我们在类<code>C1Dobject</code>的基础上派生出子类<code>C2Dobject</code>，只需再定义属性<code>y</code>和方法<code>gety()</code>及<code>sety(int)</code>就可以完整地抽象出一个二维物体；类似地，如果我们需要定义三维物体，没有必要把x坐标、y坐标重复定义，只需再类<code>C2Dobject</code>的基础上派生出子类<code>C3Dobject</code>，再定义属性<code>z</code>和方法<code>getz()</code>及<code>setz(int)</code>即可。显而易见，继承提高了代码的可重用性，减少了创建类的工作量。</p><p><img src="http://www.plantuml.com/plantuml/png/SoWkIImgAStDuN8sTCbFoafDBb6mgT7LLN0sWdAv82o4X35CWYiv9x6uM06XiPfBeK8XCw-4Io4zjQH2GnF2BWQnWInDhbgu5YCaBPLmBPL8MYhHjHWZQQc2Qwb2qb85q-AGcfS2z180" alt></p><p>以上类图对应的<code>C++</code>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1Dobject</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getx</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setx</span><span class="params">(<span class="keyword">int</span> xPrime)</span> </span>&#123; x = xPrime; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2Dobject</span>:</span> <span class="keyword">public</span> C1Dobject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gety</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sety</span><span class="params">(<span class="keyword">int</span> yPrime)</span> </span>&#123; y = yPrime; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C3Dobject</span>:</span> <span class="keyword">public</span> C2Dobject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> z = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getz</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> z; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setz</span><span class="params">(<span class="keyword">int</span> zPrime)</span> </span>&#123; z = zPrime; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="多态-Polymorphism"><a href="#多态-Polymorphism" class="headerlink" title="多态 Polymorphism"></a>多态 Polymorphism</h3><blockquote><p>使用指向父类的指针或者引用，能够调用子类的对象</p></blockquote><p>结论：</p><ol><li>当一个类从另一个类继承而来，多态使得子类可以代替父类</li><li>消息发送方不需要知道消息接收方属于哪一个子类</li><li><font color="red">同一类族</font>的接收者可以按自己的方式处理消息</li></ol><p>如以下类图例子，定义形状<code>CShape</code>作为父类，派生出矩形<code>CRectangle</code>和三角形<code>CTriangle</code>。现在假设我们知道一个图形<code>shape</code>，希望获取它的面积，而我们并不需要知道它的具体形状（属于哪一个子类），只需要确保<code>shape</code>所属的类在<code>CShape</code>的类组下即可。图形<code>shape</code>的面积可以通过调用函数<code>area()</code>实现。</p><p><img src="http://www.plantuml.com/plantuml/png/SoWkIImgAStDuN8EpaWiI5MmgT7LLN0EIaqkISnBpqb55GufoeI8SYNd91ONAq0bgxaKoZDJIZ8KClDAk1GoKZFJCqeWxCIYr4GDJJ2xbiiXDIy5Q1C0" alt></p><p><code>C++</code>中多态的实现涉及<strong>静态多态</strong>和<strong>动态多态</strong>以及<strong>虚函数</strong>的使用，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CShape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> width, height;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CShape(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>) &#123; width = a, height = b; &#125;</span><br><span class="line"><span class="comment">//纯虚函数，具体功能在子类中实现</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">area</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CRectangle</span>:</span> <span class="keyword">public</span> CShape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//显式调用父类的构造函数</span></span><br><span class="line">CRectangle( <span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>): CShape(a, b) &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"CRectangle area calls: "</span>;</span><br><span class="line"><span class="keyword">return</span> width * height;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTriangle</span>:</span> <span class="keyword">public</span> CShape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//显式调用父类的构造函数</span></span><br><span class="line">CTriangle( <span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>): CShape(a, b) &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"CTriangle area calls: "</span>;</span><br><span class="line"><span class="keyword">return</span> width * height / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CShape *ptr;</span><br><span class="line"><span class="function">CRectangle <span class="title">rect</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">CTriangle  <span class="title">tri</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取矩形的面积</span></span><br><span class="line">ptr = &amp;rect;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ptr-&gt;area() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取三角形的面积</span></span><br><span class="line">ptr = &amp;tri;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ptr-&gt;area() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>C++</code>中构成多态需要满足两个条件：</p><ol><li>调用函数的对象须是<strong>指针</strong>或<strong>引用</strong></li><li>被调用的函数须是<strong>重写</strong><sup><a href="#fn_ 1" id="reffn_ 1"> 1</a></sup>的<strong>虚函数</strong><sup><a href="#fn_ 2" id="reffn_ 2"> 2</a></sup></li></ol><h3 id="聚合-组合-Aggregation-Composition"><a href="#聚合-组合-Aggregation-Composition" class="headerlink" title="聚合/组合 Aggregation / Composition"></a>聚合/组合 Aggregation / Composition</h3><h4 id="聚合-Aggregation"><a href="#聚合-Aggregation" class="headerlink" title="聚合 Aggregation"></a>聚合 Aggregation</h4><blockquote><p>A has B，B是A的一部分，但A不控制B的生命周期</p></blockquote><p>如：学校由学生组成，那么学校与学生是聚合关系</p><p><code>UML</code>图中聚合关系的符号如下图</p><p><img src="https://s.plantuml.com/sym03.png" alt></p><h4 id="组合-Composition"><a href="#组合-Composition" class="headerlink" title="组合 Composition"></a>组合 Composition</h4><blockquote><p>A has B，B是A的一部分，且A控制B的生命周期</p></blockquote><p>如：树由树叶组成，那么树与树叶是组合关系</p><p><code>UML</code>图中聚合关系的符号如下图</p><p><img src="https://s.plantuml.com/sym01.png" alt></p><h3 id="接口-实现-Interface-Implementation"><a href="#接口-实现-Interface-Implementation" class="headerlink" title="接口/实现 Interface / Implementation"></a>接口/实现 Interface / Implementation</h3><h4 id="接口-Interface"><a href="#接口-Interface" class="headerlink" title="接口 Interface"></a>接口 Interface</h4><blockquote><p>描述一个类的用户如何与这个类交互</p></blockquote><h4 id="实现-Implementation"><a href="#实现-Implementation" class="headerlink" title="实现 Implementation"></a>实现 Implementation</h4><blockquote><p>完成接口所定义的功能，如类、构建等完成的任务</p></blockquote><p>如电视机、插座、发电厂的关系如何呢？</p><p><img src="http://www.plantuml.com/plantuml/png/SoWkIImgAStDuKhEIImkLWZEJyvEBL6miSdCAqajIajCJhMpume9Kz3JiuFASS6KrEZfAGJabwSM1UGavfLmEQJcfG3D0G00" alt></p><ul><li>电视机是用户 client</li><li>插座是接口 Interface</li><li>发电厂是实现 Implementation</li></ul><h3 id="抽象-Abstraction"><a href="#抽象-Abstraction" class="headerlink" title="抽象 Abstraction"></a>抽象 Abstraction</h3><blockquote><p>抽取具体客观事物的共性</p></blockquote><p>抽象是面向对象领域<font color="red">发现类</font>的主要方法</p><p>（所谓抽象，玄之又玄，众妙之门）</p><hr><blockquote id="fn_ 1"><sup> 1</sup>. 重写：函数重写必须函数名一致、参数一致、返回值一致<a href="#reffn_ 1" title="Jump back to footnote [ 1] in the text."> &#8617;</a></blockquote><blockquote id="fn_ 2"><sup> 2</sup>. 虚函数：在类的成员函数前加<code>virtual</code>关键字<a href="#reffn_ 2" title="Jump back to footnote [ 2] in the text."> &#8617;</a></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1580203723216&amp;amp;di=8aed87a08dfaee482cb60caaaed0998a&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2F01.minipic.eastday.com%2F20170705%2F20170705072438_f5cc5771dd19389bacdba25fcfa1ee80_4.jpeg&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;面向对象绪论&quot;&gt;&lt;a href=&quot;#面向对象绪论&quot; class=&quot;headerlink&quot; title=&quot;面向对象绪论&quot;&gt;&lt;/a&gt;面向对象绪论&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;图：歼15航母降落&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;h2 id=&quot;面向对象的基本概念&quot;&gt;&lt;a href=&quot;#面向对象的基本概念&quot; class=&quot;headerlink&quot; title=&quot;面向对象的基本概念&quot;&gt;&lt;/a&gt;面向对象的基本概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;类 Class&lt;/li&gt;
&lt;li&gt;对象 Object&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;浅显理解：类是抽象的对象，对象是具体的类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概念之间的互用&quot;&gt;&lt;a href=&quot;#概念之间的互用&quot; class=&quot;headerlink&quot; title=&quot;概念之间的互用&quot;&gt;&lt;/a&gt;概念之间的互用&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;属性 Attribute == 数据 Data == 状态 State == 信息 Information&lt;/li&gt;
&lt;li&gt;操作 Operation == 方法 Method == 行为 Behavior == 职责 Responsibility&lt;/li&gt;
&lt;li&gt;对象 Object == 实例 Instance&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;面向对象的核心特征&quot;&gt;&lt;a href=&quot;#面向对象的核心特征&quot; class=&quot;headerlink&quot; title=&quot;面向对象的核心特征&quot;&gt;&lt;/a&gt;面向对象的核心特征&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;封装 Encapsulation&lt;/li&gt;
&lt;li&gt;继承 Inheritance&lt;/li&gt;
&lt;li&gt;多态 Polymorphism&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;封装、继承和多态被称为所谓的“面向对象三大特征”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;聚合/组合 Aggregation / Composition&lt;/li&gt;
&lt;li&gt;接口/实现 Interface / Implementation&lt;/li&gt;
&lt;li&gt;抽象 Abstraction&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;封装-Encapsulation&quot;&gt;&lt;a href=&quot;#封装-Encapsulation&quot; class=&quot;headerlink&quot; title=&quot;封装 Encapsulation&quot;&gt;&lt;/a&gt;封装 Encapsulation&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;是指隐藏对象的属性和实现细节，仅对外提供公共访问方式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;封装什么？&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;内部的、不想让其他人随意了解的信息&lt;/li&gt;
&lt;li&gt;类的属性 Attribute&lt;/li&gt;
&lt;li&gt;类的方法 Method&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;为什么要封装？&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;保护隐私&lt;/li&gt;
&lt;li&gt;保护数据安全&lt;/li&gt;
&lt;li&gt;隔离复杂度&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;面向对象的封装有四种方式&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Public&lt;/li&gt;
&lt;li&gt;Private&lt;/li&gt;
&lt;li&gt;Protected&lt;/li&gt;
&lt;li&gt;Package&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;继承-Inheritance&quot;&gt;&lt;a href=&quot;#继承-Inheritance&quot; class=&quot;headerlink&quot; title=&quot;继承 Inheritance&quot;&gt;&lt;/a&gt;继承 Inheritance&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;一个类从其他类获得它的状态和行为，同时还可以加上自己额外的状态和行为&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;父类中的属性和方法，在子类中可以重复使用，子类就不需要再定义了，这样即可实现代码的可重用性。如以下类图例子，定义类&lt;code&gt;C1Dobject&lt;/code&gt;一维物体，它有一个属性&lt;code&gt;x&lt;/code&gt;对应x轴上的一个坐标，两个方法&lt;code&gt;getx()&lt;/code&gt;和&lt;code&gt;setx(int)&lt;/code&gt;分别表示x坐标的获取和设置。如果我们需要定义二维物体，就没有必要把x坐标重复定义。我们在类&lt;code&gt;C1Dobject&lt;/code&gt;的基础上派生出子类&lt;code&gt;C2Dobject&lt;/code&gt;，只需再定义属性&lt;code&gt;y&lt;/code&gt;和方法&lt;code&gt;gety()&lt;/code&gt;及&lt;code&gt;sety(int)&lt;/code&gt;就可以完整地抽象出一个二维物体；类似地，如果我们需要定义三维物体，没有必要把x坐标、y坐标重复定义，只需再类&lt;code&gt;C2Dobject&lt;/code&gt;的基础上派生出子类&lt;code&gt;C3Dobject&lt;/code&gt;，再定义属性&lt;code&gt;z&lt;/code&gt;和方法&lt;code&gt;getz()&lt;/code&gt;及&lt;code&gt;setz(int)&lt;/code&gt;即可。显而易见，继承提高了代码的可重用性，减少了创建类的工作量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.plantuml.com/plantuml/png/SoWkIImgAStDuN8sTCbFoafDBb6mgT7LLN0sWdAv82o4X35CWYiv9x6uM06XiPfBeK8XCw-4Io4zjQH2GnF2BWQnWInDhbgu5YCaBPLmBPL8MYhHjHWZQQc2Qwb2qb85q-AGcfS2z180&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;以上类图对应的&lt;code&gt;C++&lt;/code&gt;代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;C1Dobject&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getx&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; x; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setx&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; xPrime)&lt;/span&gt; &lt;/span&gt;&amp;#123; x = xPrime; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;C2Dobject&lt;/span&gt;:&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; C1Dobject&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; y = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;gety&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; y; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sety&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; yPrime)&lt;/span&gt; &lt;/span&gt;&amp;#123; y = yPrime; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;C3Dobject&lt;/span&gt;:&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; C2Dobject&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; z = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getz&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; z; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setz&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; zPrime)&lt;/span&gt; &lt;/span&gt;&amp;#123; z = zPrime; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="OOP" scheme="https://G-SS-Hacker.github.io/tags/OOP/"/>
    
      <category term="C-plus-plus" scheme="https://G-SS-Hacker.github.io/tags/C-plus-plus/"/>
    
      <category term="面向对象" scheme="https://G-SS-Hacker.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="软件工程" scheme="https://G-SS-Hacker.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>二次曲面</title>
    <link href="https://g-ss-hacker.github.io/%E4%BA%8C%E6%AC%A1%E6%9B%B2%E9%9D%A2/"/>
    <id>https://g-ss-hacker.github.io/%E4%BA%8C%E6%AC%A1%E6%9B%B2%E9%9D%A2/</id>
    <published>2019-12-27T09:17:43.000Z</published>
    <updated>2020-01-25T13:16:10.891Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/12/27/emE71j6LgFIMouW.jpg" alt></p><h1 id="二次曲面"><a href="#二次曲面" class="headerlink" title="二次曲面"></a>二次曲面</h1><blockquote><p>图：Watch Dog 2 by Ubisoft</p></blockquote><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><br>1.椭圆柱面<p></p><script type="math/tex; mode=display">\frac{x^2}{a^2}+\frac{y^2}{b^2}=1</script><p><img src="https://i.loli.net/2019/12/27/Hwvx1keWTuFSYst.png" alt></p><p>2.双曲柱面</p><script type="math/tex; mode=display">\frac{x^2}{a^2}-\frac{y^2}{b^2}=1</script><p><img src="https://i.loli.net/2019/12/27/PwFeypDxlEtRCBH.png" alt></p><p>3.抛物柱面</p><script type="math/tex; mode=display">x^2=2py,(p\ne 0)</script><p><img src="https://i.loli.net/2019/12/27/45RbcKSEJg6mzd8.png" alt></p><p>4.椭球面</p><script type="math/tex; mode=display">\frac{x^2}{a^2}+\frac{y^2}{b^2}+\frac{z^2}{c^2}=1</script><p><img src="https://i.loli.net/2019/12/27/EfLtb1HT73QlpuF.png" alt></p><p>5.单叶双曲面</p><script type="math/tex; mode=display">\frac{x^2}{a^2}+\frac{y^2}{b^2}-\frac{z^2}{c^2}=1</script><p><img src="https://i.loli.net/2019/12/27/F1US2Bg5wjTlb4p.png" alt></p><p>6.双叶双曲面</p><script type="math/tex; mode=display">\frac{x^2}{a^2}-\frac{y^2}{b^2}-\frac{z^2}{c^2}=1</script><p><img src="https://i.loli.net/2019/12/27/FvlP6Zc7On82jBh.png" alt></p><p>7.椭圆抛物面</p><script type="math/tex; mode=display">\frac{x^2}{2p}+\frac{y^2}{2q}=z,(p,q同号)</script><p><img src="https://i.loli.net/2019/12/27/iDJsOL9dQHUpM5g.png" alt></p><p>8.双曲抛物面</p><script type="math/tex; mode=display">\frac{x^2}{2p}-\frac{y^2}{2q}=z,(p,q同号)</script><p>变种：</p><script type="math/tex; mode=display">x^2-y^2=z</script><p><img src="https://i.loli.net/2019/12/27/q5RrWazfgbGyCNV.png" alt></p><p>9.二次锥面</p><script type="math/tex; mode=display">\frac{x^2}{a^2}+\frac{y^2}{b^2}+\frac{z^2}{c^2}=0</script><p><img src="https://i.loli.net/2019/12/27/xWD9suRyaVKtgLj.png" alt></p><a id="more"></a><hr><p>~<font color="#FF7F27"><strong>我们遇到什么困难也不要怕，微笑着面对它！消除恐惧的最好办法就是面对恐惧！坚持就是胜利！加油！奥利给！</strong></font>~</p><font color="#407600">【其他文章·微积分·线性代数】</font><ul><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/不定积分公式/">不定积分公式</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/常用泰勒展开式/">常用泰勒展开式</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/高阶求导公式/">高阶求导公式</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/高等数学公式/">高等数学公式</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/常用等价无穷小/">常用等价无穷小</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/导数基本公式/">导数基本公式</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/矩阵章节总结/">矩阵章节总结</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/行列式章节总结/">行列式章节总结</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/线性方程组章节总结/">线性方程组章节总结</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/27/emE71j6LgFIMouW.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;二次曲面&quot;&gt;&lt;a href=&quot;#二次曲面&quot; class=&quot;headerlink&quot; title=&quot;二次曲面&quot;&gt;&lt;/a&gt;二次曲面&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;图：Watch Dog 2 by Ubisoft&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;br&gt;1.椭圆柱面&lt;p&gt;&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\frac{x^2}{a^2}+\frac{y^2}{b^2}=1&lt;/script&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/27/Hwvx1keWTuFSYst.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;2.双曲柱面&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\frac{x^2}{a^2}-\frac{y^2}{b^2}=1&lt;/script&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/27/PwFeypDxlEtRCBH.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;3.抛物柱面&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
x^2=2py,(p\ne 0)&lt;/script&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/27/45RbcKSEJg6mzd8.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;4.椭球面&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\frac{x^2}{a^2}+\frac{y^2}{b^2}+\frac{z^2}{c^2}=1&lt;/script&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/27/EfLtb1HT73QlpuF.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;5.单叶双曲面&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\frac{x^2}{a^2}+\frac{y^2}{b^2}-\frac{z^2}{c^2}=1&lt;/script&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/27/F1US2Bg5wjTlb4p.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;6.双叶双曲面&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\frac{x^2}{a^2}-\frac{y^2}{b^2}-\frac{z^2}{c^2}=1&lt;/script&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/27/FvlP6Zc7On82jBh.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;7.椭圆抛物面&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\frac{x^2}{2p}+\frac{y^2}{2q}=z,(p,q同号)&lt;/script&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/27/iDJsOL9dQHUpM5g.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;8.双曲抛物面&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\frac{x^2}{2p}-\frac{y^2}{2q}=z,(p,q同号)&lt;/script&gt;&lt;p&gt;变种：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
x^2-y^2=z&lt;/script&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/27/q5RrWazfgbGyCNV.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;9.二次锥面&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\frac{x^2}{a^2}+\frac{y^2}{b^2}+\frac{z^2}{c^2}=0&lt;/script&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/27/xWD9suRyaVKtgLj.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="线性代数" scheme="https://G-SS-Hacker.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>面向对象设计七大原则</title>
    <link href="https://g-ss-hacker.github.io/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    <id>https://g-ss-hacker.github.io/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/</id>
    <published>2019-12-12T15:07:33.000Z</published>
    <updated>2019-12-12T15:10:10.887Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/12/12/nuhOlgtVX1asp7B.jpg" alt></p><h1 id="面向对象设计七大原则"><a href="#面向对象设计七大原则" class="headerlink" title="面向对象设计七大原则"></a>面向对象设计七大原则</h1><blockquote><p>图：北京航空航天大学</p></blockquote><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><p></p><blockquote><p>AKA：设计模式七大原则</p></blockquote><p><strong>1. 单一职责原则</strong></p><ul><li>SRP，Single Responsibility Principle</li><li>每一个对象有且只有一个职责，从而实现”高内聚、低耦合“</li><li>防止一个类实现多个功能，改变一个功能后影响其他功能的正常运作</li></ul><p><strong>2. 开放-封闭原则</strong></p><ul><li>OCP，Open-Closed Principle</li><li>对拓展开放、对修改关闭</li><li>需要对程序进行拓展的时候，不能修改原有代码，只能在原有代码的基础上添加</li></ul><p><strong>3. 李氏替换原则</strong></p><ul><li>LSP，Liskov Substitution Principle</li><li>任何基类出现的地方，一定可以用派生类代替</li><li>派生类可以拓展基类的功能，但不能改变基类的功能</li></ul><p><strong>4. 依赖倒置原则</strong></p><ul><li>DIP，Dependence Inversion Principle</li><li>实现依赖于抽象，而抽象不依赖于实现</li><li>解除高层组件对低层组件的依赖，是实现开闭原则的重要基础</li></ul><p><strong>5. 接口隔离原则</strong></p><ul><li>ISP，Interface Segregation Principle</li><li>一个类对另外一个类的依赖性应当是建立在最小的接口上</li><li>在特定的使用场合给特定用户提供其需要的方法、屏蔽其不需要的方法</li></ul><p><strong>6. 组合重用原则</strong></p><ul><li>CRP, Composite Reuse Principle,</li><li>尽量使用组合，尽量不用继承</li><li>在新的对象里面使用已有的对象，使之成为新的对象的一部分</li></ul><p><strong>7. 迪米特原则</strong></p><ul><li>LoD，Law of Demeter</li><li>一个对象应该对其他对象又尽可能少的了解</li><li>尽量降低成员的访问权限，提供访问器而不公开成员变量</li></ul><hr><a id="more"></a><blockquote><p>注：<code>C++</code>中只有抽象类的概念，<code>JAVA</code>中既有抽象类的概念，又有接口的概念。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/12/nuhOlgtVX1asp7B.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;面向对象设计七大原则&quot;&gt;&lt;a href=&quot;#面向对象设计七大原则&quot; class=&quot;headerlink&quot; title=&quot;面向对象设计七大原则&quot;&gt;&lt;/a&gt;面向对象设计七大原则&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;图：北京航空航天大学&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;AKA：设计模式七大原则&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;1. 单一职责原则&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SRP，Single Responsibility Principle&lt;/li&gt;
&lt;li&gt;每一个对象有且只有一个职责，从而实现”高内聚、低耦合“&lt;/li&gt;
&lt;li&gt;防止一个类实现多个功能，改变一个功能后影响其他功能的正常运作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2. 开放-封闭原则&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OCP，Open-Closed Principle&lt;/li&gt;
&lt;li&gt;对拓展开放、对修改关闭&lt;/li&gt;
&lt;li&gt;需要对程序进行拓展的时候，不能修改原有代码，只能在原有代码的基础上添加&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;3. 李氏替换原则&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LSP，Liskov Substitution Principle&lt;/li&gt;
&lt;li&gt;任何基类出现的地方，一定可以用派生类代替&lt;/li&gt;
&lt;li&gt;派生类可以拓展基类的功能，但不能改变基类的功能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;4. 依赖倒置原则&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DIP，Dependence Inversion Principle&lt;/li&gt;
&lt;li&gt;实现依赖于抽象，而抽象不依赖于实现&lt;/li&gt;
&lt;li&gt;解除高层组件对低层组件的依赖，是实现开闭原则的重要基础&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;5. 接口隔离原则&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ISP，Interface Segregation Principle&lt;/li&gt;
&lt;li&gt;一个类对另外一个类的依赖性应当是建立在最小的接口上&lt;/li&gt;
&lt;li&gt;在特定的使用场合给特定用户提供其需要的方法、屏蔽其不需要的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;6. 组合重用原则&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CRP, Composite Reuse Principle,&lt;/li&gt;
&lt;li&gt;尽量使用组合，尽量不用继承&lt;/li&gt;
&lt;li&gt;在新的对象里面使用已有的对象，使之成为新的对象的一部分&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;7. 迪米特原则&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LoD，Law of Demeter&lt;/li&gt;
&lt;li&gt;一个对象应该对其他对象又尽可能少的了解&lt;/li&gt;
&lt;li&gt;尽量降低成员的访问权限，提供访问器而不公开成员变量&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="面向对象" scheme="https://G-SS-Hacker.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="软件工程" scheme="https://G-SS-Hacker.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++引用</title>
    <link href="https://g-ss-hacker.github.io/C-%E5%BC%95%E7%94%A8/"/>
    <id>https://g-ss-hacker.github.io/C-%E5%BC%95%E7%94%A8/</id>
    <published>2019-12-07T02:51:15.000Z</published>
    <updated>2020-01-25T12:47:04.085Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/12/07/Xua6pB154KjyqiL.jpg" alt></p><h1 id="C-引用"><a href="#C-引用" class="headerlink" title="C++引用"></a>C++引用</h1><blockquote><p>图：LEGO小人仔</p></blockquote><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><p></p><font color="#FF7F27">笔记整理自《北京大学公开课：C++面向对象程序设计》</font><blockquote><p><code>C++</code>跟<code>C</code>相比，多了很多独特的内容，其中有很多都是为了实现面向对象编程范式而引入的，<code>C++</code>的引用就是其一。</p></blockquote><h2 id="引用的概念"><a href="#引用的概念" class="headerlink" title="引用的概念"></a>引用的概念</h2><ul><li>定义一个引用，并将其初始化为引用某个变量的通用写法：<code>类型名 &amp; 引用名 = 某变量名</code></li><li>某个变量的引用，<font color="red">等价于</font>这个变量，相当于该变量的一个别名</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> &amp; r = n;</span><br><span class="line"><span class="comment">//r引用了n，r的类型是int &amp;</span></span><br><span class="line">r = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; r;<span class="comment">//输出4</span></span><br><span class="line">cour &lt;&lt; n;<span class="comment">//输出4</span></span><br><span class="line">n = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; n;</span><br></pre></td></tr></table></figure><ul><li>定义引用时一定要将其<font color="red">初始化</font>成引用某个变量，而不像指针可以指向某个变量也可以不指向某个变量</li><li>初始化后，它就一直引用该变量，不会再引用别的变量了（引用是从一而终的）</li><li>引用只能引用<font color="red">变量</font>，不能引用常量和表达式</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> a = <span class="number">3</span>, b = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">double</span> &amp; r1 = a;</span><br><span class="line"><span class="keyword">double</span> &amp; r2 = r1;<span class="comment">//r2也引用a</span></span><br><span class="line">r2 = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//输出10</span></span><br><span class="line">r1 = b;<span class="comment">//r1并没有引用b</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//输出5</span></span><br></pre></td></tr></table></figure><h2 id="引用的应用"><a href="#引用的应用" class="headerlink" title="引用的应用"></a>引用的应用</h2><p><code>C</code>中，如何编写交换两个整型变量值的函数?</p><ul><li>这样写吗？</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    tmp = a; a = b; b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n1, n2;</span><br><span class="line">swap(n1, n2);</span><br><span class="line"><span class="comment">//n1, n2的值没有被交换</span></span><br></pre></td></tr></table></figure><p>这是错误的，改变形参不会改变实参。</p><ul><li>或者用指针？</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    tmp = *a; *a = *b; *b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n1, n2;</span><br><span class="line">swap(&amp; n1, &amp; n2);<span class="comment">//取地址</span></span><br><span class="line"><span class="comment">//n1, n2的值被交换</span></span><br></pre></td></tr></table></figure><p>正确，但丑陋！</p><p>那么<code>C++</code>中，如何编写交换两个整型变量值的函数?</p><h3 id="引用作为参数"><a href="#引用作为参数" class="headerlink" title="引用作为参数"></a>引用作为参数</h3><blockquote><p><code>C++</code>示例：交换两个整数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp; a, <span class="keyword">int</span> &amp; b)</span><span class="comment">//a就是n1，b就是n2</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    tmp = a; a = b; b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n1, n2;</span><br><span class="line">swap(n1, n2);</span><br><span class="line"><span class="comment">//n1, n2的值被交换</span></span><br></pre></td></tr></table></figure><h3 id="引用作为返回值"><a href="#引用作为返回值" class="headerlink" title="引用作为返回值"></a>引用作为返回值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp; <span class="title">SetValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//神奇之处，对函数的返回值进行赋值</span></span><br><span class="line">    SetValue() = <span class="number">40</span>;</span><br><span class="line">    <span class="comment">//然而它究竟有什么作用呢？我还没想好...</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n;</span><br><span class="line">    <span class="comment">//输出：40</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意被引用的对象<font color="red">不能超过作用域</font>，返回一个<strong>局部变量</strong>的引用是不合法的，但是，可以返回一个<strong>静态类型变量</strong>的引用。</p><h2 id="常引用"><a href="#常引用" class="headerlink" title="常引用"></a>常引用</h2><p>定义引用时，在前面加<code>const</code>关键字即为“常引用”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp; r = n;</span><br></pre></td></tr></table></figure><font color="red">注意不能通过常引用去修改其引用的内容！</font><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp; r = n;</span><br><span class="line">r = <span class="number">200</span>;<span class="comment">//err</span></span><br><span class="line">n = <span class="number">300</span>;<span class="comment">//ok</span></span><br></pre></td></tr></table></figure><h2 id="常引用和非常引用的转换"><a href="#常引用和非常引用的转换" class="headerlink" title="常引用和非常引用的转换"></a>常引用和非常引用的转换</h2><ul><li><code>const T &amp;</code><font color="red">和</font><code>T &amp;</code><font color="red">是不同的类型</font>（千万要注意！！！）</li><li><code>T &amp;</code>类型的引用或<code>T</code>类型的变量可以用来初始化<code>const T &amp;</code>类型的引用</li><li><code>const T</code>类型的常变量和<code>const T &amp;</code>类型的引用则不能用来初始化<code>T &amp;</code>类型的引用，除非进行<strong>强制类型转换</strong></li></ul><a id="more"></a><hr><blockquote><p>参考并整理自《C++面向对象设计》郭炜，北京大学，感谢原作者！编辑时有删改</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/07/Xua6pB154KjyqiL.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;C-引用&quot;&gt;&lt;a href=&quot;#C-引用&quot; class=&quot;headerlink&quot; title=&quot;C++引用&quot;&gt;&lt;/a&gt;C++引用&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;图：LEGO小人仔&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;font color=&quot;#FF7F27&quot;&gt;笔记整理自《北京大学公开课：C++面向对象程序设计》&lt;/font&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;C++&lt;/code&gt;跟&lt;code&gt;C&lt;/code&gt;相比，多了很多独特的内容，其中有很多都是为了实现面向对象编程范式而引入的，&lt;code&gt;C++&lt;/code&gt;的引用就是其一。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;引用的概念&quot;&gt;&lt;a href=&quot;#引用的概念&quot; class=&quot;headerlink&quot; title=&quot;引用的概念&quot;&gt;&lt;/a&gt;引用的概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;定义一个引用，并将其初始化为引用某个变量的通用写法：&lt;code&gt;类型名 &amp;amp; 引用名 = 某变量名&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;某个变量的引用，&lt;font color=&quot;red&quot;&gt;等价于&lt;/font&gt;这个变量，相当于该变量的一个别名&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n = &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &amp;amp; r = n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//r引用了n，r的类型是int &amp;amp;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;r = &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; r;	&lt;span class=&quot;comment&quot;&gt;//输出4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cour &amp;lt;&amp;lt; n;	&lt;span class=&quot;comment&quot;&gt;//输出4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;n = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; n;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;定义引用时一定要将其&lt;font color=&quot;red&quot;&gt;初始化&lt;/font&gt;成引用某个变量，而不像指针可以指向某个变量也可以不指向某个变量&lt;/li&gt;
&lt;li&gt;初始化后，它就一直引用该变量，不会再引用别的变量了（引用是从一而终的）&lt;/li&gt;
&lt;li&gt;引用只能引用&lt;font color=&quot;red&quot;&gt;变量&lt;/font&gt;，不能引用常量和表达式&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, b = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; &amp;amp; r1 = a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; &amp;amp; r2 = r1;	&lt;span class=&quot;comment&quot;&gt;//r2也引用a&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;r2 = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;	&lt;span class=&quot;comment&quot;&gt;//输出10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;r1 = b;				&lt;span class=&quot;comment&quot;&gt;//r1并没有引用b&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;	&lt;span class=&quot;comment&quot;&gt;//输出5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;引用的应用&quot;&gt;&lt;a href=&quot;#引用的应用&quot; class=&quot;headerlink&quot; title=&quot;引用的应用&quot;&gt;&lt;/a&gt;引用的应用&lt;/h2&gt;&lt;p&gt;&lt;code&gt;C&lt;/code&gt;中，如何编写交换两个整型变量值的函数?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这样写吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; tmp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    tmp = a; a = b; b = tmp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n1, n2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;swap(n1, n2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//n1, n2的值没有被交换&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这是错误的，改变形参不会改变实参。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;或者用指针？&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *a, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *b)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; tmp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    tmp = *a; *a = *b; *b = tmp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n1, n2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;swap(&amp;amp; n1, &amp;amp; n2);	&lt;span class=&quot;comment&quot;&gt;//取地址&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//n1, n2的值被交换&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;正确，但丑陋！&lt;/p&gt;
&lt;p&gt;那么&lt;code&gt;C++&lt;/code&gt;中，如何编写交换两个整型变量值的函数?&lt;/p&gt;
&lt;h3 id=&quot;引用作为参数&quot;&gt;&lt;a href=&quot;#引用作为参数&quot; class=&quot;headerlink&quot; title=&quot;引用作为参数&quot;&gt;&lt;/a&gt;引用作为参数&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;C++&lt;/code&gt;示例：交换两个整数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &amp;amp; a, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &amp;amp; b)&lt;/span&gt;	&lt;span class=&quot;comment&quot;&gt;//a就是n1，b就是n2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; tmp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    tmp = a; a = b; b = tmp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n1, n2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;swap(n1, n2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//n1, n2的值被交换&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;引用作为返回值&quot;&gt;&lt;a href=&quot;#引用作为返回值&quot; class=&quot;headerlink&quot; title=&quot;引用作为返回值&quot;&gt;&lt;/a&gt;引用作为返回值&lt;/h3&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n = &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &amp;amp; &lt;span class=&quot;title&quot;&gt;SetValue&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; n; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//神奇之处，对函数的返回值进行赋值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SetValue() = &lt;span class=&quot;number&quot;&gt;40&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//然而它究竟有什么作用呢？我还没想好...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//输出：40&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注意被引用的对象&lt;font color=&quot;red&quot;&gt;不能超过作用域&lt;/font&gt;，返回一个&lt;strong&gt;局部变量&lt;/strong&gt;的引用是不合法的，但是，可以返回一个&lt;strong&gt;静态类型变量&lt;/strong&gt;的引用。&lt;/p&gt;
&lt;h2 id=&quot;常引用&quot;&gt;&lt;a href=&quot;#常引用&quot; class=&quot;headerlink&quot; title=&quot;常引用&quot;&gt;&lt;/a&gt;常引用&lt;/h2&gt;&lt;p&gt;定义引用时，在前面加&lt;code&gt;const&lt;/code&gt;关键字即为“常引用”。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &amp;amp; r = n;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;font color=&quot;red&quot;&gt;注意不能通过常引用去修改其引用的内容！&lt;/font&gt;

&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &amp;amp; r = n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;r = &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;;	&lt;span class=&quot;comment&quot;&gt;//err&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;n = &lt;span class=&quot;number&quot;&gt;300&lt;/span&gt;;	&lt;span class=&quot;comment&quot;&gt;//ok&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;常引用和非常引用的转换&quot;&gt;&lt;a href=&quot;#常引用和非常引用的转换&quot; class=&quot;headerlink&quot; title=&quot;常引用和非常引用的转换&quot;&gt;&lt;/a&gt;常引用和非常引用的转换&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;const T &amp;amp;&lt;/code&gt;&lt;font color=&quot;red&quot;&gt;和&lt;/font&gt;&lt;code&gt;T &amp;amp;&lt;/code&gt;&lt;font color=&quot;red&quot;&gt;是不同的类型&lt;/font&gt;（千万要注意！！！）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;T &amp;amp;&lt;/code&gt;类型的引用或&lt;code&gt;T&lt;/code&gt;类型的变量可以用来初始化&lt;code&gt;const T &amp;amp;&lt;/code&gt;类型的引用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const T&lt;/code&gt;类型的常变量和&lt;code&gt;const T &amp;amp;&lt;/code&gt;类型的引用则不能用来初始化&lt;code&gt;T &amp;amp;&lt;/code&gt;类型的引用，除非进行&lt;strong&gt;强制类型转换&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="OOP" scheme="https://G-SS-Hacker.github.io/tags/OOP/"/>
    
      <category term="C-plus-plus" scheme="https://G-SS-Hacker.github.io/tags/C-plus-plus/"/>
    
      <category term="面向对象" scheme="https://G-SS-Hacker.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++继承和派生</title>
    <link href="https://g-ss-hacker.github.io/C-%E7%BB%A7%E6%89%BF%E5%92%8C%E6%B4%BE%E7%94%9F/"/>
    <id>https://g-ss-hacker.github.io/C-%E7%BB%A7%E6%89%BF%E5%92%8C%E6%B4%BE%E7%94%9F/</id>
    <published>2019-12-06T13:51:21.000Z</published>
    <updated>2020-01-30T02:36:48.693Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/12/06/QYrjln.jpg" alt></p><h1 id="C-继承和派生"><a href="#C-继承和派生" class="headerlink" title="C++继承和派生"></a>C++继承和派生</h1><blockquote><p>图：古老的地球</p></blockquote><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><p></p><font color="#FF7F27">本文整理自《北京大学公开课：C++面向对象程序设计》</font><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><font color="font">继承</font>和<font color="red">派生</font>实际上是一回事：在定义一个新的类<code>B</code>时，如果该类与某个已有的类<code>A</code>相似（指的是<code>B</code>拥有<code>A</code>的全部特点），那么可以把<code>A</code>作为一个<strong>基类</strong>，而把<code>B</code>作为<strong>基类</strong>的一个<strong>派生类</strong>（也称<strong>子类</strong>），这使得创建和维护一个程序更加容易</li><li><strong>派生类</strong>拥有<strong>基类</strong>的全部特点，派生类还可以对<strong>基类</strong>进行修改和扩充。在<strong>派生类</strong>中，可以扩充新的成员变量和成员函数</li><li><strong>派生类</strong>一经定义，可以独立使用，定义对象时不依赖于<strong>基类</strong></li><li><strong>派生类</strong>拥有<strong>基类</strong>的全部成员函数和成员变量。不论是<code>private</code>、<code>protected</code>、<code>public</code></li><li>在<strong>派生类</strong>的各个成员函数中，不能访问<strong>基类</strong>的<code>private</code>成员</li></ul><blockquote><p>简单理解成员修饰符<code>protected</code>和<code>private</code>的区别：<code>protected</code>成员在派生类中可以被访问，而<code>private</code>不能</p></blockquote><ul><li>对象不同类型对应的访问权限：</li></ul><div class="table-container"><table><thead><tr><th>类型</th><th>public</th><th>protected</th><th>private</th></tr></thead><tbody><tr><td>本类</td><td>√</td><td>√</td><td>√</td></tr><tr><td>派生类</td><td>√</td><td>√</td><td>×</td></tr><tr><td>其他类</td><td>√</td><td>×</td><td>×</td></tr></tbody></table></div><h2 id="派生类的写法"><a href="#派生类的写法" class="headerlink" title="派生类的写法"></a>派生类的写法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 派生类名:</span> 访问修饰符 基类名<span class="comment">//Zh</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span>-<span class="title">class</span>:</span> access-specifier base-<span class="class"><span class="keyword">class</span>//<span class="title">En</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>访问修饰符</strong>可以是<code>private</code>、<code>protected</code>、<code>public</code>中的一个。如果未使用<strong>访问修饰符</strong>，则默认为<code>private</code>。该访问修饰符规定了<strong>继承类型</strong>。</p><h2 id="继承类型"><a href="#继承类型" class="headerlink" title="继承类型"></a>继承类型</h2><ul><li>公有继承（<code>public</code>）：继承<code>public</code>和<code>protected</code>且类型不变，不继承<code>private</code></li><li>保护继承（<code>protected</code>）：继承<code>public</code>和<code>protected</code>且类型都为<code>protected</code>，不继承<code>private</code></li><li>私有继承（<code>private</code>）：继承<code>public</code>和<code>protected</code>且类型都变为<code>private</code>，不继承<code>private</code></li></ul><p>一般使用公有继承。</p><h2 id="写法示例：学生管理系统"><a href="#写法示例：学生管理系统" class="headerlink" title="写法示例：学生管理系统"></a>写法示例：学生管理系统</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CStudent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> sName;</span><br><span class="line">    <span class="keyword">int</span> nAge;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsThreeGood</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetName</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp; name)</span></span>&#123; sName = name; &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CUndergraduteStudent</span>:</span> <span class="keyword">public</span> CStudent</span><br><span class="line"><span class="comment">//本科生</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> nDepartment;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsThreeGood</span><span class="params">()</span></span>&#123;<span class="comment">/*...*/</span>&#125;;<span class="comment">//覆盖（不是重载！覆盖的参数表不变，重载的参数表改变！）</span></span><br><span class="line"><span class="comment">//名字与基类一样，但行为不一样</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CanBaoYan</span><span class="params">()</span></span>&#123;<span class="comment">/*...*/</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CGraduatedStudent</span>:</span> <span class="keyword">public</span> CStudent</span><br><span class="line"><span class="comment">//研究生</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> nDepartment;</span><br><span class="line"><span class="keyword">char</span> szMentorName[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CountSalary</span><span class="params">()</span></span>&#123;<span class="comment">/*...*/</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="派生类对象的内存空间"><a href="#派生类对象的内存空间" class="headerlink" title="派生类对象的内存空间"></a>派生类对象的内存空间</h2><font color="Red">派生类对象的体积 = 基类对象的体积 + 派生类对象自己的成员变量的体积。</font><p>在派生类对象中，包含基类对象，而且基类对象的存储位置位于派生类对象新增的成员变量<font color="red">之前</font>。</p><a id="more"></a><h2 id="学籍管理程序实现"><a href="#学籍管理程序实现" class="headerlink" title="学籍管理程序实现"></a>学籍管理程序实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CStudent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">string</span> id;</span><br><span class="line">    <span class="keyword">char</span> gender;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintInfo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetInfo</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp; name_, <span class="keyword">const</span> <span class="built_in">string</span> % id_, <span class="keyword">int</span> age_, <span class="keyword">char</span> gender_)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">GetName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CUndergraduteStudent</span>:</span> <span class="keyword">public</span> CStudent</span><br><span class="line">&#123;<span class="comment">//本科生类，继承了CStudent类</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">string</span> department;<span class="comment">//学生所属的系的名称</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QualifiedForBaoyan</span><span class="params">()</span><span class="comment">//给予保研资格</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"qualified for baoyan"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CStudent::PrintInfo();<span class="comment">//调用基类的PrintInfo</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Department"</span> &lt;&lt; department &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetInfo</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp; name_, <span class="keyword">const</span> <span class="built_in">string</span> % id_, <span class="keyword">int</span> age_, <span class="keyword">char</span> gender_)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CStudent::SetInfo(name_, id_, age_, gender_);<span class="comment">//调用基类的SetInfo</span></span><br><span class="line">department = department_;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CUndergraduteStudent s2;</span><br><span class="line">    </span><br><span class="line">    s2.SetInfo(<span class="string">"Guderian"</span>, <span class="string">"999999999"</span>, <span class="number">21</span>, <span class="string">"M"</span>, <span class="string">"Combat Command"</span>);</span><br><span class="line">    <span class="comment">//古德里安，999999999，,2岁，男性，战役指挥学</span></span><br><span class="line">    s2.QualifiedForBaoyan();</span><br><span class="line">    <span class="comment">//获得保研资格</span></span><br><span class="line">    s2.PrintInfo();</span><br><span class="line">    <span class="comment">//打印信息</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">Guderian qualified <span class="keyword">for</span> baoyan</span><br><span class="line">Name: Guderian</span><br><span class="line">ID: <span class="number">999999999</span></span><br><span class="line">Age: <span class="number">21</span></span><br><span class="line">Gender: M</span><br><span class="line">Department: Combat Command</span><br></pre></td></tr></table></figure><h2 id="派生类的使用方法"><a href="#派生类的使用方法" class="headerlink" title="派生类的使用方法"></a>派生类的使用方法</h2><ul><li>在派生类中，调用基类的成员函数，设置了从基类继承的信息之后，之后再设置自己独有的信息。这一方法在<code>C++</code>面向对象编程中是很常用的。</li><li><strong>多继承</strong>：一个子类可以有多个父亲，继承多个父亲的特性</li></ul><hr><blockquote><p>参考并整理自《C++面向对象设计》郭炜，北京大学，感谢原作者！编辑时有删改</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/12/06/QYrjln.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;C-继承和派生&quot;&gt;&lt;a href=&quot;#C-继承和派生&quot; class=&quot;headerlink&quot; title=&quot;C++继承和派生&quot;&gt;&lt;/a&gt;C++继承和派生&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;图：古老的地球&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;font color=&quot;#FF7F27&quot;&gt;本文整理自《北京大学公开课：C++面向对象程序设计》&lt;/font&gt;

&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;font color=&quot;font&quot;&gt;继承&lt;/font&gt;和&lt;font color=&quot;red&quot;&gt;派生&lt;/font&gt;实际上是一回事：在定义一个新的类&lt;code&gt;B&lt;/code&gt;时，如果该类与某个已有的类&lt;code&gt;A&lt;/code&gt;相似（指的是&lt;code&gt;B&lt;/code&gt;拥有&lt;code&gt;A&lt;/code&gt;的全部特点），那么可以把&lt;code&gt;A&lt;/code&gt;作为一个&lt;strong&gt;基类&lt;/strong&gt;，而把&lt;code&gt;B&lt;/code&gt;作为&lt;strong&gt;基类&lt;/strong&gt;的一个&lt;strong&gt;派生类&lt;/strong&gt;（也称&lt;strong&gt;子类&lt;/strong&gt;），这使得创建和维护一个程序更加容易&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;派生类&lt;/strong&gt;拥有&lt;strong&gt;基类&lt;/strong&gt;的全部特点，派生类还可以对&lt;strong&gt;基类&lt;/strong&gt;进行修改和扩充。在&lt;strong&gt;派生类&lt;/strong&gt;中，可以扩充新的成员变量和成员函数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;派生类&lt;/strong&gt;一经定义，可以独立使用，定义对象时不依赖于&lt;strong&gt;基类&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;派生类&lt;/strong&gt;拥有&lt;strong&gt;基类&lt;/strong&gt;的全部成员函数和成员变量。不论是&lt;code&gt;private&lt;/code&gt;、&lt;code&gt;protected&lt;/code&gt;、&lt;code&gt;public&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在&lt;strong&gt;派生类&lt;/strong&gt;的各个成员函数中，不能访问&lt;strong&gt;基类&lt;/strong&gt;的&lt;code&gt;private&lt;/code&gt;成员&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;简单理解成员修饰符&lt;code&gt;protected&lt;/code&gt;和&lt;code&gt;private&lt;/code&gt;的区别：&lt;code&gt;protected&lt;/code&gt;成员在派生类中可以被访问，而&lt;code&gt;private&lt;/code&gt;不能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;对象不同类型对应的访问权限：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;public&lt;/th&gt;
&lt;th&gt;protected&lt;/th&gt;
&lt;th&gt;private&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;本类&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;派生类&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;其他类&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h2 id=&quot;派生类的写法&quot;&gt;&lt;a href=&quot;#派生类的写法&quot; class=&quot;headerlink&quot; title=&quot;派生类的写法&quot;&gt;&lt;/a&gt;派生类的写法&lt;/h2&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; 派生类名:&lt;/span&gt; 访问修饰符 基类名	&lt;span class=&quot;comment&quot;&gt;//Zh&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;derived&lt;/span&gt;-&lt;span class=&quot;title&quot;&gt;class&lt;/span&gt;:&lt;/span&gt; access-specifier base-&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;	//&lt;span class=&quot;title&quot;&gt;En&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;访问修饰符&lt;/strong&gt;可以是&lt;code&gt;private&lt;/code&gt;、&lt;code&gt;protected&lt;/code&gt;、&lt;code&gt;public&lt;/code&gt;中的一个。如果未使用&lt;strong&gt;访问修饰符&lt;/strong&gt;，则默认为&lt;code&gt;private&lt;/code&gt;。该访问修饰符规定了&lt;strong&gt;继承类型&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;继承类型&quot;&gt;&lt;a href=&quot;#继承类型&quot; class=&quot;headerlink&quot; title=&quot;继承类型&quot;&gt;&lt;/a&gt;继承类型&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;公有继承（&lt;code&gt;public&lt;/code&gt;）：继承&lt;code&gt;public&lt;/code&gt;和&lt;code&gt;protected&lt;/code&gt;且类型不变，不继承&lt;code&gt;private&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;保护继承（&lt;code&gt;protected&lt;/code&gt;）：继承&lt;code&gt;public&lt;/code&gt;和&lt;code&gt;protected&lt;/code&gt;且类型都为&lt;code&gt;protected&lt;/code&gt;，不继承&lt;code&gt;private&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;私有继承（&lt;code&gt;private&lt;/code&gt;）：继承&lt;code&gt;public&lt;/code&gt;和&lt;code&gt;protected&lt;/code&gt;且类型都变为&lt;code&gt;private&lt;/code&gt;，不继承&lt;code&gt;private&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般使用公有继承。&lt;/p&gt;
&lt;h2 id=&quot;写法示例：学生管理系统&quot;&gt;&lt;a href=&quot;#写法示例：学生管理系统&quot; class=&quot;headerlink&quot; title=&quot;写法示例：学生管理系统&quot;&gt;&lt;/a&gt;写法示例：学生管理系统&lt;/h2&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CStudent&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; sName;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; nAge;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;IsThreeGood&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;	&lt;/span&gt;&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SetName&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; &amp;amp; name)&lt;/span&gt;	&lt;/span&gt;&amp;#123; sName = name; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CUndergraduteStudent&lt;/span&gt;:&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; CStudent&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//本科生&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; nDepartment;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;IsThreeGood&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;	&lt;/span&gt;&amp;#123;&lt;span class=&quot;comment&quot;&gt;/*...*/&lt;/span&gt;&amp;#125;;	&lt;span class=&quot;comment&quot;&gt;//覆盖（不是重载！覆盖的参数表不变，重载的参数表改变！）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;//名字与基类一样，但行为不一样&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CanBaoYan&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;	&lt;/span&gt;&amp;#123;&lt;span class=&quot;comment&quot;&gt;/*...*/&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CGraduatedStudent&lt;/span&gt;:&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; CStudent&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//研究生&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; nDepartment;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; szMentorName[&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CountSalary&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;	&lt;/span&gt;&amp;#123;&lt;span class=&quot;comment&quot;&gt;/*...*/&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;派生类对象的内存空间&quot;&gt;&lt;a href=&quot;#派生类对象的内存空间&quot; class=&quot;headerlink&quot; title=&quot;派生类对象的内存空间&quot;&gt;&lt;/a&gt;派生类对象的内存空间&lt;/h2&gt;&lt;font color=&quot;Red&quot;&gt;派生类对象的体积 = 基类对象的体积 + 派生类对象自己的成员变量的体积。&lt;/font&gt;

&lt;p&gt;在派生类对象中，包含基类对象，而且基类对象的存储位置位于派生类对象新增的成员变量&lt;font color=&quot;red&quot;&gt;之前&lt;/font&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="OOP" scheme="https://G-SS-Hacker.github.io/tags/OOP/"/>
    
      <category term="C-plus-plus" scheme="https://G-SS-Hacker.github.io/tags/C-plus-plus/"/>
    
      <category term="面向对象" scheme="https://G-SS-Hacker.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++友元</title>
    <link href="https://g-ss-hacker.github.io/C-%E5%8F%8B%E5%85%83/"/>
    <id>https://g-ss-hacker.github.io/C-%E5%8F%8B%E5%85%83/</id>
    <published>2019-12-05T12:43:48.000Z</published>
    <updated>2019-12-07T02:49:35.411Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/12/05/4od6BVpY9SDaAXy.jpg" alt></p><h1 id="C-友元"><a href="#C-友元" class="headerlink" title="C++友元"></a>C++友元</h1><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><p></p><font color="#FF7F27">本文整理自《北京大学公开课：C++面向对象程序设计》</font><blockquote><p>友元很简单，在某种程度上算作是C++设计者对C使用者的妥协。友元分为<strong>友元函数</strong>和<strong>友元类</strong>两种。</p></blockquote><h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><p>一个类的友元函数可以访问该类的私有成员，友元函数不是这个类的成员函数，可以是一个普通的全局函数或其他类的成员函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span>;</span><span class="comment">//提前声明CCar是一个类，以便后面的CDriver类使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDriver</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ModifyCar</span><span class="params">(CCar *pCar)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">int</span> <span class="title">MostExpensiveCar</span><span class="params">(CCar cars[], <span class="keyword">int</span> total)</span></span>;<span class="comment">//声明友元</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> CDriver::ModifyCar(CCar *pCar)<span class="comment">//声明友元</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> CDriver::ModifyCar(CCar *pCar)</span><br><span class="line">&#123;</span><br><span class="line">    pCar-&gt;price += <span class="number">1000</span>;<span class="comment">//汽车改装后价值增加</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MostExpensiveCar</span><span class="params">(CCar cars[], <span class="keyword">int</span> total)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmpMax = <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; ++i)</span><br><span class="line">    <span class="keyword">if</span>(cars[i].price &gt; tmpMax)</span><br><span class="line">            tmpMax = cars[i].price;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tmpMax;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以将一个类的成员函数（包括构造、析构函数）说明为另一个类的友元</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> B::function();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h2><p>如果<code>A</code>是<code>B</code>的友元类，那么<code>A</code>的所有成员函数可以访问<code>B</code>的所有私有成员</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">CDriver</span>;</span><span class="comment">//声明CDriver为友元类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDriver</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    CCar myCar;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ModifyCar</span><span class="params">()</span><span class="comment">//改装汽车</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">myCar.price += <span class="number">1000</span>;</span><br><span class="line">            <span class="comment">//因CDriver是CCar的友元类故可以访问其私有成员</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>友元类之间的关系不能传递：类<code>A</code>是类<code>B</code>的友元，类<code>C</code>是类<code>B</code>的友元，但类<code>A</code>不是类<code>C</code>的友元</li><li>友元类之间的关系不能继承</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/05/4od6BVpY9SDaAXy.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;C-友元&quot;&gt;&lt;a href=&quot;#C-友元&quot; class=&quot;headerlink&quot; title=&quot;C++友元&quot;&gt;&lt;/a&gt;C++友元&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;font color=&quot;#FF7F27&quot;&gt;本文整理自《北京大学公开课：C++面向对象程序设计》&lt;/font&gt;

&lt;blockquote&gt;
&lt;p&gt;友元很简单，在某种程度上算作是C++设计者对C使用者的妥协。友元分为&lt;strong&gt;友元函数&lt;/strong&gt;和&lt;strong&gt;友元类&lt;/strong&gt;两种。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;友元函数&quot;&gt;&lt;a href=&quot;#友元函数&quot; class=&quot;headerlink&quot; title=&quot;友元函数&quot;&gt;&lt;/a&gt;友元函数&lt;/h2&gt;&lt;p&gt;一个类的友元函数可以访问该类的私有成员，友元函数不是这个类的成员函数，可以是一个普通的全局函数或其他类的成员函数&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CCar&lt;/span&gt;;&lt;/span&gt;	&lt;span class=&quot;comment&quot;&gt;//提前声明CCar是一个类，以便后面的CDriver类使用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CDriver&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ModifyCar&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(CCar *pCar)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CCar&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; price;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;friend&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MostExpensiveCar&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(CCar cars[], &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; total)&lt;/span&gt;&lt;/span&gt;;	&lt;span class=&quot;comment&quot;&gt;//声明友元&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;friend&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; CDriver::ModifyCar(CCar *pCar)	&lt;span class=&quot;comment&quot;&gt;//声明友元&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; CDriver::ModifyCar(CCar *pCar)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pCar-&amp;gt;price += &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;;	&lt;span class=&quot;comment&quot;&gt;//汽车改装后价值增加&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MostExpensiveCar&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(CCar cars[], &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; total)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; tmpMax = &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; total; ++i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(cars[i].price &amp;gt; tmpMax)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            tmpMax = cars[i].price;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; tmpMax;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以将一个类的成员函数（包括构造、析构函数）说明为另一个类的友元&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;B&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;A&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;friend&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; B::function();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="OOP" scheme="https://G-SS-Hacker.github.io/tags/OOP/"/>
    
      <category term="C-plus-plus" scheme="https://G-SS-Hacker.github.io/tags/C-plus-plus/"/>
    
      <category term="面向对象" scheme="https://G-SS-Hacker.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++常量对象、常量成员函数和常引用</title>
    <link href="https://g-ss-hacker.github.io/C-%E5%B8%B8%E9%87%8F%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B8%B8%E9%87%8F%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%92%8C%E5%B8%B8%E5%BC%95%E7%94%A8/"/>
    <id>https://g-ss-hacker.github.io/C-%E5%B8%B8%E9%87%8F%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B8%B8%E9%87%8F%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%92%8C%E5%B8%B8%E5%BC%95%E7%94%A8/</id>
    <published>2019-12-05T04:43:46.000Z</published>
    <updated>2019-12-07T02:50:43.777Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/12/05/vwAOcbkZFnzf4PR.jpg" alt></p><h1 id="C-常量对象、常量成员函数和常引用"><a href="#C-常量对象、常量成员函数和常引用" class="headerlink" title="C++常量对象、常量成员函数和常引用"></a>C++常量对象、常量成员函数和常引用</h1><blockquote><p>图：广州塔</p></blockquote><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><p></p><font color="#FF7F27">本文整理自《北京大学公开课：C++面向对象程序设计》</font><h2 id="常量对象"><a href="#常量对象" class="headerlink" title="常量对象"></a>常量对象</h2><p>如果不希望某个对象的值被改变，则定义该对象的时候可在前面加<code>const</code>关键字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDemo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> vale;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetValue</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Demo obj;<span class="comment">//常量对象</span></span><br></pre></td></tr></table></figure><hr><h2 id="常量成员函数"><a href="#常量成员函数" class="headerlink" title="常量成员函数"></a>常量成员函数</h2><p>在类的成员函数说明后面可以加<code>const</code>关键字，则该成员函数成为常量成员函数。</p><p>常量成员函数执行期间<font color="red">不应该修改其所作用的对象</font>。因此，在常量成员函数中不能修改成员变量的值（<font color="Red">静态成员变量除外</font>），也不能调用同类的非常量成员函数（<font color="red">静态成员函数除外</font>）。</p><p>非常亮成员函数在执行的过程中是有可能修改掉常量成员函数中的值的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GetValue</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    Sample() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> Sample::GetValue() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    value = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//wrong,不能修改成员变量的值</span></span><br><span class="line">    func();</span><br><span class="line">    <span class="comment">//wrong,不能调用同类的非常量成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Sample o;</span><br><span class="line">    o.value = <span class="number">100</span>;<span class="comment">//err,不能修改成员变量的值</span></span><br><span class="line">    o.func();<span class="comment">//err,不能调用同类的非常量成员函数</span></span><br><span class="line">    o.GetValue();<span class="comment">//ok,可以执行常量成员函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="常量成员函数的重载"><a href="#常量成员函数的重载" class="headerlink" title="常量成员函数的重载"></a>常量成员函数的重载</h2><p>两个成员函数，名字和参数表都一样，但是一个是<code>const</code>，一个不是，算<font color="red">重载</font>，而不是<font color="red">重复定义</font>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    CTest()&#123; n = <span class="number">1</span> ;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span> * n; &#125;</span><br><span class="line">    <span class="comment">//这两个GetValue()函数是重载关系，而不是重复定义</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> CTest objTest1;</span><br><span class="line">    CTest objTest2;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; objTest1.GetValue() &lt;&lt; <span class="string">", "</span> &lt;&lt; objTest2.GetValue();</span><br><span class="line">    <span class="comment">//objTest1是常量对象，调用的是GetValue() const</span></span><br><span class="line">    <span class="comment">//objTest2是非常量对象，调用的是GetValue()</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="常引用"><a href="#常引用" class="headerlink" title="常引用"></a>常引用</h2><p>引用前面可以加<code>const</code>关键字，成为常引用。不能通过常引用，修改其引用的变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r = n;</span><br><span class="line">r = <span class="number">5</span>;<span class="comment">//error</span></span><br><span class="line">n = <span class="number">4</span>;<span class="comment">//OK</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>对象作为函数的参数时，生成该参数需要调用复制构造函数，效率比较低。用指针作参数，代码又不好看，如何解决？可以用对象的引用作为参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">//...  </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintfObj</span><span class="params">(Sample &amp;o)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但对象引用作为函数参数有一定风险性，若函数中不小心修改了形参<code>o</code>，则实参也跟着变，这不是我想要的。如何避免？使用常引用！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">//...  </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintfObj</span><span class="params">(<span class="keyword">const</span> Sample &amp;o)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样函数中就能确保不会出现无意中更改<code>o</code>值的语句了。</p><hr><blockquote><p> 参考并整理自《C++面向对象设计》郭炜，北京大学，感谢原作者！编辑时有删改</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/05/vwAOcbkZFnzf4PR.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;C-常量对象、常量成员函数和常引用&quot;&gt;&lt;a href=&quot;#C-常量对象、常量成员函数和常引用&quot; class=&quot;headerlink&quot; title=&quot;C++常量对象、常量成员函数和常引用&quot;&gt;&lt;/a&gt;C++常量对象、常量成员函数和常引用&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;图：广州塔&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;font color=&quot;#FF7F27&quot;&gt;本文整理自《北京大学公开课：C++面向对象程序设计》&lt;/font&gt;

&lt;h2 id=&quot;常量对象&quot;&gt;&lt;a href=&quot;#常量对象&quot; class=&quot;headerlink&quot; title=&quot;常量对象&quot;&gt;&lt;/a&gt;常量对象&lt;/h2&gt;&lt;p&gt;如果不希望某个对象的值被改变，则定义该对象的时候可在前面加&lt;code&gt;const&lt;/code&gt;关键字。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CDemo&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; vale;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   	&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SetValue&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;	&lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; Demo obj;	&lt;span class=&quot;comment&quot;&gt;//常量对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h2 id=&quot;常量成员函数&quot;&gt;&lt;a href=&quot;#常量成员函数&quot; class=&quot;headerlink&quot; title=&quot;常量成员函数&quot;&gt;&lt;/a&gt;常量成员函数&lt;/h2&gt;&lt;p&gt;在类的成员函数说明后面可以加&lt;code&gt;const&lt;/code&gt;关键字，则该成员函数成为常量成员函数。&lt;/p&gt;
&lt;p&gt;常量成员函数执行期间&lt;font color=&quot;red&quot;&gt;不应该修改其所作用的对象&lt;/font&gt;。因此，在常量成员函数中不能修改成员变量的值（&lt;font color=&quot;Red&quot;&gt;静态成员变量除外&lt;/font&gt;），也不能调用同类的非常量成员函数（&lt;font color=&quot;red&quot;&gt;静态成员函数除外&lt;/font&gt;）。&lt;/p&gt;
&lt;p&gt;非常亮成员函数在执行的过程中是有可能修改掉常量成员函数中的值的。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Sample&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;GetValue&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;	&lt;/span&gt;&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	Sample() &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; Sample::GetValue() &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    value = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//wrong,不能修改成员变量的值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    func();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//wrong,不能调用同类的非常量成员函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; Sample o;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    o.value = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;;	&lt;span class=&quot;comment&quot;&gt;//err,不能修改成员变量的值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    o.func();		&lt;span class=&quot;comment&quot;&gt;//err,不能调用同类的非常量成员函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    o.GetValue();	&lt;span class=&quot;comment&quot;&gt;//ok,可以执行常量成员函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h2 id=&quot;常量成员函数的重载&quot;&gt;&lt;a href=&quot;#常量成员函数的重载&quot; class=&quot;headerlink&quot; title=&quot;常量成员函数的重载&quot;&gt;&lt;/a&gt;常量成员函数的重载&lt;/h2&gt;&lt;p&gt;两个成员函数，名字和参数表都一样，但是一个是&lt;code&gt;const&lt;/code&gt;，一个不是，算&lt;font color=&quot;red&quot;&gt;重载&lt;/font&gt;，而不是&lt;font color=&quot;red&quot;&gt;重复定义&lt;/font&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CTest&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	CTest()	&amp;#123; n = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; ;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;GetValue&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; n; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;GetValue&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; * n; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;comment&quot;&gt;//这两个GetValue()函数是重载关系，而不是重复定义&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; CTest objTest1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CTest objTest2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; objTest1.GetValue() &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;, &quot;&lt;/span&gt; &amp;lt;&amp;lt; objTest2.GetValue();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//objTest1是常量对象，调用的是GetValue() const&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//objTest2是非常量对象，调用的是GetValue()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h2 id=&quot;常引用&quot;&gt;&lt;a href=&quot;#常引用&quot; class=&quot;headerlink&quot; title=&quot;常引用&quot;&gt;&lt;/a&gt;常引用&lt;/h2&gt;&lt;p&gt;引用前面可以加&lt;code&gt;const&lt;/code&gt;关键字，成为常引用。不能通过常引用，修改其引用的变量。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &amp;amp;r = n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;r = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;;	&lt;span class=&quot;comment&quot;&gt;//error&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;n = &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;;	&lt;span class=&quot;comment&quot;&gt;//OK&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="OOP" scheme="https://G-SS-Hacker.github.io/tags/OOP/"/>
    
      <category term="C-plus-plus" scheme="https://G-SS-Hacker.github.io/tags/C-plus-plus/"/>
    
      <category term="面向对象" scheme="https://G-SS-Hacker.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++复制构造函数</title>
    <link href="https://g-ss-hacker.github.io/C-%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <id>https://g-ss-hacker.github.io/C-%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</id>
    <published>2019-12-04T12:55:34.000Z</published>
    <updated>2019-12-07T02:50:40.328Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/12/04/BtpLFjvfUKwGqTV.jpg" alt></p><h1 id="C-复制构造函数"><a href="#C-复制构造函数" class="headerlink" title="C++复制构造函数"></a>C++复制构造函数</h1><blockquote><p>图：广州天河CBD</p></blockquote><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><p></p><font color="#FF7F27">本文整理自《北京大学公开课：C++面向对象程序设计》</font><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>只有一个参数，即对同类对象的引用</li><li>形如<code>X::X(X &amp;)</code>或<code>X::X(const X &amp;)</code>，二者选一，后者能以常量对象作为参数</li><li>如果没有定义复制构造函数，那么编译器生成默认的复制构造函数。默认的复制构造函数完成复制功能</li></ul><hr><h2 id="构造函数与复制构造函数的异同"><a href="#构造函数与复制构造函数的异同" class="headerlink" title="构造函数与复制构造函数的异同"></a>构造函数与复制构造函数的异同</h2><ul><li>构造函数（或称无参构造函数）不一定存在，你不写构造函数，编译器就只会帮你生成一个什么也不做的无参构造函数</li><li>复制构造函数一定存在，你不写复制构造函数，编译器也会帮你写好一个具有复制功能的复制构造函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    douebl real, imag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Complex c1;<span class="comment">//调用缺省的构造函数</span></span><br><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(c1)</span></span>;<span class="comment">//调用缺省的复制构造函数，将c2初始化成和c1一样</span></span><br></pre></td></tr></table></figure><ul><li>如果定义了自己的复制构造函数，则默认的复制构造函数不存在</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> real, imag;</span><br><span class="line">    Complex()&#123;&#125;</span><br><span class="line">    Complex(<span class="keyword">const</span> Complex &amp;c)</span><br><span class="line">        &#123;</span><br><span class="line">            real = c.real;</span><br><span class="line">            imag = c.imag;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Copy constructor called"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Complex c1;</span><br><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(c1)</span></span>;</span><br><span class="line"><span class="comment">//调用自己定义过的复制构造函数，输出Copy constructor called</span></span><br></pre></td></tr></table></figure><hr><h2 id="特别强调1"><a href="#特别强调1" class="headerlink" title="特别强调1"></a>特别强调1</h2><p>注意：不允许有形如<code>X::X(X)</code>的复制构造函数，参数一定是引用，不能是对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    CSample(CSample c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//错，不允许出现这样的复制构造函数</span></span><br><span class="line">        <span class="comment">//这样写的话，下面的内容要么变成了构造函数，要么语法是错误的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="复制构造函数起作用的三种情况"><a href="#复制构造函数起作用的三种情况" class="headerlink" title="复制构造函数起作用的三种情况"></a>复制构造函数起作用的三种情况</h2><h3 id="（1）当用一个对象去初始化同类的另一个对象时"><a href="#（1）当用一个对象去初始化同类的另一个对象时" class="headerlink" title="（1）当用一个对象去初始化同类的另一个对象时"></a>（1）当用一个对象去初始化同类的另一个对象时</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(c1)</span></span>;</span><br><span class="line">Complex c2 = c1; <span class="comment">//初始化语句，非赋值语句，与上面写法是等价的</span></span><br></pre></td></tr></table></figure><h3 id="（2）当某函数有一个参数是类A的对象时"><a href="#（2）当某函数有一个参数是类A的对象时" class="headerlink" title="（2）当某函数有一个参数是类A的对象时"></a>（2）当某函数有一个参数是类A的对象时</h3><p>那么该函数被调用时，类<code>A</code>的复制构造函数将被调用。<code>C++</code>规则：形参是实参的拷贝</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    A()&#123;&#125;;</span><br><span class="line">    A(A &amp;a)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Copy constructor called"</span> &lt;&lt; <span class="built_in">endl</span>;    </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(A a1)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a2;</span><br><span class="line">    Func(a2);</span><br><span class="line">    </span><br><span class="line">    retrun <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">Copy constructor called</span><br></pre></td></tr></table></figure><h3 id="（3）当函数的返回值是类A的对象时"><a href="#（3）当函数的返回值是类A的对象时" class="headerlink" title="（3）当函数的返回值是类A的对象时"></a>（3）当函数的返回值是类A的对象时</h3><p>那么在函数返回时，<code>A</code>的复制构造函数被调用，作用是初始化作为返回值的类<code>A</code>对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    A(<span class="keyword">int</span> n)&#123;v = n&#125;;</span><br><span class="line">    A(<span class="keyword">const</span> A &amp;a)</span><br><span class="line">    &#123;</span><br><span class="line">        v = a.v;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Copy constructor called"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A.Func()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">A <span class="title">b</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Func().v &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//此处Func()的返回值没有名字，是一个复制构造函数初始化的对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">Copy constructor called</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><hr><a id="more"></a><h2 id="特别强调2"><a href="#特别强调2" class="headerlink" title="特别强调2"></a>特别强调2</h2><p>注意：对象间赋值并不导致复制构造函数被调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    CMyClass()&#123;&#125;;</span><br><span class="line">    CMyClass(CMyClass &amp;c)&#123; n = <span class="number">2</span> * c.n; &#125;</span><br><span class="line">    <span class="comment">//不推荐复制构造函数这样写，此处仅用于凸显调用复制构造函数与对象间赋值的区别</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CMyClass c1, c2;</span><br><span class="line">    c1.n = <span class="number">5</span>;</span><br><span class="line">    c2 = c1;<span class="comment">//这是赋值语句</span></span><br><span class="line">    <span class="function">CMyClass <span class="title">c3</span><span class="params">(c1)</span></span>;<span class="comment">//调用复制构造函数，c3并没有变得跟c1一样</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c2.n &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c3.n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="number">5</span>, <span class="number">10</span></span><br></pre></td></tr></table></figure><hr><h2 id="定义函数时常量引用参数的使用"><a href="#定义函数时常量引用参数的使用" class="headerlink" title="定义函数时常量引用参数的使用"></a>定义函数时常量引用参数的使用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(CMyClass obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"fun"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这样的函数，调用时生成形参会引发复制构造函数调用，复制一遍时间开销比较大</li><li>所以可以考虑使用<code>CMyClass &amp;</code> 引用类型作为参数，本质上与实参是一样的</li><li>如果希望确保实参的值在函数中不应被改变，那么可以加上<code>const</code>关键字，这样的话如果你定义的函数中出现了改变实参的值得语句。编译器就会报错</li></ul><blockquote><p>我自己写的程序难道我自己不记得我没有改过参数吗？的确，你现在记得，明天也记得，但以后再改你的程序，就未必记得了。从代码规范的角度来讲，加上<code>const</code>关键字是必要的</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">const</span> CMyClass &amp;obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如此一来，函数中任何试图改变obj值得语句都将是非法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="思考：为什么要自己写复制构造函数？"><a href="#思考：为什么要自己写复制构造函数？" class="headerlink" title="思考：为什么要自己写复制构造函数？"></a>思考：为什么要自己写复制构造函数？</h2><blockquote><p>想通这个问题是高难度操作，作者水平有限，无法清晰地回答，仅提供参考链接。</p></blockquote><p>前置知识：</p><ul><li>深拷贝、浅拷贝</li><li>传值、传地址、传引用</li></ul><p>参考链接：</p><ul><li><a href="https://www.cnblogs.com/qianqiannian/p/8946769.html" target="_blank" rel="noopener">为什么需要拷贝构造函数</a></li><li><a href="https://blog.csdn.net/qq_29344757/article/details/76037255" target="_blank" rel="noopener">c++的默认拷贝构造函数，从深度拷贝和浅拷贝说起</a></li><li><a href="https://blog.csdn.net/mist99/article/details/24660173" target="_blank" rel="noopener">为什么要自己写构造函数和析构函数</a></li><li><a href="https://blog.csdn.net/RealOnlyme/article/details/7272051" target="_blank" rel="noopener">使用缺省的拷贝构造函数带来的危险性</a></li><li><a href="https://www.cnblogs.com/xuewangkai/p/11152377.html" target="_blank" rel="noopener">值传递 引用传递（传地址，传引用）的区别</a></li></ul><hr><blockquote><p>参考并整理自《C++面向对象设计》郭炜，北京大学，感谢原作者！编辑时有删改</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/04/BtpLFjvfUKwGqTV.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;C-复制构造函数&quot;&gt;&lt;a href=&quot;#C-复制构造函数&quot; class=&quot;headerlink&quot; title=&quot;C++复制构造函数&quot;&gt;&lt;/a&gt;C++复制构造函数&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;图：广州天河CBD&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;font color=&quot;#FF7F27&quot;&gt;本文整理自《北京大学公开课：C++面向对象程序设计》&lt;/font&gt;

&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;只有一个参数，即对同类对象的引用&lt;/li&gt;
&lt;li&gt;形如&lt;code&gt;X::X(X &amp;amp;)&lt;/code&gt;或&lt;code&gt;X::X(const X &amp;amp;)&lt;/code&gt;，二者选一，后者能以常量对象作为参数&lt;/li&gt;
&lt;li&gt;如果没有定义复制构造函数，那么编译器生成默认的复制构造函数。默认的复制构造函数完成复制功能&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;构造函数与复制构造函数的异同&quot;&gt;&lt;a href=&quot;#构造函数与复制构造函数的异同&quot; class=&quot;headerlink&quot; title=&quot;构造函数与复制构造函数的异同&quot;&gt;&lt;/a&gt;构造函数与复制构造函数的异同&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;构造函数（或称无参构造函数）不一定存在，你不写构造函数，编译器就只会帮你生成一个什么也不做的无参构造函数&lt;/li&gt;
&lt;li&gt;复制构造函数一定存在，你不写复制构造函数，编译器也会帮你写好一个具有复制功能的复制构造函数&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Complex&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	douebl real, imag;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Complex c1;		&lt;span class=&quot;comment&quot;&gt;//调用缺省的构造函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;Complex &lt;span class=&quot;title&quot;&gt;c2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(c1)&lt;/span&gt;&lt;/span&gt;;	&lt;span class=&quot;comment&quot;&gt;//调用缺省的复制构造函数，将c2初始化成和c1一样&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;如果定义了自己的复制构造函数，则默认的复制构造函数不存在&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Complex&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; real, imag;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	Complex()	&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	Complex(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; Complex &amp;amp;c)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            real = c.real;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            imag = c.imag;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;Copy constructor called&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Complex c1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;Complex &lt;span class=&quot;title&quot;&gt;c2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(c1)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//调用自己定义过的复制构造函数，输出Copy constructor called&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h2 id=&quot;特别强调1&quot;&gt;&lt;a href=&quot;#特别强调1&quot; class=&quot;headerlink&quot; title=&quot;特别强调1&quot;&gt;&lt;/a&gt;特别强调1&lt;/h2&gt;&lt;p&gt;注意：不允许有形如&lt;code&gt;X::X(X)&lt;/code&gt;的复制构造函数，参数一定是引用，不能是对象&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CSample&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CSample(CSample c)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//错，不允许出现这样的复制构造函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//这样写的话，下面的内容要么变成了构造函数，要么语法是错误的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h2 id=&quot;复制构造函数起作用的三种情况&quot;&gt;&lt;a href=&quot;#复制构造函数起作用的三种情况&quot; class=&quot;headerlink&quot; title=&quot;复制构造函数起作用的三种情况&quot;&gt;&lt;/a&gt;复制构造函数起作用的三种情况&lt;/h2&gt;&lt;h3 id=&quot;（1）当用一个对象去初始化同类的另一个对象时&quot;&gt;&lt;a href=&quot;#（1）当用一个对象去初始化同类的另一个对象时&quot; class=&quot;headerlink&quot; title=&quot;（1）当用一个对象去初始化同类的另一个对象时&quot;&gt;&lt;/a&gt;（1）当用一个对象去初始化同类的另一个对象时&lt;/h3&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;Complex &lt;span class=&quot;title&quot;&gt;c2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(c1)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Complex c2 = c1; 	&lt;span class=&quot;comment&quot;&gt;//初始化语句，非赋值语句，与上面写法是等价的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;（2）当某函数有一个参数是类A的对象时&quot;&gt;&lt;a href=&quot;#（2）当某函数有一个参数是类A的对象时&quot; class=&quot;headerlink&quot; title=&quot;（2）当某函数有一个参数是类A的对象时&quot;&gt;&lt;/a&gt;（2）当某函数有一个参数是类A的对象时&lt;/h3&gt;&lt;p&gt;那么该函数被调用时，类&lt;code&gt;A&lt;/code&gt;的复制构造函数将被调用。&lt;code&gt;C++&lt;/code&gt;规则：形参是实参的拷贝&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;A&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	A()	&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	A(A &amp;amp;a)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        	&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;Copy constructor called&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Func&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(A a1)&lt;/span&gt;	&lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    A a2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Func(a2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    retrun &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//输出：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Copy constructor called&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;（3）当函数的返回值是类A的对象时&quot;&gt;&lt;a href=&quot;#（3）当函数的返回值是类A的对象时&quot; class=&quot;headerlink&quot; title=&quot;（3）当函数的返回值是类A的对象时&quot;&gt;&lt;/a&gt;（3）当函数的返回值是类A的对象时&lt;/h3&gt;&lt;p&gt;那么在函数返回时，&lt;code&gt;A&lt;/code&gt;的复制构造函数被调用，作用是初始化作为返回值的类&lt;code&gt;A&lt;/code&gt;对象&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;A&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; v;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    A(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n)	&amp;#123;v = n&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    A(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; A &amp;amp;a)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        v = a.v;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;Copy constructor called&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;A.Func()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;A &lt;span class=&quot;title&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; Func().v &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//此处Func()的返回值没有名字，是一个复制构造函数初始化的对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//输出：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Copy constructor called&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="OOP" scheme="https://G-SS-Hacker.github.io/tags/OOP/"/>
    
      <category term="C-plus-plus" scheme="https://G-SS-Hacker.github.io/tags/C-plus-plus/"/>
    
      <category term="面向对象" scheme="https://G-SS-Hacker.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++构造函数</title>
    <link href="https://g-ss-hacker.github.io/C-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <id>https://g-ss-hacker.github.io/C-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</id>
    <published>2019-12-04T09:10:38.000Z</published>
    <updated>2019-12-07T02:50:36.293Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.mp.itc.cn/upload/20170616/3e26b0c84ed64d5e9c6d533178122240_th.jpg" alt></p><h1 id="C-构造参数"><a href="#C-构造参数" class="headerlink" title="C++ 构造参数"></a>C++ 构造参数</h1><blockquote><p>图：深圳福田CBD</p></blockquote><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><p></p><font color="#FF7F27">本文整理自《北京大学公开课：C++面向对象程序设计》</font><h2 id="构造函数的性质"><a href="#构造函数的性质" class="headerlink" title="构造函数的性质"></a>构造函数的性质</h2><ul><li>构造参数是成员函数的一种</li><li>名字与类名相同，可以由参数，不能有返回值（<code>void</code>也不行）</li><li>作用是对对象进行初始化，如给成员变量赋初值</li><li>如果定义类的时候没写构造函数，则编译器生成一个默认的无参数的构造函数</li><li>默认构造函数无参数，不进行任何操作</li><li>如果定义了构造函数，则编译器不生成默认的无参数的构造函数</li><li>对象生成时构造函数被自动调用。对象一旦生成，就再也不能在其上执行构造函数</li><li>一个类可以有多个构造函数</li></ul><p>注：如果只定义了带参构造函数，在定义对象时必须声明参数</p><h2 id="为什么需要构造函数："><a href="#为什么需要构造函数：" class="headerlink" title="为什么需要构造函数："></a>为什么需要构造函数：</h2><ul><li>不用专门写初始化函数，也不用担心忘记</li><li>有时对象没有被初始化，会导致程序出错</li></ul><h2 id="构造函数的使用"><a href="#构造函数的使用" class="headerlink" title="构造函数的使用"></a>构造函数的使用</h2><h3 id="一个类可以有一个构造函数"><a href="#一个类可以有一个构造函数" class="headerlink" title="一个类可以有一个构造函数"></a>一个类可以有一个构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> radius, xLoc, yLoc;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Circle(<span class="keyword">double</span> r ,<span class="keyword">double</span> x = <span class="number">0</span>, y = <span class="number">0</span>)</span><br><span class="line">&#125;;</span><br><span class="line">Circle::Circle(<span class="keyword">double</span> r, <span class="keyword">double</span> x, <span class="keyword">double</span> y)</span><br><span class="line">&#123;</span><br><span class="line">    radius = r, xLoc = x, yLoc = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Wrong samples</span></span><br><span class="line">Circle c1;<span class="comment">//error,缺少构造函数的参数</span></span><br><span class="line">Circle *pc = <span class="keyword">new</span> Circle;<span class="comment">//error，没有参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Correct samples</span></span><br><span class="line"><span class="function">Circle <span class="title">c1</span><span class="params">(<span class="number">2</span>)</span></span>;<span class="comment">//OK</span></span><br><span class="line"><span class="function">Circle <span class="title">c1</span><span class="params">(<span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>)</span></span>;<span class="comment">//OK</span></span><br><span class="line">Circle *pc = <span class="keyword">new</span> Circle(<span class="number">3</span>, <span class="number">4</span>);<span class="comment">//also OK</span></span><br></pre></td></tr></table></figure><h3 id="一个类可以有多个构造函数"><a href="#一个类可以有多个构造函数" class="headerlink" title="一个类可以有多个构造函数"></a>一个类可以有多个构造函数</h3><p>只要不同的构造函数的参数个数和参数类型不同，这些构造函数就会构成重载的关系</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> radius, xLoc, yLoc;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Circle(<span class="keyword">double</span> r ,<span class="keyword">double</span> x = <span class="number">0</span>, y = <span class="number">0</span>)</span><br><span class="line">        Circle(<span class="keyword">double</span> r);</span><br><span class="line">    Circle(Circle c1, Circle c2)</span><br><span class="line">&#125;;</span><br><span class="line">Circle::Circle(<span class="keyword">double</span> r, <span class="keyword">double</span> x, <span class="keyword">double</span> y)</span><br><span class="line">&#123;</span><br><span class="line">    radius = r, xLoc = x, yLoc = y;</span><br><span class="line">&#125;</span><br><span class="line">Circle::Circle(<span class="keyword">double</span> r)</span><br><span class="line">&#123;</span><br><span class="line">    radius = r;</span><br><span class="line">&#125;</span><br><span class="line">Circle::Circle(Circle c1, Circle c2)</span><br><span class="line">&#123;</span><br><span class="line">    radius = c1.radius + c2.radius;</span><br><span class="line">    xLoc   = c1.xLOc   + c2.xLoc;</span><br><span class="line">    yLoc   = c1.yLOc   + c2.yLoc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Samples</span></span><br><span class="line">Circle c1(3), c2(1, 0), c3(c1, c2);</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="构造函数在数组的使用（1）"><a href="#构造函数在数组的使用（1）" class="headerlink" title="构造函数在数组的使用（1）"></a>构造函数在数组的使用（1）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    CSample()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Constructor 1 Called"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    CSample(<span class="keyword">int</span> n)</span><br><span class="line">        &#123;</span><br><span class="line">            x = n;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Constructor 2 Called"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"step1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    CSample array1[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"step2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    CSample array2[<span class="number">2</span>] = &#123;<span class="number">4</span>, <span class="number">5</span>&#125;;    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"step3"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    CSample array3[<span class="number">2</span>] = &#123;<span class="number">3</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"step4"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    CSample *array4 = <span class="keyword">new</span> CSample[<span class="number">2</span>];<span class="comment">//随机生成两个元素的数组</span></span><br><span class="line">    <span class="keyword">delete</span> []array4;<span class="comment">//解除空间占用</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">step1<span class="comment">//对两个对象初始化的参数没有作任何交代，编译器就认为这个对象就应该用无参的构造函数初始化</span></span><br><span class="line">Constructor <span class="number">1</span> Called</span><br><span class="line">Constructor <span class="number">1</span> Called</span><br><span class="line">step2<span class="comment">//对两个对象初始化的参数都有交代</span></span><br><span class="line">Constructor <span class="number">2</span> Called</span><br><span class="line">Constructor <span class="number">2</span> Called</span><br><span class="line">step3<span class="comment">//只对第一个对象初始化的参数作了交代</span></span><br><span class="line">Constructor <span class="number">2</span> Called</span><br><span class="line">Constructor <span class="number">1</span> Called</span><br><span class="line">step4<span class="comment">//对两个对象初始化的参数没有作任何交代</span></span><br><span class="line">Constructor <span class="number">1</span> Called</span><br><span class="line">Constructor <span class="number">1</span> Called</span><br></pre></td></tr></table></figure><h3 id="构造函数在数组的使用（2）"><a href="#构造函数在数组的使用（2）" class="headerlink" title="构造函数在数组的使用（2）"></a>构造函数在数组的使用（2）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Test(<span class="keyword">int</span> n)&#123;&#125;<span class="comment">//(1)</span></span><br><span class="line">    Test(<span class="keyword">int</span> n, <span class="keyword">int</span> m)&#123;&#125;<span class="comment">//(2)</span></span><br><span class="line">    Test()&#123;&#125;<span class="comment">//(3)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Test array1[<span class="number">3</span>] = &#123;<span class="number">1</span>, Test(<span class="number">1</span>,<span class="number">2</span>)&#125;;</span><br><span class="line"><span class="comment">//三个元素分别用(1)，(2)，(3)初始化</span></span><br><span class="line"></span><br><span class="line">Test array2[<span class="number">3</span>] = &#123;Test(<span class="number">2</span>, <span class="number">3</span>), Test(<span class="number">1</span>, <span class="number">2</span>), <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">//三个元素分别用(2)，(2)，(1)初始化</span></span><br><span class="line"></span><br><span class="line">Test *pArray1[<span class="number">3</span>];</span><br><span class="line"><span class="comment">//仅仅这么定义是不会导致对象生成的，不会引发Test的构造函数被调用。</span></span><br><span class="line"><span class="comment">//*pArray1[3]仅仅是指针而已，不会产生任何对象</span></span><br><span class="line"></span><br><span class="line">Test *pArray2[<span class="number">3</span>] = &#123;<span class="keyword">new</span> Test(<span class="number">4</span>), <span class="keyword">new</span> Test(<span class="number">1</span>, <span class="number">2</span>)&#125;;</span><br><span class="line"><span class="comment">//对指针数组的前两个元素初始化，方法是new两个对象，返回值是指针，用new的两个对象的地址去初始化数组pArray2[3]的前两个元素。</span></span><br><span class="line"><span class="comment">//注意这个语句只生成了两个对象，pArray2[2]还是一个指针，无从得知它的指针指向哪里，它的生成并不会导致任何对象的生成。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意在使用中，指针数组与数组的区别</span></span><br></pre></td></tr></table></figure><hr><blockquote><p>参考并整理自《C++面向对象程序设计》郭炜，北京大学，感谢原作者！编辑时有删改</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.mp.itc.cn/upload/20170616/3e26b0c84ed64d5e9c6d533178122240_th.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;C-构造参数&quot;&gt;&lt;a href=&quot;#C-构造参数&quot; class=&quot;headerlink&quot; title=&quot;C++ 构造参数&quot;&gt;&lt;/a&gt;C++ 构造参数&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;图：深圳福田CBD&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;font color=&quot;#FF7F27&quot;&gt;本文整理自《北京大学公开课：C++面向对象程序设计》&lt;/font&gt;

&lt;h2 id=&quot;构造函数的性质&quot;&gt;&lt;a href=&quot;#构造函数的性质&quot; class=&quot;headerlink&quot; title=&quot;构造函数的性质&quot;&gt;&lt;/a&gt;构造函数的性质&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;构造参数是成员函数的一种&lt;/li&gt;
&lt;li&gt;名字与类名相同，可以由参数，不能有返回值（&lt;code&gt;void&lt;/code&gt;也不行）&lt;/li&gt;
&lt;li&gt;作用是对对象进行初始化，如给成员变量赋初值&lt;/li&gt;
&lt;li&gt;如果定义类的时候没写构造函数，则编译器生成一个默认的无参数的构造函数&lt;/li&gt;
&lt;li&gt;默认构造函数无参数，不进行任何操作&lt;/li&gt;
&lt;li&gt;如果定义了构造函数，则编译器不生成默认的无参数的构造函数&lt;/li&gt;
&lt;li&gt;对象生成时构造函数被自动调用。对象一旦生成，就再也不能在其上执行构造函数&lt;/li&gt;
&lt;li&gt;一个类可以有多个构造函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注：如果只定义了带参构造函数，在定义对象时必须声明参数&lt;/p&gt;
&lt;h2 id=&quot;为什么需要构造函数：&quot;&gt;&lt;a href=&quot;#为什么需要构造函数：&quot; class=&quot;headerlink&quot; title=&quot;为什么需要构造函数：&quot;&gt;&lt;/a&gt;为什么需要构造函数：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;不用专门写初始化函数，也不用担心忘记&lt;/li&gt;
&lt;li&gt;有时对象没有被初始化，会导致程序出错&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;构造函数的使用&quot;&gt;&lt;a href=&quot;#构造函数的使用&quot; class=&quot;headerlink&quot; title=&quot;构造函数的使用&quot;&gt;&lt;/a&gt;构造函数的使用&lt;/h2&gt;&lt;h3 id=&quot;一个类可以有一个构造函数&quot;&gt;&lt;a href=&quot;#一个类可以有一个构造函数&quot; class=&quot;headerlink&quot; title=&quot;一个类可以有一个构造函数&quot;&gt;&lt;/a&gt;一个类可以有一个构造函数&lt;/h3&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Circle&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; radius, xLoc, yLoc;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	Circle(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; r ,&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; x = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, y = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Circle::Circle(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; r, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; x, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; y)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    radius = r, xLoc = x, yLoc = y;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//Wrong samples&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Circle c1;	&lt;span class=&quot;comment&quot;&gt;//error,缺少构造函数的参数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Circle *pc = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Circle;	&lt;span class=&quot;comment&quot;&gt;//error，没有参数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//Correct samples&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;Circle &lt;span class=&quot;title&quot;&gt;c1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;	&lt;span class=&quot;comment&quot;&gt;//OK&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;Circle &lt;span class=&quot;title&quot;&gt;c1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;	&lt;span class=&quot;comment&quot;&gt;//OK&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Circle *pc = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Circle(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;);	&lt;span class=&quot;comment&quot;&gt;//also OK&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;一个类可以有多个构造函数&quot;&gt;&lt;a href=&quot;#一个类可以有多个构造函数&quot; class=&quot;headerlink&quot; title=&quot;一个类可以有多个构造函数&quot;&gt;&lt;/a&gt;一个类可以有多个构造函数&lt;/h3&gt;&lt;p&gt;只要不同的构造函数的参数个数和参数类型不同，这些构造函数就会构成重载的关系&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Circle&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; radius, xLoc, yLoc;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	Circle(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; r ,&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; x = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, y = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Circle(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; r);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	Circle(Circle c1, Circle c2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Circle::Circle(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; r, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; x, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; y)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    radius = r, xLoc = x, yLoc = y;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Circle::Circle(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; r)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    radius = r;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Circle::Circle(Circle c1, Circle c2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    radius = c1.radius + c2.radius;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    xLoc   = c1.xLOc   + c2.xLoc;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    yLoc   = c1.yLOc   + c2.yLoc;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//Samples&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Circle c1(3), c2(1, 0), c3(c1, c2);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="OOP" scheme="https://G-SS-Hacker.github.io/tags/OOP/"/>
    
      <category term="C-plus-plus" scheme="https://G-SS-Hacker.github.io/tags/C-plus-plus/"/>
    
      <category term="面向对象" scheme="https://G-SS-Hacker.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
</feed>
