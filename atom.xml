<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>G-SS-Hacker</title>
  
  <subtitle>---A Cyber Driver---</subtitle>
  <link href="/G-SS-Hacker.github.io/atom.xml" rel="self"/>
  
  <link href="https://g-ss-hacker.github.io/"/>
  <updated>2019-12-02T13:46:09.482Z</updated>
  <id>https://g-ss-hacker.github.io/</id>
  
  <author>
    <name>G-SS-Hacker</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>不定积分公式</title>
    <link href="https://g-ss-hacker.github.io/%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E5%85%AC%E5%BC%8F/"/>
    <id>https://g-ss-hacker.github.io/%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E5%85%AC%E5%BC%8F/</id>
    <published>2019-12-01T12:50:06.000Z</published>
    <updated>2019-12-02T13:46:09.482Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/12/01/hMmSsvG2xVE7K5p.png" alt></p><h1 id="不定积分公式"><a href="#不定积分公式" class="headerlink" title="不定积分公式"></a>不定积分公式</h1><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><br>$(1)\int0 \mathrm{dx} = C$<p></p><p>$(2)\int1\mathrm{dx}=x+C$</p><p>$(3)\int x^\mu \mathrm{dx}=\frac1{\mu+1}x^{\mu+1}+C(\mu \ne -1)$</p><p>$(4)\int\frac1{x}\mathrm{dx}=\ln|x|+C$</p><p>$(5)\int a^x \mathrm{dx}=\frac{a^x}{\ln a}+C$</p><p>$(6)\int e^x \mathrm{dx}=e^x+C$</p><p>$(7)\int \sin x \mathrm{dx}=-\cos x +C$</p><p>$(8)\int \cos x \mathrm{dx}=\sin x +C$</p><p>$(9)\int \sec^2 x \mathrm{dx}=\int \frac1{\cos^2 x}\mathrm{dx}=\tan x+C$</p><p>$(10)\int \csc^2x\mathrm{dx}=\int \frac1{\sin^2x}\mathrm{dx}=-\cot x +C$</p><p>$(11)\int\sec x\tan x\mathrm{dx}=\sec x+C$</p><p>$(12)\int \csc x\cot x\mathrm{dx}=-\csc x +C$</p><p>$(13)\int \frac{\mathrm{dx}}{\sqrt{1-x^2}}=\arcsin x+C$</p><p>$(14)\int \frac{\mathrm{dx}}{1+x^2}=\arctan x+C$</p><p>$(15)\int \tan x\mathrm{dx}=-\ln|\cos x|+C$</p><p>$(16)\int \cot x \mathrm{dx}=\ln|\sin x|+C$</p><p>$(17)\int \sec x \mathrm{dx}=\ln|\sec x+\tan x|+C$</p><p>$(18)\int \csc x\mathrm{dx}=\ln|\csc x -\cot x|+C$</p><p>$(19)\int \frac{\mathrm{dx}}{x^2+a^2}=\frac1{a}\arctan {\frac{x}{a}}+C$</p><p>$(20)\int \frac{\mathrm{dx}}{x^2-a^2}=\frac1{2a}\ln|\frac{x-a}{x+a}|+C$</p><p>$(21)\int \frac{\mathrm{dx}}{\sqrt{a^2-x^2}}=\arcsin \frac{x}{a}+C$</p><p>$(22)\int \frac{\mathrm{dx}}{\sqrt{x^2\pm a^2}}=\ln|x+\sqrt{x^2\pm a^2}|+C$</p><p>$(23)\int \sqrt{a^2-x^2}\mathrm{dx}=\frac{x}{2}\sqrt{a^2-x^2}+\frac{a^2}{2}\arcsin \frac{x}{a}+C$</p><p>$(24)\int \sqrt{x^2\pm a^2}\mathrm{dx}=\frac{x}{2}\sqrt{x^2\pm a^2}\pm \frac{a^2}{2}\ln|x+\sqrt{x^2\pm a^2}|+C$</p><p>$(25)\int \ln x\mathrm{dx}=x\ln x-x+C$</p><a id="more"></a><hr><p>~<font color="#FF7F27"><strong>我们遇到什么困难也不要怕，微笑着面对它！消除恐惧的最好办法就是面对恐惧！坚持就是胜利！加油！奥利给！</strong></font>~</p><font color="#407600">【其他文章·微积分·线性代数】</font><ul><li>[不定积分公式](<a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/不定积分公式/">https://g-ss-hacker.github.io/G-SS-Hacker.github.io/不定积分公式/</a></li></ul><ul><li>[常用泰勒展开式](<a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/常用泰勒展开式/">https://g-ss-hacker.github.io/G-SS-Hacker.github.io/常用泰勒展开式/</a></li><li>[高阶求导公式](<a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/高阶求导公式/">https://g-ss-hacker.github.io/G-SS-Hacker.github.io/高阶求导公式/</a></li><li>[高等数学公式](<a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/高等数学公式/">https://g-ss-hacker.github.io/G-SS-Hacker.github.io/高等数学公式/</a></li><li>[常用等价无穷小](<a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/常用等价无穷小/">https://g-ss-hacker.github.io/G-SS-Hacker.github.io/常用等价无穷小/</a></li><li>[导数基本公式](<a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/导数基本公式/">https://g-ss-hacker.github.io/G-SS-Hacker.github.io/导数基本公式/</a></li></ul><ul><li><p>[矩阵章节总结](<a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/矩阵章节总结/">https://g-ss-hacker.github.io/G-SS-Hacker.github.io/矩阵章节总结/</a></p></li><li><p>[行列式章节总结](<a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/行列式章节总结/">https://g-ss-hacker.github.io/G-SS-Hacker.github.io/行列式章节总结/</a></p></li><li>[线性方程组章节总结](<a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/线性方程组章节总结/">https://g-ss-hacker.github.io/G-SS-Hacker.github.io/线性方程组章节总结/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/01/hMmSsvG2xVE7K5p.png&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;不定积分公式&quot;&gt;&lt;a href=&quot;#不定积分公式&quot; class=&quot;headerlink&quot; title=&quot;不定积分公式&quot;&gt;&lt;/a&gt;不定积分公式&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;br&gt;$(1)\int0 \mathrm{dx} = C$&lt;p&gt;&lt;/p&gt;
&lt;p&gt;$(2)\int1\mathrm{dx}=x+C$&lt;/p&gt;
&lt;p&gt;$(3)\int x^\mu \mathrm{dx}=\frac1{\mu+1}x^{\mu+1}+C(\mu \ne -1)$&lt;/p&gt;
&lt;p&gt;$(4)\int\frac1{x}\mathrm{dx}=\ln|x|+C$&lt;/p&gt;
&lt;p&gt;$(5)\int a^x \mathrm{dx}=\frac{a^x}{\ln a}+C$&lt;/p&gt;
&lt;p&gt;$(6)\int e^x \mathrm{dx}=e^x+C$&lt;/p&gt;
&lt;p&gt;$(7)\int \sin x \mathrm{dx}=-\cos x +C$&lt;/p&gt;
&lt;p&gt;$(8)\int \cos x \mathrm{dx}=\sin x +C$&lt;/p&gt;
&lt;p&gt;$(9)\int \sec^2 x \mathrm{dx}=\int \frac1{\cos^2 x}\mathrm{dx}=\tan x+C$&lt;/p&gt;
&lt;p&gt;$(10)\int \csc^2x\mathrm{dx}=\int \frac1{\sin^2x}\mathrm{dx}=-\cot x +C$&lt;/p&gt;
&lt;p&gt;$(11)\int\sec x\tan x\mathrm{dx}=\sec x+C$&lt;/p&gt;
&lt;p&gt;$(12)\int \csc x\cot x\mathrm{dx}=-\csc x +C$&lt;/p&gt;
&lt;p&gt;$(13)\int \frac{\mathrm{dx}}{\sqrt{1-x^2}}=\arcsin x+C$&lt;/p&gt;
&lt;p&gt;$(14)\int \frac{\mathrm{dx}}{1+x^2}=\arctan x+C$&lt;/p&gt;
&lt;p&gt;$(15)\int \tan x\mathrm{dx}=-\ln|\cos x|+C$&lt;/p&gt;
&lt;p&gt;$(16)\int \cot x \mathrm{dx}=\ln|\sin x|+C$&lt;/p&gt;
&lt;p&gt;$(17)\int \sec x \mathrm{dx}=\ln|\sec x+\tan x|+C$&lt;/p&gt;
&lt;p&gt;$(18)\int \csc x\mathrm{dx}=\ln|\csc x -\cot x|+C$&lt;/p&gt;
&lt;p&gt;$(19)\int \frac{\mathrm{dx}}{x^2+a^2}=\frac1{a}\arctan {\frac{x}{a}}+C$&lt;/p&gt;
&lt;p&gt;$(20)\int \frac{\mathrm{dx}}{x^2-a^2}=\frac1{2a}\ln|\frac{x-a}{x+a}|+C$&lt;/p&gt;
&lt;p&gt;$(21)\int \frac{\mathrm{dx}}{\sqrt{a^2-x^2}}=\arcsin \frac{x}{a}+C$&lt;/p&gt;
&lt;p&gt;$(22)\int \frac{\mathrm{dx}}{\sqrt{x^2\pm a^2}}=\ln|x+\sqrt{x^2\pm a^2}|+C$&lt;/p&gt;
&lt;p&gt;$(23)\int \sqrt{a^2-x^2}\mathrm{dx}=\frac{x}{2}\sqrt{a^2-x^2}+\frac{a^2}{2}\arcsin \frac{x}{a}+C$&lt;/p&gt;
&lt;p&gt;$(24)\int \sqrt{x^2\pm a^2}\mathrm{dx}=\frac{x}{2}\sqrt{x^2\pm a^2}\pm \frac{a^2}{2}\ln|x+\sqrt{x^2\pm a^2}|+C$&lt;/p&gt;
&lt;p&gt;$(25)\int \ln x\mathrm{dx}=x\ln x-x+C$&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="微积分" scheme="https://G-SS-Hacker.github.io/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>线性方程组章节总结</title>
    <link href="https://g-ss-hacker.github.io/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E7%AB%A0%E8%8A%82%E6%80%BB%E7%BB%93/"/>
    <id>https://g-ss-hacker.github.io/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E7%AB%A0%E8%8A%82%E6%80%BB%E7%BB%93/</id>
    <published>2019-11-28T13:13:45.000Z</published>
    <updated>2019-12-02T13:43:44.289Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/11/28/KuIyhFR2j49xqwG.jpg" alt></p><h1 id="线性方程组章节总结"><a href="#线性方程组章节总结" class="headerlink" title="线性方程组章节总结"></a>线性方程组章节总结</h1><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><p></p><h2 id="线性方程组有解的充要条件"><a href="#线性方程组有解的充要条件" class="headerlink" title="线性方程组有解的充要条件"></a>线性方程组有解的充要条件</h2><ol><li><p>齐次线性方程组要么只有一组零解，要么有无穷多解</p></li><li><p>非齐次线性方程组有解的充要条件</p><p>$R(A)=R(A|\beta)$</p><p>注：$R(A)$和$R(A|\beta)$要么相等，要么差$1$</p></li></ol><h2 id="线性方程组解的结构"><a href="#线性方程组解的结构" class="headerlink" title="线性方程组解的结构"></a>线性方程组解的结构</h2><ol><li><p>齐次线性方程组</p><p>(1) $AX=0$只有零解 $ \Leftrightarrow R(A)$等于未知数个数$\Leftrightarrow$A为列满秩阵</p><p>(2) $AX=0$有无穷多组解 $ \Leftrightarrow R(A)$小于未知数个数</p></li><li><p>非齐次线性方程组</p><p>(1) $AX=B$ 有唯一解 $\Leftrightarrow R(A)=R(A|\beta)=n$ </p><p>(2) $AX=B$ 有无穷多组解 $\Leftrightarrow R(A)=R(A|\beta)&lt;n$</p><p>(3) $AX=B$ 无解 $\Leftrightarrow R(A) \ne R(A|\beta)$</p></li></ol><p>注：在非常严苛的条件下，以下两命题等价：$AX=B$ 有唯一解 $\Leftrightarrow $ $AX=0$只有零解（当$A$时方阵时成立）</p><h2 id="线性方程组的解"><a href="#线性方程组的解" class="headerlink" title="线性方程组的解"></a>线性方程组的解</h2><p>思想：利用矩阵初等行变换（高斯消元）</p><ol><li><p>齐次线性方程组</p><p>记$N(A)$为齐次线性方程组的全体解向量所构成的向量空间，则$\dim N(A)=n-R(A)$，称$n(A)$的基为齐次线性方程组的<strong>基础解系</strong>：</p><p>(1) 当$R(A)=n$时，齐次线性方程组只有零解，没有<strong>基础解系</strong></p><p>(2) 当$R(A)&lt;n$时，<strong>基础解系</strong>为齐次线性方程组的$n-R(A)$个线性无关的解向量</p></li><li><p>非齐次线性方程组</p><p>$AX=B$ 和 $AX=0$的解向量满足：</p><p>(1) 若$\eta_1$，$\eta_2$都是$AX=B$的解，那么$\eta_1 - \eta_2$是$AX=0$的解<del>（几乎没用）</del></p><p>(2) 若$\eta_1$是$AX=B$的解，$\eta_2$是$AX=0$的解，那么$\eta_1 + \eta_2$还是$AX=B$的解</p><a id="more"></a></li></ol><hr><p>~<font color="#FF7F27"><strong>我们遇到什么困难也不要怕，微笑着面对它！消除恐惧的最好办法就是面对恐惧！坚持就是胜利！加油！奥利给！</strong></font>~</p><font color="#407600">【其他文章·线性代数·微积分】</font><ul><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/线性方程组章节总结/">线性方程组章节总结</a></li></ul><ul><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/矩阵章节总结/">矩阵章节总结</a></li></ul><ul><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/行列式章节总结/">行列式章节总结</a></li></ul><ul><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/常用泰勒展开式/">常用泰勒展开式</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/高阶求导公式/">高阶求导公式</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/高等数学公式/">高等数学公式</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/常用等价无穷小/">常用等价无穷小</a></li><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/导数基本公式/">导数基本公式</a></li></ul><ul><li><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/不定积分公式/">不定积分公式</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/11/28/KuIyhFR2j49xqwG.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;线性方程组章节总结&quot;&gt;&lt;a href=&quot;#线性方程组章节总结&quot; class=&quot;headerlink&quot; title=&quot;线性方程组章节总结&quot;&gt;&lt;/a&gt;线性方程组章节总结&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;h2 id=&quot;线性方程组有解的充要条件&quot;&gt;&lt;a href=&quot;#线性方程组有解的充要条件&quot; class=&quot;headerlink&quot; title=&quot;线性方程组有解的充要条件&quot;&gt;&lt;/a&gt;线性方程组有解的充要条件&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;齐次线性方程组要么只有一组零解，要么有无穷多解&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;非齐次线性方程组有解的充要条件&lt;/p&gt;
&lt;p&gt;$R(A)=R(A|\beta)$&lt;/p&gt;
&lt;p&gt;注：$R(A)$和$R(A|\beta)$要么相等，要么差$1$&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;线性方程组解的结构&quot;&gt;&lt;a href=&quot;#线性方程组解的结构&quot; class=&quot;headerlink&quot; title=&quot;线性方程组解的结构&quot;&gt;&lt;/a&gt;线性方程组解的结构&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;齐次线性方程组&lt;/p&gt;
&lt;p&gt;(1) $AX=0$只有零解 $ \Leftrightarrow R(A)$等于未知数个数$\Leftrightarrow$A为列满秩阵&lt;/p&gt;
&lt;p&gt;(2) $AX=0$有无穷多组解 $ \Leftrightarrow R(A)$小于未知数个数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;非齐次线性方程组&lt;/p&gt;
&lt;p&gt;(1) $AX=B$ 有唯一解 $\Leftrightarrow R(A)=R(A|\beta)=n$ &lt;/p&gt;
&lt;p&gt;(2) $AX=B$ 有无穷多组解 $\Leftrightarrow R(A)=R(A|\beta)&amp;lt;n$&lt;/p&gt;
&lt;p&gt;(3) $AX=B$ 无解 $\Leftrightarrow R(A) \ne R(A|\beta)$&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注：在非常严苛的条件下，以下两命题等价：$AX=B$ 有唯一解 $\Leftrightarrow $ $AX=0$只有零解（当$A$时方阵时成立）&lt;/p&gt;
&lt;h2 id=&quot;线性方程组的解&quot;&gt;&lt;a href=&quot;#线性方程组的解&quot; class=&quot;headerlink&quot; title=&quot;线性方程组的解&quot;&gt;&lt;/a&gt;线性方程组的解&lt;/h2&gt;&lt;p&gt;思想：利用矩阵初等行变换（高斯消元）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;齐次线性方程组&lt;/p&gt;
&lt;p&gt;记$N(A)$为齐次线性方程组的全体解向量所构成的向量空间，则$\dim N(A)=n-R(A)$，称$n(A)$的基为齐次线性方程组的&lt;strong&gt;基础解系&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;(1) 当$R(A)=n$时，齐次线性方程组只有零解，没有&lt;strong&gt;基础解系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(2) 当$R(A)&amp;lt;n$时，&lt;strong&gt;基础解系&lt;/strong&gt;为齐次线性方程组的$n-R(A)$个线性无关的解向量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;非齐次线性方程组&lt;/p&gt;
&lt;p&gt;$AX=B$ 和 $AX=0$的解向量满足：&lt;/p&gt;
&lt;p&gt;(1) 若$\eta_1$，$\eta_2$都是$AX=B$的解，那么$\eta_1 - \eta_2$是$AX=0$的解&lt;del&gt;（几乎没用）&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;(2) 若$\eta_1$是$AX=B$的解，$\eta_2$是$AX=0$的解，那么$\eta_1 + \eta_2$还是$AX=B$的解&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="线性代数" scheme="https://G-SS-Hacker.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>模式匹配算法：KMP算法</title>
    <link href="https://g-ss-hacker.github.io/KMP%E7%AE%97%E6%B3%95/"/>
    <id>https://g-ss-hacker.github.io/KMP%E7%AE%97%E6%B3%95/</id>
    <published>2019-11-26T07:34:36.000Z</published>
    <updated>2019-12-02T13:44:47.441Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1574783133220&amp;di=3be2714c61c60e81640b949c940ab16a&amp;imgtype=0&amp;src=http%3A%2F%2Fimg.mp.itc.cn%2Fupload%2F20170613%2Fca5280ac60284d4cb01f4f81be3b448b_th.jpg" alt></p><h1 id="模式匹配算法：KMP算法"><a href="#模式匹配算法：KMP算法" class="headerlink" title="模式匹配算法：KMP算法"></a>模式匹配算法：KMP算法</h1><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><p></p><blockquote><p>模式匹配是数据结构中字符串的一种基本运算，给定一个字符串P，要求在某个字符串T中找出与字符串P相同的所有子串，这就是模式匹配。</p></blockquote><h2 id="模式匹配算法要解决的问题"><a href="#模式匹配算法要解决的问题" class="headerlink" title="模式匹配算法要解决的问题"></a>模式匹配算法要解决的问题</h2><ul><li><font color="#495DD8">detection</font> ：P<font color="#64ceaa"><strong>是否</strong></font>出现</li><li><font color="#495DD8">location</font> ：首次<font color="#64ceaa"><strong>在哪里</strong></font>出现</li><li><font color="#495DD8">counting</font> ：共有<font color="#64ceaa"><strong>几次</strong></font>出现</li><li><font color="#495DD8">enumeration</font> ：各出现<font color="#64ceaa"><strong>在哪里</strong></font>？</li></ul><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><p><code>KMP算法</code>（全称<code>Knuth-Morris-Pratt算法</code>）是一种高效的模式匹配算法。在模式匹配算法中，常见的算法包括<code>BF算法</code>（<code>朴素算法</code>）、<code>KMP算法</code>、<code>BM算法</code>、<code>RK算法</code>、<code>有限自动机算法</code>、<code>Horspool算法</code>、<code>Sunday算法</code>。在这些算法中，最经典的算法非<code>KMP算法</code>和<code>BM算法</code>莫属。这两种算法都有一个共同点：抽象，理解难度大。实际上，<code>KMP算法</code>还有一个明显特点：会者不难。本文内容默认你已经明白<code>BF算法</code>的原理和不足（因此这部分内容将简单略过），展开讲述<code>KMP算法</code>的原理、优点和<code>c++</code>代码实现。相信你在学会<code>KMP算法</code>之后将会有一种<font color="#64ceaa"><strong>“踏遍青山人未老，这边风景独好”</strong></font>的快意。让我们开始吧。</p><h2 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h2><p><code>BF算法</code>的本质就是<font color="#64ceaa">暴力搜索</font>。既然要在串<code>T</code>中找出与串<code>P</code>相同的所有子串，那不妨找出串<code>T</code>中所有与串<code>P</code>长度相同的子串，在逐个判断这个子串是否与串<code>P</code>相同。具体的例子<a href="https://www.bilibili.com/video/av11866460" target="_blank" rel="noopener">点击这里</a><font color="#5F2CA5">（<del>讲得很形象了，应该不会有理解上的困难</del>）</font>。设<code>strlen(T) == n, strlen(P) == m</code>，则<code>BF算法</code>的<font color="#64ceaa"><strong>预处理时间</strong></font>为$0$，<font color="#64ceaa"><strong>匹配时间</strong></font>为$O(mn)$，<font color="#64ceaa"><strong>总时间复杂度</strong></font>为$O(mn)$<font color="#5F2CA5"><del>（简直是蜗速）</del></font>，在大部分应用场景中并不<font color="#64ceaa"><strong>优秀</strong></font>。</p><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><h3 id="更高的效率"><a href="#更高的效率" class="headerlink" title="更高的效率"></a>更高的效率</h3><p>容易看出<code>BF算法</code>的效率是十分蹩脚的，而它蹩脚的原因也很明显：在一次匹配尝试中，一旦失配（某一位匹配失败），就把串<code>P</code>整体向右移动一位。在模拟算法运行过程中，我们发现如果开始匹配时第一位就失配，那么只向右移动一位的确无可厚非，毕竟说不定移动一位之后就会匹配成功呢；但是如果已经匹配了串<code>P</code>的一部分了才失配，在向右移动一位之后，有时候（而且往往是经常）我们发现依然注定会匹配失败，也就是说在上次失败之后，向右移动一位再做尝试是根本不必要的，这种<font color="#5F2CA5">“只移动一位”</font>的策略实际上造成了巨大的步骤浪费。那么有没有办法，把这些不必要的尝试舍弃，节约算法的运行时间呢？</p><p>此处我们需要考虑以下问题，以便对<code>BF算法</code>做出有效的改进：</p><ul><li><font color="#495DD8">为什么有一些尝试是注定徒劳的？</font></li><li><font color="#495DD8">如何判断哪些尝试需要舍弃？</font></li><li><font color="#495DD8">如果不是向右移动一位，又应该如何确定向右移动的位数？</font></li></ul><p>在看完<a href="https://www.bilibili.com/video/av11866460" target="_blank" rel="noopener">点击这里</a>（还是上面那个链接）之后，前两个问题都能得到答案。在链接的视频讲解中，讲述者构造了一个前缀表数组<code>prefix table</code>来确定串<code>P</code>中每个从头开始的子串的<font color="#64ceaa"><strong>最长公共前后缀</strong></font>（自身除外，以下省略此说明），一旦失配，就把串<code>P</code>向右移动到失配位置左侧子串的<font color="#64ceaa"><strong>最长前缀</strong></font>处，使它们重叠，也就是把下图中的<font color="#A349A4">1号</font>移动到<font color="#A349A4">2号</font>位置，继续从当前位置匹配，如果当前位置为串<code>T</code>的结尾，则结束匹配。</p><p><img src="https://i.loli.net/2019/11/26/eZcoQNJmPrKtklh.jpg" alt></p><p>那么问题来了：为什么要把<font color="#64ceaa"><strong>最长公共前缀</strong></font>移动至<font color="#64cceaa"><strong>最长公共后缀</strong></font>的位置？这个移动距离能不能更短？能不能更长？</p><blockquote> <font color="black">**引理**</font>  串的<font color="#64ceaa">**最长公共前后缀**</font>的<font color="#64ceaa">**最长公共前后缀**</font>是原串的<font color="#64ceaa">**次长公共前后缀**</font>。 <font color="black">**证明**</font>  略<font color="#5F2CA5">~~（逃~~</font></blockquote><p>实际上，在<code>BF算法</code>的一次匹配过程中，一旦失配，就把串<code>P</code>整体向右移动一位再次尝试匹配。假设第一次匹配时在串<code>P</code>的第<code>r + 1</code>位失配，此时已经确定串<code>P</code>失配位置的前<code>r</code>项与串<code>T</code>相应位置元素匹配，也确定了串<code>P</code>失配位置的前<code>r - 1</code>项与串<code>T</code>相应位置元素匹配。那么第二次匹配成功，当且仅当在串<code>P</code>的前<code>r</code>项组成的子串中，前<code>r - 1</code>位字符组成的前缀和后<code>r - 1</code>位字符组成的后缀相同，即某一个<font color="#64ceaa"><strong>公共前后缀</strong></font>长度为<code>r - 1</code>。也就是说，如果匹配失败向右移动<code>s</code>位，那么再次匹配成功的<font color="#64ceaa"><strong>必要条件</strong></font>是串<code>P</code>在失配位置前的子串的某一个<font color="#64ceaa"><strong>公共前后缀</strong></font>长度为<code>r - s</code>。如果串<code>P</code>在失配位置前的子串的<font color="#64ceaa"><strong>最长公共前后缀</strong></font>长度就是<code>r - s</code>，匹配失败后向右移动了不足<code>s</code>位，这意味着移动距离过短，将会做一遍无用功。</p><p>如果移动距离过长，那就有可能会错过一个成功的匹配。如果匹配失败向右移动<code>s</code>位，那么再次匹配成功的<font color="#64ceaa"><strong>必要条件</strong></font>是串<code>P</code>在失配位置前的子串的某一个<font color="#64ceaa"><strong>公共前后缀</strong></font>长度为<code>r - s</code>。注意这里是<font color="#64ceaa"><strong>必要条件</strong></font>而不是<font color="#64ceaa"><strong>充分条件</strong></font>，在把串<code>P</code>向右移动的过程中，并不是在失配位置前随便放一个<font color="#64ceaa"><strong>公共前后缀</strong></font>都能匹配成功，我们需要从<font color="#64ceaa"><strong>最长公共前后缀</strong></font>开始尝试，逐步减少原失配位置前子串的长度，直到匹配成功或者串<code>P</code>在失配位置前子串<font color="#64ceaa"><strong>最长公共前后缀</strong></font>长度变为<code>0</code>。</p><p>此处我们引入<code>next[]</code>数组来记录在失配时应该把串<code>P</code>的哪一位移动到当前位置。对于串<code>P</code>的第<code>j + 1</code>位的字符来说，<code>next[j + 1]</code>的意义是由串<code>P</code>的前<code>j</code>项的子串中<font color="#64ceaa"><strong>最长公共前后缀</strong></font>的长度。<code>next[]</code>数组是<code>KMP算法</code>降低<font color="#64ceaa"><strong>时间复杂度</strong></font>的关键，在预处理时就已经确定。下面介绍<code>next[]</code>数组求法。</p><h3 id="next数组求法"><a href="#next数组求法" class="headerlink" title="next数组求法"></a>next数组求法</h3><p>如果你直接跳过了前面看到了这里，那说明你已经看了无数多参考资料，还是搞不懂<code>next[]</code>数组求法的原理，几乎走投无路了。但是，正如B站鬼畜区某神所言：</p><p>~<font color="#FF7F27"><strong>我们遇到什么困难也不要怕，微笑着面对它！消除恐惧的最好办法就是面对恐惧！坚持就是胜利！加油！奥利给！</strong></font>~</p><a id="more"></a><p>回到正题。</p><p>先考虑求<code>next[]</code>数组的朴素算法：我们要求一个长度为<code>l</code>的串<code>S</code>的<font color="#64ceaa"><strong>最长公共前后缀</strong></font>，因为自身除外，所以把串<code>S</code>复制一遍，产生一个串<code>S&#39;</code>，并让串<code>S&#39;</code>的第<code>1</code>位对齐串<code>S</code>的第<code>2</code>位，尝试匹配剩余<code>l - 1</code>位。若匹配成功，则剩余<code>l - 1</code>位就是串<code>P</code>的<font color="#64ceaa"><strong>最长公共前后缀</strong></font>；若匹配失败，则把串<code>S&#39;</code>向右移动<code>1</code>位，再次尝试，知道匹配成功或串<code>S&#39;</code>已被移出串<code>S</code>的范围之内。</p><p>等一等，为什么这波操作如此熟悉？<font color="#5F2CA5"><del>（战术后仰</del></font></p><p>是的，这就是所谓的<font color="#5F2CA5">“串<code>P</code>匹配自身”</font>，有没有办法可以优化以上的朴素算法呢？</p><p>我们的任务是求出串<code>P</code>每一个由前<code>j</code>项元素组成的子串的<font color="#64ceaa"><strong>最长公共前后缀</strong></font>的长度。假设串<code>P</code>从字符串下标<code>1</code>开始存储，规定<code>next[1] = 0</code>，并从第<code>2</code>位开始匹配。设用串<code>P&#39;</code>匹配串<code>P</code>，当前匹配位置是串<code>P&#39;</code>的第<code>j + 1</code>位，串<code>P</code>的第<code>i</code>位，如果失配，那么处理方法同上面介绍的一样，把串<code>P&#39;</code>向右移动到失配位置左侧子串的<font color="#64ceaa"><strong>最长前缀</strong></font>处，即令<code>j = next[j]</code><font color="#5F2CA5">（思想：回溯）</font>，使它们重叠，即把下图中的<font color="#A349A4">1号</font>移动到<font color="#A349A4">2号</font>位置，继续从当前位置匹配；如果第<code>j + 1</code>位匹配成功，则更新串<code>P</code>前<code>i</code>位元素组成的子串的<font color="#64ceaa"><strong>最长公共前后缀</strong></font>的长度为<code>j</code>，即令<code>next[i] = j</code>。</p><p><img src="https://i.loli.net/2019/11/26/IrptJbecBsQy16q.jpg" alt></p><p>你已经明白了<code>KMP算法</code>的原理，那么不难推算出<code>KMP算法</code>的时间复杂度：<font color="#64ceaa"><strong>预处理时间</strong></font>为$\Theta(m)$，<font color="#64ceaa"><strong>匹配时间</strong></font>为$\Theta(n)$，<font color="#64ceaa"><strong>总时间复杂度</strong></font>为$\Theta(m+n)$。与<code>BF算法</code>相比，<code>KMP算法</code>是一种<font color="#64ceaa"><strong>优秀</strong></font>的模式匹配算法。</p><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">KMP-MATCHER(T, P)</span><br><span class="line"></span><br><span class="line">n = T.length</span><br><span class="line">m = P.length</span><br><span class="line"></span><br><span class="line">next = COMPUTE-PREFIX-FUNCTION(P)</span><br><span class="line"></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> to n</span><br><span class="line"><span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> P[j + <span class="number">1</span>] != T[i]</span><br><span class="line">j = next[j]</span><br><span class="line"><span class="keyword">if</span> P[j + <span class="number">1</span>] == T[j]</span><br><span class="line">j = j + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> j == m</span><br><span class="line">    print <span class="string">"Pattern occurs with shift"</span> i - m</span><br><span class="line">    j = next[j]</span><br><span class="line">    </span><br><span class="line">COMPUTE-PREFIX-FUNCTION(P)</span><br><span class="line"></span><br><span class="line">m = P.length</span><br><span class="line">let next[<span class="number">1.</span>.m] be a <span class="keyword">new</span> <span class="built_in">array</span></span><br><span class="line">next[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">2</span> to m</span><br><span class="line"><span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> P[j + <span class="number">1</span>] != T[i]</span><br><span class="line">j = next[j]</span><br><span class="line"><span class="keyword">if</span> P[j + <span class="number">1</span>] == T[j]</span><br><span class="line">j = j + <span class="number">1</span></span><br><span class="line">    next[i] = j</span><br><span class="line"><span class="keyword">return</span> next</span><br></pre></td></tr></table></figure><h2 id="例题：KMP算法模版"><a href="#例题：KMP算法模版" class="headerlink" title="例题：KMP算法模版"></a>例题：KMP算法模版</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个字符串$s1$和$s2$（皆从下标为$1$处开始存储），$s2$为$s1$的子串，输出$s2$在$s1$中所有出现位置的下标。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行为$s1$，第二行为$s2$</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>每行一个正整数表示s2在s1中出现的位置</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">123456123</span><br><span class="line">123</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">7</span><br></pre></td></tr></table></figure><h3 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h3><ul><li><font color="#495DD8">$s1$和$s2$的长度在$1000000$之内</font></li><li><font color="#495DD8">运行速度不能太慢</font></li></ul><h3 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Presented by G-SS-Hacker</span></span><br><span class="line"><span class="comment">//cc BY-NC-SA 4.0</span></span><br><span class="line"><span class="comment">//Run on C++</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000000</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1000000</span> + <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//next,x0,x1,y0,y1,index cannot be named to variables</span></span><br><span class="line"><span class="keyword">int</span> nxt[MAXM];<span class="comment">//nxt[i]表示字串1到i最长公共前后缀的长度</span></span><br><span class="line"><span class="keyword">int</span> len1, len2;</span><br><span class="line"><span class="keyword">char</span> s1[MAXN], s2[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>, i = <span class="number">2</span>; i &lt;= len2; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(j &amp;&amp; s2[i] != s2[j + <span class="number">1</span>])</span><br><span class="line">j = nxt[j];</span><br><span class="line"><span class="keyword">if</span>(s2[i] == s2[j + <span class="number">1</span>])</span><br><span class="line">j++;</span><br><span class="line">nxt[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>, i = <span class="number">1</span>; i &lt;= len1; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(j &amp;&amp; s1[i] != s2[j + <span class="number">1</span>])</span><br><span class="line">j = nxt[j];</span><br><span class="line"><span class="keyword">if</span>(s1[i] == s2[j + <span class="number">1</span>])</span><br><span class="line">j++;</span><br><span class="line"><span class="keyword">if</span>(j == len2)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i - len2 + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>, j = nxt[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s1 + <span class="number">1</span> &gt;&gt; s2 + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">len1 = <span class="built_in">strlen</span>(s1 + <span class="number">1</span>);</span><br><span class="line">len2 = <span class="built_in">strlen</span>(s2 + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">pre();</span><br><span class="line">kmp();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>~<font color="#FF7F27"><strong>我们遇到什么困难也不要怕，微笑着面对它！消除恐惧的最好办法就是面对恐惧！坚持就是胜利！加油！奥利给！</strong></font>~</p><hr><blockquote><p>图：北京航空航天大学</p></blockquote><font color="#407600">【其他文章·数据结构】</font><ul><li><p><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/拓扑排序/">拓扑排序</a></p></li><li><p><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/图的表示/">图的表示</a></p></li><li><p><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/数据结构绪论/">数据结构绪论</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1574783133220&amp;amp;di=3be2714c61c60e81640b949c940ab16a&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fimg.mp.itc.cn%2Fupload%2F20170613%2Fca5280ac60284d4cb01f4f81be3b448b_th.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;模式匹配算法：KMP算法&quot;&gt;&lt;a href=&quot;#模式匹配算法：KMP算法&quot; class=&quot;headerlink&quot; title=&quot;模式匹配算法：KMP算法&quot;&gt;&lt;/a&gt;模式匹配算法：KMP算法&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;模式匹配是数据结构中字符串的一种基本运算，给定一个字符串P，要求在某个字符串T中找出与字符串P相同的所有子串，这就是模式匹配。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;模式匹配算法要解决的问题&quot;&gt;&lt;a href=&quot;#模式匹配算法要解决的问题&quot; class=&quot;headerlink&quot; title=&quot;模式匹配算法要解决的问题&quot;&gt;&lt;/a&gt;模式匹配算法要解决的问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;font color=&quot;#495DD8&quot;&gt;detection&lt;/font&gt; ：P&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;是否&lt;/strong&gt;&lt;/font&gt;出现&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;#495DD8&quot;&gt;location&lt;/font&gt; ：首次&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;在哪里&lt;/strong&gt;&lt;/font&gt;出现&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;#495DD8&quot;&gt;counting&lt;/font&gt; ：共有&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;几次&lt;/strong&gt;&lt;/font&gt;出现&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;#495DD8&quot;&gt;enumeration&lt;/font&gt; ：各出现&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;在哪里&lt;/strong&gt;&lt;/font&gt;？&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;绪论&quot;&gt;&lt;a href=&quot;#绪论&quot; class=&quot;headerlink&quot; title=&quot;绪论&quot;&gt;&lt;/a&gt;绪论&lt;/h2&gt;&lt;p&gt;&lt;code&gt;KMP算法&lt;/code&gt;（全称&lt;code&gt;Knuth-Morris-Pratt算法&lt;/code&gt;）是一种高效的模式匹配算法。在模式匹配算法中，常见的算法包括&lt;code&gt;BF算法&lt;/code&gt;（&lt;code&gt;朴素算法&lt;/code&gt;）、&lt;code&gt;KMP算法&lt;/code&gt;、&lt;code&gt;BM算法&lt;/code&gt;、&lt;code&gt;RK算法&lt;/code&gt;、&lt;code&gt;有限自动机算法&lt;/code&gt;、&lt;code&gt;Horspool算法&lt;/code&gt;、&lt;code&gt;Sunday算法&lt;/code&gt;。在这些算法中，最经典的算法非&lt;code&gt;KMP算法&lt;/code&gt;和&lt;code&gt;BM算法&lt;/code&gt;莫属。这两种算法都有一个共同点：抽象，理解难度大。实际上，&lt;code&gt;KMP算法&lt;/code&gt;还有一个明显特点：会者不难。本文内容默认你已经明白&lt;code&gt;BF算法&lt;/code&gt;的原理和不足（因此这部分内容将简单略过），展开讲述&lt;code&gt;KMP算法&lt;/code&gt;的原理、优点和&lt;code&gt;c++&lt;/code&gt;代码实现。相信你在学会&lt;code&gt;KMP算法&lt;/code&gt;之后将会有一种&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;“踏遍青山人未老，这边风景独好”&lt;/strong&gt;&lt;/font&gt;的快意。让我们开始吧。&lt;/p&gt;
&lt;h2 id=&quot;BF算法&quot;&gt;&lt;a href=&quot;#BF算法&quot; class=&quot;headerlink&quot; title=&quot;BF算法&quot;&gt;&lt;/a&gt;BF算法&lt;/h2&gt;&lt;p&gt;&lt;code&gt;BF算法&lt;/code&gt;的本质就是&lt;font color=&quot;#64ceaa&quot;&gt;暴力搜索&lt;/font&gt;。既然要在串&lt;code&gt;T&lt;/code&gt;中找出与串&lt;code&gt;P&lt;/code&gt;相同的所有子串，那不妨找出串&lt;code&gt;T&lt;/code&gt;中所有与串&lt;code&gt;P&lt;/code&gt;长度相同的子串，在逐个判断这个子串是否与串&lt;code&gt;P&lt;/code&gt;相同。具体的例子&lt;a href=&quot;https://www.bilibili.com/video/av11866460&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击这里&lt;/a&gt;&lt;font color=&quot;#5F2CA5&quot;&gt;（&lt;del&gt;讲得很形象了，应该不会有理解上的困难&lt;/del&gt;）&lt;/font&gt;。设&lt;code&gt;strlen(T) == n, strlen(P) == m&lt;/code&gt;，则&lt;code&gt;BF算法&lt;/code&gt;的&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;预处理时间&lt;/strong&gt;&lt;/font&gt;为$0$，&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;匹配时间&lt;/strong&gt;&lt;/font&gt;为$O(mn)$，&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;总时间复杂度&lt;/strong&gt;&lt;/font&gt;为$O(mn)$&lt;font color=&quot;#5F2CA5&quot;&gt;&lt;del&gt;（简直是蜗速）&lt;/del&gt;&lt;/font&gt;，在大部分应用场景中并不&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;优秀&lt;/strong&gt;&lt;/font&gt;。&lt;/p&gt;
&lt;h2 id=&quot;KMP算法&quot;&gt;&lt;a href=&quot;#KMP算法&quot; class=&quot;headerlink&quot; title=&quot;KMP算法&quot;&gt;&lt;/a&gt;KMP算法&lt;/h2&gt;&lt;h3 id=&quot;更高的效率&quot;&gt;&lt;a href=&quot;#更高的效率&quot; class=&quot;headerlink&quot; title=&quot;更高的效率&quot;&gt;&lt;/a&gt;更高的效率&lt;/h3&gt;&lt;p&gt;容易看出&lt;code&gt;BF算法&lt;/code&gt;的效率是十分蹩脚的，而它蹩脚的原因也很明显：在一次匹配尝试中，一旦失配（某一位匹配失败），就把串&lt;code&gt;P&lt;/code&gt;整体向右移动一位。在模拟算法运行过程中，我们发现如果开始匹配时第一位就失配，那么只向右移动一位的确无可厚非，毕竟说不定移动一位之后就会匹配成功呢；但是如果已经匹配了串&lt;code&gt;P&lt;/code&gt;的一部分了才失配，在向右移动一位之后，有时候（而且往往是经常）我们发现依然注定会匹配失败，也就是说在上次失败之后，向右移动一位再做尝试是根本不必要的，这种&lt;font color=&quot;#5F2CA5&quot;&gt;“只移动一位”&lt;/font&gt;的策略实际上造成了巨大的步骤浪费。那么有没有办法，把这些不必要的尝试舍弃，节约算法的运行时间呢？&lt;/p&gt;
&lt;p&gt;此处我们需要考虑以下问题，以便对&lt;code&gt;BF算法&lt;/code&gt;做出有效的改进：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=&quot;#495DD8&quot;&gt;为什么有一些尝试是注定徒劳的？&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;#495DD8&quot;&gt;如何判断哪些尝试需要舍弃？&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;#495DD8&quot;&gt;如果不是向右移动一位，又应该如何确定向右移动的位数？&lt;/font&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在看完&lt;a href=&quot;https://www.bilibili.com/video/av11866460&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击这里&lt;/a&gt;（还是上面那个链接）之后，前两个问题都能得到答案。在链接的视频讲解中，讲述者构造了一个前缀表数组&lt;code&gt;prefix table&lt;/code&gt;来确定串&lt;code&gt;P&lt;/code&gt;中每个从头开始的子串的&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;最长公共前后缀&lt;/strong&gt;&lt;/font&gt;（自身除外，以下省略此说明），一旦失配，就把串&lt;code&gt;P&lt;/code&gt;向右移动到失配位置左侧子串的&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;最长前缀&lt;/strong&gt;&lt;/font&gt;处，使它们重叠，也就是把下图中的&lt;font color=&quot;#A349A4&quot;&gt;1号&lt;/font&gt;移动到&lt;font color=&quot;#A349A4&quot;&gt;2号&lt;/font&gt;位置，继续从当前位置匹配，如果当前位置为串&lt;code&gt;T&lt;/code&gt;的结尾，则结束匹配。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/11/26/eZcoQNJmPrKtklh.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;那么问题来了：为什么要把&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;最长公共前缀&lt;/strong&gt;&lt;/font&gt;移动至&lt;font color=&quot;#64cceaa&quot;&gt;&lt;strong&gt;最长公共后缀&lt;/strong&gt;&lt;/font&gt;的位置？这个移动距离能不能更短？能不能更长？&lt;/p&gt;
&lt;blockquote&gt;
 &lt;font color=&quot;black&quot;&gt;**引理**&lt;/font&gt;  串的&lt;font color=&quot;#64ceaa&quot;&gt;**最长公共前后缀**&lt;/font&gt;的&lt;font color=&quot;#64ceaa&quot;&gt;**最长公共前后缀**&lt;/font&gt;是原串的&lt;font color=&quot;#64ceaa&quot;&gt;**次长公共前后缀**&lt;/font&gt;。

 &lt;font color=&quot;black&quot;&gt;**证明**&lt;/font&gt;  略&lt;font color=&quot;#5F2CA5&quot;&gt;~~（逃~~&lt;/font&gt;

&lt;/blockquote&gt;
&lt;p&gt;实际上，在&lt;code&gt;BF算法&lt;/code&gt;的一次匹配过程中，一旦失配，就把串&lt;code&gt;P&lt;/code&gt;整体向右移动一位再次尝试匹配。假设第一次匹配时在串&lt;code&gt;P&lt;/code&gt;的第&lt;code&gt;r + 1&lt;/code&gt;位失配，此时已经确定串&lt;code&gt;P&lt;/code&gt;失配位置的前&lt;code&gt;r&lt;/code&gt;项与串&lt;code&gt;T&lt;/code&gt;相应位置元素匹配，也确定了串&lt;code&gt;P&lt;/code&gt;失配位置的前&lt;code&gt;r - 1&lt;/code&gt;项与串&lt;code&gt;T&lt;/code&gt;相应位置元素匹配。那么第二次匹配成功，当且仅当在串&lt;code&gt;P&lt;/code&gt;的前&lt;code&gt;r&lt;/code&gt;项组成的子串中，前&lt;code&gt;r - 1&lt;/code&gt;位字符组成的前缀和后&lt;code&gt;r - 1&lt;/code&gt;位字符组成的后缀相同，即某一个&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;公共前后缀&lt;/strong&gt;&lt;/font&gt;长度为&lt;code&gt;r - 1&lt;/code&gt;。也就是说，如果匹配失败向右移动&lt;code&gt;s&lt;/code&gt;位，那么再次匹配成功的&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;必要条件&lt;/strong&gt;&lt;/font&gt;是串&lt;code&gt;P&lt;/code&gt;在失配位置前的子串的某一个&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;公共前后缀&lt;/strong&gt;&lt;/font&gt;长度为&lt;code&gt;r - s&lt;/code&gt;。如果串&lt;code&gt;P&lt;/code&gt;在失配位置前的子串的&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;最长公共前后缀&lt;/strong&gt;&lt;/font&gt;长度就是&lt;code&gt;r - s&lt;/code&gt;，匹配失败后向右移动了不足&lt;code&gt;s&lt;/code&gt;位，这意味着移动距离过短，将会做一遍无用功。&lt;/p&gt;
&lt;p&gt;如果移动距离过长，那就有可能会错过一个成功的匹配。如果匹配失败向右移动&lt;code&gt;s&lt;/code&gt;位，那么再次匹配成功的&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;必要条件&lt;/strong&gt;&lt;/font&gt;是串&lt;code&gt;P&lt;/code&gt;在失配位置前的子串的某一个&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;公共前后缀&lt;/strong&gt;&lt;/font&gt;长度为&lt;code&gt;r - s&lt;/code&gt;。注意这里是&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;必要条件&lt;/strong&gt;&lt;/font&gt;而不是&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;充分条件&lt;/strong&gt;&lt;/font&gt;，在把串&lt;code&gt;P&lt;/code&gt;向右移动的过程中，并不是在失配位置前随便放一个&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;公共前后缀&lt;/strong&gt;&lt;/font&gt;都能匹配成功，我们需要从&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;最长公共前后缀&lt;/strong&gt;&lt;/font&gt;开始尝试，逐步减少原失配位置前子串的长度，直到匹配成功或者串&lt;code&gt;P&lt;/code&gt;在失配位置前子串&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;最长公共前后缀&lt;/strong&gt;&lt;/font&gt;长度变为&lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;此处我们引入&lt;code&gt;next[]&lt;/code&gt;数组来记录在失配时应该把串&lt;code&gt;P&lt;/code&gt;的哪一位移动到当前位置。对于串&lt;code&gt;P&lt;/code&gt;的第&lt;code&gt;j + 1&lt;/code&gt;位的字符来说，&lt;code&gt;next[j + 1]&lt;/code&gt;的意义是由串&lt;code&gt;P&lt;/code&gt;的前&lt;code&gt;j&lt;/code&gt;项的子串中&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;最长公共前后缀&lt;/strong&gt;&lt;/font&gt;的长度。&lt;code&gt;next[]&lt;/code&gt;数组是&lt;code&gt;KMP算法&lt;/code&gt;降低&lt;font color=&quot;#64ceaa&quot;&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;&lt;/font&gt;的关键，在预处理时就已经确定。下面介绍&lt;code&gt;next[]&lt;/code&gt;数组求法。&lt;/p&gt;
&lt;h3 id=&quot;next数组求法&quot;&gt;&lt;a href=&quot;#next数组求法&quot; class=&quot;headerlink&quot; title=&quot;next数组求法&quot;&gt;&lt;/a&gt;next数组求法&lt;/h3&gt;&lt;p&gt;如果你直接跳过了前面看到了这里，那说明你已经看了无数多参考资料，还是搞不懂&lt;code&gt;next[]&lt;/code&gt;数组求法的原理，几乎走投无路了。但是，正如B站鬼畜区某神所言：&lt;/p&gt;
&lt;p&gt;~&lt;font color=&quot;#FF7F27&quot;&gt;&lt;strong&gt;我们遇到什么困难也不要怕，微笑着面对它！消除恐惧的最好办法就是面对恐惧！坚持就是胜利！加油！奥利给！&lt;/strong&gt;&lt;/font&gt;~&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="C-plus-plus" scheme="https://G-SS-Hacker.github.io/tags/C-plus-plus/"/>
    
      <category term="算法" scheme="https://G-SS-Hacker.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://G-SS-Hacker.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="字符串" scheme="https://G-SS-Hacker.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>常用泰勒展开式</title>
    <link href="https://g-ss-hacker.github.io/%E5%B8%B8%E7%94%A8%E6%B3%B0%E5%8B%92%E5%B1%95%E5%BC%80%E5%BC%8F/"/>
    <id>https://g-ss-hacker.github.io/%E5%B8%B8%E7%94%A8%E6%B3%B0%E5%8B%92%E5%B1%95%E5%BC%80%E5%BC%8F/</id>
    <published>2019-11-07T14:22:19.000Z</published>
    <updated>2019-11-28T14:48:40.154Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.colorhub.me/IogF4QdtTJDwNcp_7Fkx7Zw0XBgIHtR3T4Okq_bH7dU/fill/0/500/ce/0/bG9jYWw6Ly8vMDgv/MTIvNjQyYWU2NmVk/ODlmOWRlNGE3Y2Yw/ODJmYjI0NGE1ODY0/MjgzMDgxMi5qcGVn.jpg" alt></p><h1 id="常用泰勒展开"><a href="#常用泰勒展开" class="headerlink" title="常用泰勒展开"></a>常用泰勒展开</h1><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><br>$(1)e^x=1+e+\frac{e^2}{2!}+\dots +\frac{e^n}{n!}+\frac{e^\theta x}{(n+1)!}x^{n+1}$<p></p><p>$(2)\sin x=x-\frac{x^3}{3!}+\frac{x^5}{5!}-\dots+(-1)^m\frac{x^{2m+1}}{(2m+1)!}+(-1)^{m+1}\frac{\cos \theta x}{(2m+3!)}x^{2m+3}$</p><p>$(3)\cos x=1-\frac{x^2}{2!}+\frac{x^4}{4!}-\dots+(-1)^m\frac{x^{2m}}{(2m)!}+(-1)^{m+1}\frac{\cos \theta x}{(2m+2)!}x^{2m+2}$</p><p>$(4)\ln(1+x)=x-\frac{x^2}{2}+\frac{x^3}{3}-\dots+(-1)^{n-1}\frac{x^n}{n}+(-1)^n\frac{x^{n+1}}{(n+1)(1+\theta x)^{n+1}}$</p><p>$(5)(1+x)^\alpha=\sum_{k=0}^n C_\alpha^n x^n+C_\alpha^{n+1}x^{n+1}(1+\theta x)^{\alpha -n-1}$</p><a id="more"></a><hr><p>~<font color="#FF7F27"><strong>我们遇到什么困难也不要怕，微笑着面对它！消除恐惧的最好办法就是面对恐惧！坚持就是胜利！加油！奥利给！</strong></font>~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.colorhub.me/IogF4QdtTJDwNcp_7Fkx7Zw0XBgIHtR3T4Okq_bH7dU/fill/0/500/ce/0/bG9jYWw6Ly8vMDgv/MTIvNjQyYWU2NmVk/ODlmOWRlNGE3Y2Yw/ODJmYjI0NGE1ODY0/MjgzMDgxMi5qcGVn.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;常用泰勒展开&quot;&gt;&lt;a href=&quot;#常用泰勒展开&quot; class=&quot;headerlink&quot; title=&quot;常用泰勒展开&quot;&gt;&lt;/a&gt;常用泰勒展开&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;br&gt;$(1)e^x=1+e+\frac{e^2}{2!}+\dots +\frac{e^n}{n!}+\frac{e^\theta x}{(n+1)!}x^{n+1}$&lt;p&gt;&lt;/p&gt;
&lt;p&gt;$(2)\sin x=x-\frac{x^3}{3!}+\frac{x^5}{5!}-\dots+(-1)^m\frac{x^{2m+1}}{(2m+1)!}+(-1)^{m+1}\frac{\cos \theta x}{(2m+3!)}x^{2m+3}$&lt;/p&gt;
&lt;p&gt;$(3)\cos x=1-\frac{x^2}{2!}+\frac{x^4}{4!}-\dots+(-1)^m\frac{x^{2m}}{(2m)!}+(-1)^{m+1}\frac{\cos \theta x}{(2m+2)!}x^{2m+2}$&lt;/p&gt;
&lt;p&gt;$(4)\ln(1+x)=x-\frac{x^2}{2}+\frac{x^3}{3}-\dots+(-1)^{n-1}\frac{x^n}{n}+(-1)^n\frac{x^{n+1}}{(n+1)(1+\theta x)^{n+1}}$&lt;/p&gt;
&lt;p&gt;$(5)(1+x)^\alpha=\sum_{k=0}^n C_\alpha^n x^n+C_\alpha^{n+1}x^{n+1}(1+\theta x)^{\alpha -n-1}$&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="微积分" scheme="https://G-SS-Hacker.github.io/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>矩阵章节总结</title>
    <link href="https://g-ss-hacker.github.io/%E7%9F%A9%E9%98%B5%E7%AB%A0%E8%8A%82%E6%80%BB%E7%BB%93/"/>
    <id>https://g-ss-hacker.github.io/%E7%9F%A9%E9%98%B5%E7%AB%A0%E8%8A%82%E6%80%BB%E7%BB%93/</id>
    <published>2019-10-28T13:43:02.000Z</published>
    <updated>2019-11-28T14:49:12.849Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1573141304163&amp;di=91f3aa900d4bd602b9a233ff478c2bbc&amp;imgtype=0&amp;src=http%3A%2F%2Fdingyue.nosdn.127.net%2FvXsWUrS27VAb4s%3DrSMlMPRzjkRzux6S4Tx9RXqej1%3D%3DW51544709511256compressflag.jpg" alt></p><h1 id="矩阵章节总结"><a href="#矩阵章节总结" class="headerlink" title="矩阵章节总结"></a>矩阵章节总结</h1><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><br>矩阵（matrix）形式优美，应用广泛。但是笔者相当头痛矩阵问题。实际上，矩阵的计算绝对不能靠硬算（硬算的事交给<code>Matlab</code>就好了，实际上计算机做矩阵运算，为了避免数值不稳定问题，使用的是和人计算不同的算法），而是灵活变形后运用基本的计算公式；矩阵的证明则更离不开对公式及其推论的灵活运用。笔者从题海中抽象出矩阵计算的常用思想和性质。作者实属菜鸟，水平很菜，将就看看吧 ╮(╯_╰)╭<p></p><h2 id="运算律"><a href="#运算律" class="headerlink" title="运算律"></a>运算律</h2><ol><li><p>$ {AB}= {BA}$时，矩阵运算满足<code>交换律</code>，故以下运算皆成立</p><p>$(\mathrm{i})( {A}\pm  {B})^2= {A}^2 \pm 2 {AB} + {B}^2$</p><p>$(\mathrm{ii})( {A}+ {B})( {A}- {B})= {A}^2- {B}^2$</p><p>$(\mathrm{iii})( {AB})^2=( {BA})^2$</p></li><li><p>$ {A}^*， {A}’， {A}^{-1}$组合会产生十分令人头疼的问题，使用以下公式来缓解头疼</p><p>$(\mathrm{i})( {AB})’= {B}’ {A}’$</p><p>$(\mathrm{ii})( {AB})^{-1}= {B}^{-1} {A}^{-1}$</p><p>$(\mathrm{iii})( {A}^*)^{-1}=( {A}^{-1})^*$</p></li><li><p>带系数的情况</p><p>$(\mathrm{i})|k {A}|=k^n| {A}|$</p><p>$(\mathrm{ii})(k {A})^{-1}=\frac1{k} {A}^{-1}$</p><p>$(\mathrm{iii})(k {A})’=k {A}’$</p><p>$(\mathrm{iv})\overline{k {A}}=\overline{k}\overline{ {A}}$</p></li></ol><h2 id="共轭矩阵"><a href="#共轭矩阵" class="headerlink" title="共轭矩阵"></a>共轭矩阵</h2><p>记住以下四个公式，以备突然考到</p><p>$(\mathrm{i})\overline{ {A}+ {B}}=\overline{ {A}}+\overline{ {B}}$</p><p>$(\mathrm{ii})\overline{k {A}}=\overline{k}\overline{ {A}}$</p><p>$(\mathrm{iii})\overline{ {AB}}=\overline{ {A}}\overline{ {B}}$</p><p>$(\mathrm{iv})|\overline{ {A}}|=\overline{| {A}|}$</p><p>简单地记，凡是涉及共轭的题目，计算的时候看起来能取共轭的都取共轭</p><h2 id="伴随矩阵"><a href="#伴随矩阵" class="headerlink" title="伴随矩阵"></a>伴随矩阵</h2><ol><li><p>看到$ {A}^*$，以下公式至少用其一</p><p>$(\mathrm{i}) {A}^* {A}= {A} {A}^*=| {A}| {E}$</p><p>$(\mathrm{ii}) {A}^{-1}=\frac{ {A}^*}{| {A}|}$</p><p>$(\mathrm{iii})| {A}^*|=| {A}|^{n-1}$</p><p>$(\mathrm{iv})( {A}^*)^*=| {A}|^{n-2} {A}$</p></li><li><p>伴随矩阵的特殊性质：极端的伴随矩阵</p><script type="math/tex; mode=display">{R}({A}^*)=\begin{cases}     n,\quad {R}({A})=n\\    1,\quad {R}({A})=n-1\\    0,\quad {R}({A})<n-1\end{cases}</script></li></ol><h2 id="杂题"><a href="#杂题" class="headerlink" title="杂题"></a>杂题</h2><ol><li><p>判断矩阵可逆的方法：</p><p>$(\mathrm{i}) {AB}= {BA}=E$</p><p>$(\mathrm{ii}) {R}( {A})=n$</p><p>$(\mathrm{iii})| {A}|=0$</p><p>$(\mathrm{iv}) {A}= {P}_1 {P}_2 \dots  {P}_k$</p></li><li><p>初变不变秩，不变奇异性</p></li><li><p>行阶梯、行最简、标准形</p></li><li><p>求逆方法：公式法、辅助矩阵法</p></li></ol><h2 id="分块矩阵运算"><a href="#分块矩阵运算" class="headerlink" title="分块矩阵运算"></a>分块矩阵运算</h2><ol><li><p>对角方阵求逆（仅对对角方阵有效）：</p><script type="math/tex; mode=display">\left(\begin {array}{ccc}    {A}_{11}& & & &\\     & {A}_{22}& & &\\     & & \ddots & &\\     & & & {A}_{ss}&\end {array}\right)^m=\left(\begin {array}{ccc}    {A}_{11}^m& & & &\\     & {A}_{22}^m& & &\\     & & \ddots & &\\     & & & {A}_{ss}^m&\end {array}\right)</script></li><li><p>特殊矩阵求逆矩阵，是否还应保持原来的顺序：</p><p>$(\mathrm{i})$主对角：$\searrow$仍为$\searrow$</p><p>$(\mathrm{ii})$次对角：$\swarrow$变为$\nearrow$</p></li><li><p>思想：运用<code>第三类初等变换</code></p><script type="math/tex; mode=display">\left|\begin{array}{cccc} {A} & {C} \\ {D} & {B} \end{array} \right|=|{A}||{B}-{DA}^{-1}{C}|</script></li><li><p>分块矩阵的秩（高频使用，按重要性降序排列）：</p><p>$(\mathrm{i})R(A+B)\leq R(A)+R(B),\quad R(A-B)\leq R(A)+R(B)$</p><p>$(\mathrm{ii})R(AB)\leq min\{R(A),R(B)\}$</p><p>$(\mathrm{iii})R(A|B)\leq R(A)+R(B),\quad R(\frac{A}{B})\leq R(A)+R(B)$</p><p>$(\mathrm{iv})R \left(\begin{array}{ccc} A &amp; 0\\0 &amp; B \end{array} \right)=R(A)+R(B)$</p><p>$(\mathrm{v})R \left(\begin{array}{ccc} A &amp; C\\0 &amp; B \end{array} \right)\ge R(A)+R(B)$，若$A$，$B$其一可逆则取等</p><p>$(\mathrm{vi})$设$A$为$m\times n$矩阵，$B$为$n\times p$矩阵（有时题目条件会简化为$A$、$B$为同阶方阵），则$R(AB) \ge R(A)+R(B)-n$；特别地，当$AB=0$时，$R(A)+R(B)\le n$</p><p>$(\mathrm{iii})(\mathrm{iv})(\mathrm{v})$皆易证</p><a id="more"></a><hr><p>~<font color="#FF7F27"><strong>我们遇到什么困难也不要怕，微笑着面对它！消除恐惧的最好办法就是面对恐惧！坚持就是胜利！加油！奥利给！</strong></font>~</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1573141304163&amp;amp;di=91f3aa900d4bd602b9a233ff478c2bbc&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fdingyue.nosdn.127.net%2FvXsWUrS27VAb4s%3DrSMlMPRzjkRzux6S4Tx9RXqej1%3D%3DW51544709511256compressflag.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;矩阵章节总结&quot;&gt;&lt;a href=&quot;#矩阵章节总结&quot; class=&quot;headerlink&quot; title=&quot;矩阵章节总结&quot;&gt;&lt;/a&gt;矩阵章节总结&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;br&gt;矩阵（matrix）形式优美，应用广泛。但是笔者相当头痛矩阵问题。实际上，矩阵的计算绝对不能靠硬算（硬算的事交给&lt;code&gt;Matlab&lt;/code&gt;就好了，实际上计算机做矩阵运算，为了避免数值不稳定问题，使用的是和人计算不同的算法），而是灵活变形后运用基本的计算公式；矩阵的证明则更离不开对公式及其推论的灵活运用。笔者从题海中抽象出矩阵计算的常用思想和性质。作者实属菜鸟，水平很菜，将就看看吧 ╮(╯_╰)╭&lt;p&gt;&lt;/p&gt;
&lt;h2 id=&quot;运算律&quot;&gt;&lt;a href=&quot;#运算律&quot; class=&quot;headerlink&quot; title=&quot;运算律&quot;&gt;&lt;/a&gt;运算律&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;$ {AB}= {BA}$时，矩阵运算满足&lt;code&gt;交换律&lt;/code&gt;，故以下运算皆成立&lt;/p&gt;
&lt;p&gt;$(\mathrm{i})( {A}\pm  {B})^2= {A}^2 \pm 2 {AB} + {B}^2$&lt;/p&gt;
&lt;p&gt;$(\mathrm{ii})( {A}+ {B})( {A}- {B})= {A}^2- {B}^2$&lt;/p&gt;
&lt;p&gt;$(\mathrm{iii})( {AB})^2=( {BA})^2$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;$ {A}^*， {A}’， {A}^{-1}$组合会产生十分令人头疼的问题，使用以下公式来缓解头疼&lt;/p&gt;
&lt;p&gt;$(\mathrm{i})( {AB})’= {B}’ {A}’$&lt;/p&gt;
&lt;p&gt;$(\mathrm{ii})( {AB})^{-1}= {B}^{-1} {A}^{-1}$&lt;/p&gt;
&lt;p&gt;$(\mathrm{iii})( {A}^*)^{-1}=( {A}^{-1})^*$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;带系数的情况&lt;/p&gt;
&lt;p&gt;$(\mathrm{i})|k {A}|=k^n| {A}|$&lt;/p&gt;
&lt;p&gt;$(\mathrm{ii})(k {A})^{-1}=\frac1{k} {A}^{-1}$&lt;/p&gt;
&lt;p&gt;$(\mathrm{iii})(k {A})’=k {A}’$&lt;/p&gt;
&lt;p&gt;$(\mathrm{iv})\overline{k {A}}=\overline{k}\overline{ {A}}$&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;共轭矩阵&quot;&gt;&lt;a href=&quot;#共轭矩阵&quot; class=&quot;headerlink&quot; title=&quot;共轭矩阵&quot;&gt;&lt;/a&gt;共轭矩阵&lt;/h2&gt;&lt;p&gt;记住以下四个公式，以备突然考到&lt;/p&gt;
&lt;p&gt;$(\mathrm{i})\overline{ {A}+ {B}}=\overline{ {A}}+\overline{ {B}}$&lt;/p&gt;
&lt;p&gt;$(\mathrm{ii})\overline{k {A}}=\overline{k}\overline{ {A}}$&lt;/p&gt;
&lt;p&gt;$(\mathrm{iii})\overline{ {AB}}=\overline{ {A}}\overline{ {B}}$&lt;/p&gt;
&lt;p&gt;$(\mathrm{iv})|\overline{ {A}}|=\overline{| {A}|}$&lt;/p&gt;
&lt;p&gt;简单地记，凡是涉及共轭的题目，计算的时候看起来能取共轭的都取共轭&lt;/p&gt;
&lt;h2 id=&quot;伴随矩阵&quot;&gt;&lt;a href=&quot;#伴随矩阵&quot; class=&quot;headerlink&quot; title=&quot;伴随矩阵&quot;&gt;&lt;/a&gt;伴随矩阵&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;看到$ {A}^*$，以下公式至少用其一&lt;/p&gt;
&lt;p&gt;$(\mathrm{i}) {A}^* {A}= {A} {A}^*=| {A}| {E}$&lt;/p&gt;
&lt;p&gt;$(\mathrm{ii}) {A}^{-1}=\frac{ {A}^*}{| {A}|}$&lt;/p&gt;
&lt;p&gt;$(\mathrm{iii})| {A}^*|=| {A}|^{n-1}$&lt;/p&gt;
&lt;p&gt;$(\mathrm{iv})( {A}^*)^*=| {A}|^{n-2} {A}$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;伴随矩阵的特殊性质：极端的伴随矩阵&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
{R}({A}^*)=\begin{cases} 
    n,\quad {R}({A})=n\\
    1,\quad {R}({A})=n-1\\
    0,\quad {R}({A})&lt;n-1
\end{cases}&lt;/script&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;杂题&quot;&gt;&lt;a href=&quot;#杂题&quot; class=&quot;headerlink&quot; title=&quot;杂题&quot;&gt;&lt;/a&gt;杂题&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;判断矩阵可逆的方法：&lt;/p&gt;
&lt;p&gt;$(\mathrm{i}) {AB}= {BA}=E$&lt;/p&gt;
&lt;p&gt;$(\mathrm{ii}) {R}( {A})=n$&lt;/p&gt;
&lt;p&gt;$(\mathrm{iii})| {A}|=0$&lt;/p&gt;
&lt;p&gt;$(\mathrm{iv}) {A}= {P}_1 {P}_2 \dots  {P}_k$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;初变不变秩，不变奇异性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;行阶梯、行最简、标准形&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;求逆方法：公式法、辅助矩阵法&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;分块矩阵运算&quot;&gt;&lt;a href=&quot;#分块矩阵运算&quot; class=&quot;headerlink&quot; title=&quot;分块矩阵运算&quot;&gt;&lt;/a&gt;分块矩阵运算&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;对角方阵求逆（仅对对角方阵有效）：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\left(\begin {array}{ccc}
    {A}_{11}&amp; &amp; &amp; &amp;\\
     &amp; {A}_{22}&amp; &amp; &amp;\\
     &amp; &amp; \ddots &amp; &amp;\\
     &amp; &amp; &amp; {A}_{ss}&amp;
\end {array}\right)^m
=
\left(\begin {array}{ccc}
    {A}_{11}^m&amp; &amp; &amp; &amp;\\
     &amp; {A}_{22}^m&amp; &amp; &amp;\\
     &amp; &amp; \ddots &amp; &amp;\\
     &amp; &amp; &amp; {A}_{ss}^m&amp;
\end {array}\right)&lt;/script&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;特殊矩阵求逆矩阵，是否还应保持原来的顺序：&lt;/p&gt;
&lt;p&gt;$(\mathrm{i})$主对角：$\searrow$仍为$\searrow$&lt;/p&gt;
&lt;p&gt;$(\mathrm{ii})$次对角：$\swarrow$变为$\nearrow$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;思想：运用&lt;code&gt;第三类初等变换&lt;/code&gt;&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\left|\begin{array}{cccc} {A} &amp; {C} \\ {D} &amp; {B} \end{array} \right|=|{A}||{B}-{DA}^{-1}{C}|&lt;/script&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分块矩阵的秩（高频使用，按重要性降序排列）：&lt;/p&gt;
&lt;p&gt;$(\mathrm{i})R(A+B)\leq R(A)+R(B),\quad R(A-B)\leq R(A)+R(B)$&lt;/p&gt;
&lt;p&gt;$(\mathrm{ii})R(AB)\leq min\{R(A),R(B)\}$&lt;/p&gt;
&lt;p&gt;$(\mathrm{iii})R(A|B)\leq R(A)+R(B),\quad R(\frac{A}{B})\leq R(A)+R(B)$&lt;/p&gt;
&lt;p&gt;$(\mathrm{iv})R \left(\begin{array}{ccc} A &amp;amp; 0\\0 &amp;amp; B \end{array} \right)=R(A)+R(B)$&lt;/p&gt;
&lt;p&gt;$(\mathrm{v})R \left(\begin{array}{ccc} A &amp;amp; C\\0 &amp;amp; B \end{array} \right)\ge R(A)+R(B)$，若$A$，$B$其一可逆则取等&lt;/p&gt;
&lt;p&gt;$(\mathrm{vi})$设$A$为$m\times n$矩阵，$B$为$n\times p$矩阵（有时题目条件会简化为$A$、$B$为同阶方阵），则$R(AB) \ge R(A)+R(B)-n$；特别地，当$AB=0$时，$R(A)+R(B)\le n$&lt;/p&gt;
&lt;p&gt;$(\mathrm{iii})(\mathrm{iv})(\mathrm{v})$皆易证&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="线性代数" scheme="https://G-SS-Hacker.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>行列式章节总结</title>
    <link href="https://g-ss-hacker.github.io/%E8%A1%8C%E5%88%97%E5%BC%8F%E7%AB%A0%E8%8A%82%E6%80%BB%E7%BB%93/"/>
    <id>https://g-ss-hacker.github.io/%E8%A1%8C%E5%88%97%E5%BC%8F%E7%AB%A0%E8%8A%82%E6%80%BB%E7%BB%93/</id>
    <published>2019-10-27T06:37:35.000Z</published>
    <updated>2019-11-28T14:49:43.966Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/10/27/y2VaJbGAj3O6uxW.png" alt></p><h1 id="行列式章节总结"><a href="#行列式章节总结" class="headerlink" title="行列式章节总结"></a>行列式章节总结</h1><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><br>行列式形式优美，应用广泛。但是笔者相当头痛行列式的计算问题和行列式等式的证明问题。为了让行列式计算与证明不那么难算，笔者从题海中抽象出行列式计算和证明的常用算法和性质。作者水平不高，将就看看吧 ╮(╯_╰)╭<p></p><h2 id="行列式计算公式"><a href="#行列式计算公式" class="headerlink" title="行列式计算公式"></a>行列式计算公式</h2><p><strong>1.行列式定义</strong></p><script type="math/tex; mode=display">\left|\begin{array}{cccc}    a_{11} &    a_{12} &    \dots &     a_{1n}\\    a_{21} &    a_{22} &     \dots &     a_{2n}\\    \vdots &    \vdots &           &     \vdots\\    a_{n1} &    a_{n2} &     \dots &     a_{nn}\\\end{array}\right|= \sum(-1)^{t(p_1p_2\dots p_n)}a_{p_11}a_{p_22}\dots a_{p_nn}</script><p>特别地，对于二阶和三阶行列式，可直接用<code>对角线法则</code>求出结果。</p><p><strong>2.行列式展开定理</strong></p><p><strong>引理</strong>    如果$n$阶行列式$D$中第$i$行（列）所有元素除$a_{ij}$外都是零，那么，$D$等于$a_{ij}$与它的代数余子式$A_{ij}$的乘积，即$D=a_{ij}A_{ij}$。</p><p><strong>展开定理</strong>     行列式等于它的任一行（列）的各元素与其代数余子式的乘积之和，即</p><script type="math/tex; mode=display">D=a_{i1}A_{i1}+a_{i2}A_{i2}+\dots a_{in}A_{in},\quad i=1,2,\dots,n;\\D=a_{1j}A_{1j}+a_{2j}A_{2j}+\dots a_{nj}A_{nj},\quad j=1,2,\dots,n.</script><p><strong>推论</strong>    行列式$D$的任一行（列）元素与另一行（列）对应元素的代数余子式乘积之和等于$0$，即</p><script type="math/tex; mode=display">a_{i1}A_{j1}+a_{i2}A_{j2}+\dots a_{in}A_{jn}=0,\quad i \ne j,\quad i,j=1,2,\dots ,n;\\a_{1i}A_{1j}+a_{2i}A_{2j}+\dots a_{ni}A_{nj}=0,\quad i \ne j,\quad i,j=1,2,\dots ,n.</script><p>行列式结果等于$0$的定理常用于填空题和判断题。</p><p><strong>3.范德蒙定理</strong></p><p>范德蒙定理的证明用到了<code>第二数学归纳法</code>，在行列式和矩阵中，任何看起来可以用<code>数学归纳法</code>证明的题目（甚至包括一部分计算题），都可以用<code>数学归纳法</code>来做。</p><script type="math/tex; mode=display">D_n=\left|\begin{array}{cccc}    1 &    1 &    \dots &     1\\    x_1 &    x_2 &     \dots &     x_n\\    x_1^2& x_2^2& \dots & x_n^2\\    \vdots &    \vdots &           &     \vdots\\    x_1^{n-1} &    x_2^{n-1} &     \dots &     x_n^{n-1}\\\end{array}\right|= \prod_{1\leq j<i \leq n}(x_i-x_j),\quad n \ge 2</script><p>简单地记就是，每两个不同的项全部按顺序作差乘一遍。</p><p><strong>4.凯恩法则</strong></p><p>遇见线性方程组就上凯恩法则，把消元问题化为行列式计算问题。</p><a id="more"></a><h2 id="行列式七条性质"><a href="#行列式七条性质" class="headerlink" title="行列式七条性质"></a>行列式七条性质</h2><p>行列式七条性质常用与选择题和填空题，以及某些命题的证明，计算时得出来的结果要么为$0$，要么为题目所给行列式的值得整数倍。</p><p><strong>1.行列式与其转置相等</strong></p><p><strong>2.互换两行（列）变号</strong></p><p><strong>3.两行（列）相同为零</strong></p><p><strong>4.行（列）提公因子</strong></p><p><strong>5.两行（列）成比例为零</strong></p><p><strong>6.如果行列式的某一行（列）是两项和的形式，那么这个行列式就等于两个行列式的和</strong></p><p><strong>7.某行（列）的倍数加到另一行（列），行列式不变</strong></p><h2 id="杂题"><a href="#杂题" class="headerlink" title="杂题"></a>杂题</h2><p><strong>1.</strong> $|kA|=k^n|A|,\quad |A^m|=|A|^m,\quad A_{n \times n}$</p><p><strong>2.</strong>行列式乘法定理： $|AB|=|A||B|,\quad A_{n \times n},\quad B_{n \times n}$</p><p>然而，$|A+B|\ne|A|+|B|$</p><p><strong>3.</strong> $|A^m|=|A|^m,\quad A_{n \times n}$</p><p><strong>4.</strong> $|A’|=|A|,\quad A_{n\times n}$</p><p><strong>5.</strong> $A^*A=AA^*=|A|E$</p><p><strong>6.</strong>$A^{-1}=\frac{A^*}{|A|}$</p><p><strong>7.</strong>$|A^{*}|=|A|^{n-1},\quad A^{*}=|A|A^{-1}$</p><p><strong>8.</strong>$(A^{*})^{*}=|A|^{n-2}A$</p><p><strong>9.</strong>若$A\sim B$，则$|A|=|B|$</p><p><strong>10.</strong>$|A^{-1}|=\frac1{|A|}$</p><h2 id="分块矩阵的行列式"><a href="#分块矩阵的行列式" class="headerlink" title="分块矩阵的行列式"></a>分块矩阵的行列式</h2><p><strong>1.对角形</strong></p><p>对方阵$A_{11},A_{22},\dots A_{ss}$，若满足主对角线上的三角形，则其构成的行列式结果为</p><script type="math/tex; mode=display">|A_{11}||A_{22}|\dots |A_{ss}|</script><p>对方阵$A_{11},A_{22},\dots A_{ss}$，若满足次对角线上的三角形，则其构成的行列式结果为</p><script type="math/tex; mode=display">(-1)^{m \times n}|A_{11}||A_{22}|\dots |A_{ss}|</script><p><strong>2.在非常严苛的条件下以下等式成立。</strong></p><script type="math/tex; mode=display">\left|\begin{array}{cccc} A & B \\ C & D \end{array} \right|=|AD-CB|,\quad AC=CA</script><p><strong>3.</strong>$|\lambda E_m -AB|=\lambda^{m-n}|\lambda E_n-BA|,\quad A_{m \times n},\quad B_{n \times m},\quad m &gt; n$</p><p>该公式的证明运用了分块方阵的<code>第三类初等变换</code>（第三类初等变换不改变分块方阵的行列式的值），这是一个重要的思想，是分块矩阵行列式运算的根本方法，常用于分块方阵的计算和证明中。</p><p><strong>4.</strong>令$n=1$，$|\lambda E_m-\alpha \beta’|=\lambda^{m-1}|\lambda-\beta’\alpha|$，$\alpha$，$\beta$为$m\times 1$向量</p><p><strong>5.</strong>令$\lambda=1$，$|E_m-AB|=|En-BA|$</p><p><strong>6.</strong>令$m=n$，$|\lambda E_m-AB|=|\lambda E_n-BA|$</p><!--more--><hr><p>~<font color="#FF7F27"><strong>我们遇到什么困难也不要怕，微笑着面对它！消除恐惧的最好办法就是面对恐惧！坚持就是胜利！加油！奥利给！</strong></font>~</p><blockquote><p>图：刺客伍六七</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/10/27/y2VaJbGAj3O6uxW.png&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;行列式章节总结&quot;&gt;&lt;a href=&quot;#行列式章节总结&quot; class=&quot;headerlink&quot; title=&quot;行列式章节总结&quot;&gt;&lt;/a&gt;行列式章节总结&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;br&gt;行列式形式优美，应用广泛。但是笔者相当头痛行列式的计算问题和行列式等式的证明问题。为了让行列式计算与证明不那么难算，笔者从题海中抽象出行列式计算和证明的常用算法和性质。作者水平不高，将就看看吧 ╮(╯_╰)╭&lt;p&gt;&lt;/p&gt;
&lt;h2 id=&quot;行列式计算公式&quot;&gt;&lt;a href=&quot;#行列式计算公式&quot; class=&quot;headerlink&quot; title=&quot;行列式计算公式&quot;&gt;&lt;/a&gt;行列式计算公式&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1.行列式定义&lt;/strong&gt;&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\left|\begin{array}{cccc}
    a_{11} &amp;    a_{12} &amp;    \dots &amp;     a_{1n}\\
    a_{21} &amp;    a_{22} &amp;     \dots &amp;     a_{2n}\\
    \vdots &amp;    \vdots &amp;           &amp;     \vdots\\
    a_{n1} &amp;    a_{n2} &amp;     \dots &amp;     a_{nn}\\
\end{array}\right|
= 
\sum(-1)^{t(p_1p_2\dots p_n)}a_{p_11}a_{p_22}\dots a_{p_nn}&lt;/script&gt;&lt;p&gt;特别地，对于二阶和三阶行列式，可直接用&lt;code&gt;对角线法则&lt;/code&gt;求出结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.行列式展开定理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;引理&lt;/strong&gt;    如果$n$阶行列式$D$中第$i$行（列）所有元素除$a_{ij}$外都是零，那么，$D$等于$a_{ij}$与它的代数余子式$A_{ij}$的乘积，即$D=a_{ij}A_{ij}$。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;展开定理&lt;/strong&gt;     行列式等于它的任一行（列）的各元素与其代数余子式的乘积之和，即&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
D=a_{i1}A_{i1}+a_{i2}A_{i2}+\dots a_{in}A_{in},\quad i=1,2,\dots,n;\\
D=a_{1j}A_{1j}+a_{2j}A_{2j}+\dots a_{nj}A_{nj},\quad j=1,2,\dots,n.&lt;/script&gt;&lt;p&gt;&lt;strong&gt;推论&lt;/strong&gt;    行列式$D$的任一行（列）元素与另一行（列）对应元素的代数余子式乘积之和等于$0$，即&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
a_{i1}A_{j1}+a_{i2}A_{j2}+\dots a_{in}A_{jn}=0,\quad i \ne j,\quad i,j=1,2,\dots ,n;\\
a_{1i}A_{1j}+a_{2i}A_{2j}+\dots a_{ni}A_{nj}=0,\quad i \ne j,\quad i,j=1,2,\dots ,n.&lt;/script&gt;&lt;p&gt;行列式结果等于$0$的定理常用于填空题和判断题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.范德蒙定理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;范德蒙定理的证明用到了&lt;code&gt;第二数学归纳法&lt;/code&gt;，在行列式和矩阵中，任何看起来可以用&lt;code&gt;数学归纳法&lt;/code&gt;证明的题目（甚至包括一部分计算题），都可以用&lt;code&gt;数学归纳法&lt;/code&gt;来做。&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
D_n=
\left|\begin{array}{cccc}
    1 &amp;    1 &amp;    \dots &amp;     1\\
    x_1 &amp;    x_2 &amp;     \dots &amp;     x_n\\
    x_1^2&amp; x_2^2&amp; \dots &amp; x_n^2\\
    \vdots &amp;    \vdots &amp;           &amp;     \vdots\\
    x_1^{n-1} &amp;    x_2^{n-1} &amp;     \dots &amp;     x_n^{n-1}\\
\end{array}\right|
= 
\prod_{1\leq j&lt;i \leq n}(x_i-x_j),\quad n \ge 2&lt;/script&gt;&lt;p&gt;简单地记就是，每两个不同的项全部按顺序作差乘一遍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.凯恩法则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;遇见线性方程组就上凯恩法则，把消元问题化为行列式计算问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="线性代数" scheme="https://G-SS-Hacker.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>高阶求导公式</title>
    <link href="https://g-ss-hacker.github.io/%E9%AB%98%E9%98%B6%E6%B1%82%E5%AF%BC%E5%85%AC%E5%BC%8F/"/>
    <id>https://g-ss-hacker.github.io/%E9%AB%98%E9%98%B6%E6%B1%82%E5%AF%BC%E5%85%AC%E5%BC%8F/</id>
    <published>2019-10-21T09:42:24.000Z</published>
    <updated>2019-12-01T13:07:51.885Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/10/21/qfvbeiV7g8M6N9G.png" alt></p><h1 id="高阶求导公式"><a href="#高阶求导公式" class="headerlink" title="高阶求导公式"></a>高阶求导公式</h1><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><br>$ (1)(a^x)^{(n)}=a^x (\ln a)$<p></p><p>$ (2)(e^{ax})^{(n)} = a^n e ^{ax} $</p><p>$(3)(\sin x)^{(n)}=\sin(x+\frac {n\pi}2)$    </p><p>$(4)(\cos x)^{(n)}=\cos(x+\frac{n\pi}2)$</p><p>$(5)(x^a)^{(n)}=a(a-1)\dots(a-n+1)x^{a-n},若n&gt;a，则导数等于零$</p><p>$(6)[\ln (x+a)]^{(n)}=(-1)^n \frac{(n-1)!}{(x+a)^n}，特别地，令a=0，(\ln x)^{(n)}=(-1)^n\frac{(n-1)!}{x^n}$</p><p>$(7)(\frac1{ax+b})^{(n)}=(-a)^{n} \frac{n!}{(ax+b)^{n+1}}，特别地，令a=1,(\frac1{x+b})=(-1)^n \frac{n!}{(x+b)^{n+1}}$</p><p>$(8)Leibniz公式：[f(x)g(x)]^{(n)}=\sum_{k=0}^n C_n^kf^{(k)}(x)g^{(n-k)}(x)，C_n^k=\frac{n!}{k!(n-k)!)}$</p><a id="more"></a><p>$(9)(f(x)\pm g(x))^{(n)}=f^{(n)}(x)+g^{(n)}(x)$</p><p>$(10)(af(x))^{(n)}=af^{(n)}(x)$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/10/21/qfvbeiV7g8M6N9G.png&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;高阶求导公式&quot;&gt;&lt;a href=&quot;#高阶求导公式&quot; class=&quot;headerlink&quot; title=&quot;高阶求导公式&quot;&gt;&lt;/a&gt;高阶求导公式&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;br&gt;$ (1)(a^x)^{(n)}=a^x (\ln a)$&lt;p&gt;&lt;/p&gt;
&lt;p&gt;$ (2)(e^{ax})^{(n)} = a^n e ^{ax} $&lt;/p&gt;
&lt;p&gt;$(3)(\sin x)^{(n)}=\sin(x+\frac {n\pi}2)$    &lt;/p&gt;
&lt;p&gt;$(4)(\cos x)^{(n)}=\cos(x+\frac{n\pi}2)$&lt;/p&gt;
&lt;p&gt;$(5)(x^a)^{(n)}=a(a-1)\dots(a-n+1)x^{a-n},若n&amp;gt;a，则导数等于零$&lt;/p&gt;
&lt;p&gt;$(6)[\ln (x+a)]^{(n)}=(-1)^n \frac{(n-1)!}{(x+a)^n}，特别地，令a=0，(\ln x)^{(n)}=(-1)^n\frac{(n-1)!}{x^n}$&lt;/p&gt;
&lt;p&gt;$(7)(\frac1{ax+b})^{(n)}=(-a)^{n} \frac{n!}{(ax+b)^{n+1}}，特别地，令a=1,(\frac1{x+b})=(-1)^n \frac{n!}{(x+b)^{n+1}}$&lt;/p&gt;
&lt;p&gt;$(8)Leibniz公式：[f(x)g(x)]^{(n)}=\sum_{k=0}^n C_n^kf^{(k)}(x)g^{(n-k)}(x)，C_n^k=\frac{n!}{k!(n-k)!)}$&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="微积分" scheme="https://G-SS-Hacker.github.io/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>拓扑排序</title>
    <link href="https://g-ss-hacker.github.io/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    <id>https://g-ss-hacker.github.io/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</id>
    <published>2019-10-17T15:17:33.000Z</published>
    <updated>2019-11-26T12:03:02.510Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/10/17/Q4afFcoLyVZz91B.jpg" alt></p><h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><p></p><blockquote><p>拓扑是研究几何图形或空间在连续改变形状后还能保持不变的一些性质的一个学科。它只考虑物体间的位置关系而不考虑它们的形状和大小。</p></blockquote><h2 id="AOV网"><a href="#AOV网" class="headerlink" title="AOV网"></a>AOV网</h2><p>在工程领域，一个大规模工程常被拆分为多个子工程，这些子工程被称为<strong>活动（Activity）</strong>，在有向图中以<strong>顶点（Vertex）</strong>表示活动，以有向边表示活动之间的先后关系，这样的有向图被称为<strong>AOV网（Activity On Vertex Network）</strong>。在AOV网中，如果出现了闭环，就意味着有若干个活动将被无限次重复，工程将永远无法完成；因此，一个具有实用价值的AOV网，必定是一个<strong>有向无环图（DAG，Directed Acyclic Graph）</strong>。</p><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><p>对于一个有向无环图$G=(V,E)$，其拓扑排序是其上顶点的一个线性排序：对于有向边$(u,v)\in E$，顶点$u$在排序中在顶点$v$的前面（如果$G$包含环路，则不可能产生一个线性排序）。可以将$G$上各顶点在一条水平线上从左向右排开，且图的所有边的指向也都是从左向右。拓扑排序并未各顶点上的排序，而是各顶点逻辑上的排序，这种排序可能有不止一种。在工程上，常把一个大规模工程的各个子工程抽象为一个AOV网，用拓扑排序解决工程的调度问题。下面用一个示例说明拓扑排序的具体应用：</p><p>下图（a）表示的是某教授每天早上从起床后到上班前所发生的事情的AOV网。教授必须先完成某些活动，才能完成某些活动；而另一些活动则可以以任意次序完成。在图（a）中，有向边$(u,v)$表示的就是活动$u$必须在活动$v$前完成。图（b）将拓扑排序后的有向无环图在一条水平直线上展示出来。如图（b）所示，该有向无环图所有边的指向都是从左到右。</p><p><img src="https://i.loli.net/2019/10/17/AtgWPhiQ15aXfOb.jpg" alt="a"></p><p><center>（a）</center><br><img src="https://i.loli.net/2019/10/17/ysW6329TM1YHjNF.jpg" alt="b"></p><p><center>（b）</center><br><a id="more"></a></p><h2 id="拓扑排序算法"><a href="#拓扑排序算法" class="headerlink" title="拓扑排序算法"></a>拓扑排序算法</h2><h3 id="1-基于入度的拓扑排序"><a href="#1-基于入度的拓扑排序" class="headerlink" title="1. 基于入度的拓扑排序"></a>1. 基于入度的拓扑排序</h3><p><code>基于入度的拓扑排序算法</code>，又被称为<code>Kahn算法</code>。以下摘选<a href="https://en.wikipedia.org/wiki/Topological_sorting" target="_blank" rel="noopener">维基百科</a>上关于<code>Kahn算法</code>的伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TOPOLOGICAL-SORT(G)</span></span><br><span class="line"></span><br><span class="line">L ← Empty <span class="built_in">list</span> that will contain the sorted elements</span><br><span class="line">S ← Set of all nodes with no incoming edges</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> S is non-empty <span class="keyword">do</span></span><br><span class="line">    remove a node u from S</span><br><span class="line">    insert u into L</span><br><span class="line">    <span class="keyword">for</span> each node v with an edge e from u to v <span class="keyword">do</span></span><br><span class="line">        remove edge e from the graph</span><br><span class="line">        <span class="keyword">if</span> v has no other incoming edges then</span><br><span class="line">            insert v into S</span><br><span class="line"><span class="keyword">if</span> graph has edges then</span><br><span class="line">    <span class="keyword">return</span> error (graph has at least onecycle)</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">return</span> L (a topologically sortedorder)</span><br></pre></td></tr></table></figure><p><code>Kahn算法</code>的基本思想是“走一步，看一步”。从以上伪代码不难看出<code>Kahn算法</code>的步骤：先统计所有顶点的入度，再把入度为零的顶点从图中分离出来，先放在集合$S$中，再从集合$S$中分别取出顶点放入线性表$L$中，然后把这个顶点指向的所有顶点的入度减<code>1</code>，并删除该顶点及所有与其相连的边。重复上述操作，直到所有顶点都被分离出来。若当集合$S$为空集时，线性表$L$中元素个数等于原来图中顶点的个数，则返回$L$，$L$中元素的排列即为该图的一种拓扑排序；若当集合$S$为空集时，线性表$L$中元素个数不等于原来图中顶点的个数，则意味着图中有闭环，返回错误信息，对图进行修改后再进行下一次拓扑排序。</p><p>对于图（a）的例子，首先我们找到入度为零的顶点有“刷牙”和“喂猫”，则把这两个顶点放入集合$S$中，$S=\{“刷牙”, “喂猫”\}$，$L=\varnothing$。</p><p>第一步、在$S$中选取”刷牙“并把该顶点从$S$中删除并放入线性表$L$中，”刷牙“与”洗脸“相连，删除相连的边，”洗脸“的入度减<code>1</code>，新的入度为<code>0</code>，把”洗脸“也放入$S$中。此时$S=\{“洗脸”, “喂猫”\}$，$L=“刷牙”$。</p><p><img src="https://i.loli.net/2019/10/17/ErzPGWtTIp67jMk.jpg" alt></p><p>第二步、在$S$中选取“洗脸”并把该顶点从$S$中删除并放入线性表$L$中，“洗脸”与“吃饭”“更衣”相连，删除相连的边，”吃饭““更衣”的入度减<code>1</code>，新的入度为<code>0</code>，把”吃饭“”更衣“也放入$S$中。此时$S=\{“吃饭”, “更衣”, “喂猫”\}$，$L=“刷牙”\to“洗脸”$。</p><p><img src="https://i.loli.net/2019/10/17/6IbE1rwjioKMSkQ.jpg" alt></p><p>以此类推，第三步到第五步的结果分别如图（3）（4）（5）所示（第六步时$G=\varnothing$），采用同样的步骤，直至$S=\varnothing$，算法结束。</p><p><img src="https://i.loli.net/2019/10/17/HCvbkjRUXqcMZfx.jpg" alt></p><p><center>（3）</center><br><img src="https://i.loli.net/2019/10/17/BTOl3tF974ks5ZR.jpg" alt></p><p><center>（4）</center><br><img src="https://i.loli.net/2019/10/17/ieHNnwm9pJGChd4.jpg" alt></p><p><center>（5）</center></p><h3 id="2-基于深度优先搜索的拓扑排序"><a href="#2-基于深度优先搜索的拓扑排序" class="headerlink" title="2. 基于深度优先搜索的拓扑排序"></a>2. 基于深度优先搜索的拓扑排序</h3><p><code>基于深度优先搜索的拓扑排序算法</code>同样见以下<a href="https://en.wikipedia.org/wiki/Topological_sorting" target="_blank" rel="noopener">维基百科</a>上关于该算法的伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TOPOLOGICAL-SORT(G)</span></span><br><span class="line"></span><br><span class="line">L ← Empty <span class="built_in">list</span> that will contain the sorted nodes</span><br><span class="line">S ← Set of all nodes with no outgoing edges</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> each node v in S <span class="keyword">do</span></span><br><span class="line">    visit(v) </span><br><span class="line">    </span><br><span class="line"><span class="function">function <span class="title">visit</span><span class="params">(node v)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">if</span> v has <span class="keyword">not</span> been visited yet then</span></span><br><span class="line"><span class="function">        mark v as visited</span></span><br><span class="line"><span class="function">        <span class="keyword">for</span> each node u with an edge from u to v <span class="keyword">do</span></span></span><br><span class="line"><span class="function">            <span class="title">visit</span><span class="params">(u)</span></span></span><br><span class="line"><span class="function">        add v to L</span></span><br></pre></td></tr></table></figure><p>这个算法的过程非常直观：先把出度为零的顶点从图中分离出来，放在集合$S$中，再从集合$S$中分别取出顶点，递归访问其父顶点，若该顶点未被访问，则标记为“已访问”；到达递归基础后，将当前顶点放入线性表$L$中，并逐步回溯。</p><p>下证<code>基于DFS的拓扑排序算法</code>生成的是有向无环图的拓扑排序：</p><p>在有向无环图$G=(V,E)$上运行<code>DFS</code>，只需证明对于任意一对顶点$(u,v)\in E$，$u$的返回在$v$之前即可。</p><p>对边$(u,v)\in E $，在调用<code>DFS(v)</code>时，对于即将访问的$u$，不外乎以下两种情况：</p><ol><li><code>DFS(u)</code>未被调用，即$u$未被<code>mark</code>，在当前路搜索路径的<code>DFS</code>树上，$u$是$v$的子节点。</li><li><code>DFS(u)</code>已被调用，即$u$已被<code>mark</code>，则可知<code>DFS(u)</code>在另一条已经完成的搜索路径上返回。</li></ol><p>对于这两种情况，$u$的返回都在$v$之前，得证。</p><h2 id="例题：任务排序问题"><a href="#例题：任务排序问题" class="headerlink" title="例题：任务排序问题"></a>例题：任务排序问题</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>假定你需完成$n$项任务，这些任务之间并非独立，一项任务的执行当且仅当其所有前置任务已经被全部完成。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入的数据包含若干组样例，每个样例的第一行包括两个整数$n$和$m$。$n$是任务的数量，$m$是任务之间先后关系的数量。接下来有$m$行，每行有两个整数$i$和$j$，表示任务$i$的执行必须在任务$j$之前。</p><p>输入结束的标志是一组$n=m=0$的样例。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每一组样例，在一行内输出$n$个整数，每两个整数之间用一个空格隔开，每一行数据表示一种可行的任务排序方案。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 4</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">1 3</span><br><span class="line">1 5</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 4 2 5 3</span><br></pre></td></tr></table></figure><h3 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h3><p>$1 \leq n \leq 100$</p><h3 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h3><h4 id="解法一、Kahn算法"><a href="#解法一、Kahn算法" class="headerlink" title="解法一、Kahn算法"></a>解法一、Kahn算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Run on C++</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">110</span>, MAXM = <span class="number">110</span> * <span class="number">110</span> / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> v, nxt;</span><br><span class="line">&#125;E[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, cnt;</span><br><span class="line"><span class="keyword">int</span> head[MAXN], in[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">E[++cnt].v = v;</span><br><span class="line">E[cnt].nxt = head[u];</span><br><span class="line">head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cnt = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line"><span class="built_in">memset</span>(E, <span class="number">0</span>, <span class="keyword">sizeof</span>(E));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">while</span>(n || m)</span><br><span class="line">&#123;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u, v;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">addedge(u, v);</span><br><span class="line">in[v]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span>(!in[i]) q.push(i);</span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> cur = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cur &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[cur]; i; i = E[i].nxt)</span><br><span class="line"><span class="keyword">if</span>(!--in[E[i].v]) q.push(E[i].v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解法二、DFS"><a href="#解法二、DFS" class="headerlink" title="解法二、DFS"></a>解法二、DFS</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Run on C++</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">110</span>, MAXM = <span class="number">110</span> * <span class="number">110</span> / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> u, nxt;</span><br><span class="line">&#125;E[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, cnt;</span><br><span class="line"><span class="keyword">int</span> head[MAXN], out[MAXN];</span><br><span class="line"><span class="keyword">bool</span> flag[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">E[++cnt].u = u;</span><br><span class="line">E[cnt].nxt = head[v];</span><br><span class="line">head[v] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cnt = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line"><span class="built_in">memset</span>(E, <span class="number">0</span>, <span class="keyword">sizeof</span>(E));</span><br><span class="line"><span class="built_in">memset</span>(out, <span class="number">0</span>, <span class="keyword">sizeof</span>(out));</span><br><span class="line"><span class="built_in">memset</span>(flag, <span class="number">0</span>, <span class="keyword">sizeof</span>(flag));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!flag[V]) </span><br><span class="line">&#123;</span><br><span class="line">flag[V] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[V]; i; i = E[i].nxt)</span><br><span class="line">dfs(E[i].u);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; V &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">while</span>(n || m)</span><br><span class="line">&#123;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u, v;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">addedge(u, v);</span><br><span class="line">out[u]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span>(!out[i]) q.push(i);</span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">dfs(q.front());</span><br><span class="line">q.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/10/17/Q4afFcoLyVZz91B.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;拓扑排序&quot;&gt;&lt;a href=&quot;#拓扑排序&quot; class=&quot;headerlink&quot; title=&quot;拓扑排序&quot;&gt;&lt;/a&gt;拓扑排序&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;拓扑是研究几何图形或空间在连续改变形状后还能保持不变的一些性质的一个学科。它只考虑物体间的位置关系而不考虑它们的形状和大小。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;AOV网&quot;&gt;&lt;a href=&quot;#AOV网&quot; class=&quot;headerlink&quot; title=&quot;AOV网&quot;&gt;&lt;/a&gt;AOV网&lt;/h2&gt;&lt;p&gt;在工程领域，一个大规模工程常被拆分为多个子工程，这些子工程被称为&lt;strong&gt;活动（Activity）&lt;/strong&gt;，在有向图中以&lt;strong&gt;顶点（Vertex）&lt;/strong&gt;表示活动，以有向边表示活动之间的先后关系，这样的有向图被称为&lt;strong&gt;AOV网（Activity On Vertex Network）&lt;/strong&gt;。在AOV网中，如果出现了闭环，就意味着有若干个活动将被无限次重复，工程将永远无法完成；因此，一个具有实用价值的AOV网，必定是一个&lt;strong&gt;有向无环图（DAG，Directed Acyclic Graph）&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;绪论&quot;&gt;&lt;a href=&quot;#绪论&quot; class=&quot;headerlink&quot; title=&quot;绪论&quot;&gt;&lt;/a&gt;绪论&lt;/h2&gt;&lt;p&gt;对于一个有向无环图$G=(V,E)$，其拓扑排序是其上顶点的一个线性排序：对于有向边$(u,v)\in E$，顶点$u$在排序中在顶点$v$的前面（如果$G$包含环路，则不可能产生一个线性排序）。可以将$G$上各顶点在一条水平线上从左向右排开，且图的所有边的指向也都是从左向右。拓扑排序并未各顶点上的排序，而是各顶点逻辑上的排序，这种排序可能有不止一种。在工程上，常把一个大规模工程的各个子工程抽象为一个AOV网，用拓扑排序解决工程的调度问题。下面用一个示例说明拓扑排序的具体应用：&lt;/p&gt;
&lt;p&gt;下图（a）表示的是某教授每天早上从起床后到上班前所发生的事情的AOV网。教授必须先完成某些活动，才能完成某些活动；而另一些活动则可以以任意次序完成。在图（a）中，有向边$(u,v)$表示的就是活动$u$必须在活动$v$前完成。图（b）将拓扑排序后的有向无环图在一条水平直线上展示出来。如图（b）所示，该有向无环图所有边的指向都是从左到右。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/10/17/AtgWPhiQ15aXfOb.jpg&quot; alt=&quot;a&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;（a）&lt;/center&gt;&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2019/10/17/ysW6329TM1YHjNF.jpg&quot; alt=&quot;b&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;（b）&lt;/center&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="C-plus-plus" scheme="https://G-SS-Hacker.github.io/tags/C-plus-plus/"/>
    
      <category term="算法" scheme="https://G-SS-Hacker.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="https://G-SS-Hacker.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="数据结构" scheme="https://G-SS-Hacker.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="图论" scheme="https://G-SS-Hacker.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>高等数学公式</title>
    <link href="https://g-ss-hacker.github.io/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"/>
    <id>https://g-ss-hacker.github.io/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</id>
    <published>2019-10-13T14:49:17.000Z</published>
    <updated>2019-12-02T12:54:14.059Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1570988493976&amp;di=831446d27114ecbfec8880afa48584ea&amp;imgtype=0&amp;src=http%3A%2F%2Fimg.mp.itc.cn%2Fupload%2F20160511%2F28084d3cb772429b8546dbd5b302ff89_th.jpg" alt></p><h1 id="高等数学公式"><a href="#高等数学公式" class="headerlink" title="高等数学公式"></a>高等数学公式</h1><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><p></p><h2 id="立方公式"><a href="#立方公式" class="headerlink" title="立方公式"></a>立方公式</h2><h3 id="1-立方和公式"><a href="#1-立方和公式" class="headerlink" title="1.立方和公式"></a>1.立方和公式</h3><p>$a^3+b^3=(a+b)(a^2-ab+b^2)$</p><h3 id="2-立方差公式"><a href="#2-立方差公式" class="headerlink" title="2.立方差公式"></a>2.立方差公式</h3><p>$a^3-b^3=(a-b)(a^2+ab+b^2)$</p><h3 id="3-三项立方和公式"><a href="#3-三项立方和公式" class="headerlink" title="3.三项立方和公式"></a>3.三项立方和公式</h3><p>$a^3+b^3+c^3-abc=(a+b+c)(a^2+b^2+c^2-ab-bc-ac)$</p><h3 id="4-完全立方和公式"><a href="#4-完全立方和公式" class="headerlink" title="4.完全立方和公式"></a>4.完全立方和公式</h3><p>$(a+b)^3=a^3+3a^2b+3ab^2+b^3$</p><p>$(a-b)^3=a^3-3a^2b+3ab^2-b^3$</p><h3 id="5-立方和累加"><a href="#5-立方和累加" class="headerlink" title="5.立方和累加"></a>5.立方和累加</h3><p>$1^3+2^3+\ldots +n^3=[\frac{n(n+1)}{2}]^2=(1+2+\ldots+n)^2$</p><hr><h2 id="和差化积公式"><a href="#和差化积公式" class="headerlink" title="和差化积公式"></a>和差化积公式</h2><p>$\sin \alpha+\sin \beta=2\sin \frac{\alpha+ \beta}{2} \cos \frac{\alpha- \beta}{2}$</p><p>$\sin \alpha-\sin\beta=2\cos \frac{\alpha+ \beta}{2}\sin \frac{\alpha- \beta}{2}$</p><p>$\cos \alpha+\cos \beta=2\cos \frac{\alpha + \beta}{2}\cos \frac{\alpha- \beta}{2}$</p><p>$\cos \alpha - \cos \beta=-2\sin \frac{\alpha+ \beta}{2}\sin \frac{\alpha- \beta}{2}$</p><hr><h2 id="积化和差公式"><a href="#积化和差公式" class="headerlink" title="积化和差公式"></a>积化和差公式</h2><p>$\sin \alpha \sin \beta=\frac12[\sin(\alpha + \beta)+\sin(\alpha - \beta)]$</p><p>$\sin \alpha \cos \beta=\frac12[\sin(\alpha + \beta)-\sin(\alpha - \beta)]$</p><p>$\cos \alpha \sin \beta=\frac12[\cos(\alpha + \beta)+\cos(\alpha - \beta)]$</p><p>$\cos \alpha \cos \beta=\frac12[cos(\alpha + \beta)-cos(\alpha - \beta)]$</p><hr><a id="more"></a><h2 id="万能公式"><a href="#万能公式" class="headerlink" title="万能公式"></a>万能公式</h2><p>$\sin \theta=\frac{2\tan \frac{\theta}{2}}{1+\tan^2\frac{\theta}{2}}$</p><p>$\cos \theta=\frac{1-\tan^2\frac{\theta}{2}}{1+\tan^2\frac{\theta}{2}}$</p><p>$\tan \theta=\frac{2\tan \frac{\theta}{2}}{1-\tan^2 \frac{\theta}{2}}$</p><hr><p>​    </p><h2 id="平方和拓展"><a href="#平方和拓展" class="headerlink" title="平方和拓展"></a>平方和拓展</h2><p>$1^2+2^2+\ldots+n^2=\frac1{6}n(n+1)(2n+1)$</p><p>$1\times2+2\times3+\ldots+n(n+1)=n(n+1)(n+2)$</p><hr><h2 id="裂项相消"><a href="#裂项相消" class="headerlink" title="裂项相消"></a>裂项相消</h2><p>$\frac1{n(n+1)(n+2)}=\frac12[\frac1{n(n+1)}-\frac1{(n+1)(n+2)}]$</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1570988493976&amp;amp;di=831446d27114ecbfec8880afa48584ea&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fimg.mp.itc.cn%2Fupload%2F20160511%2F28084d3cb772429b8546dbd5b302ff89_th.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;高等数学公式&quot;&gt;&lt;a href=&quot;#高等数学公式&quot; class=&quot;headerlink&quot; title=&quot;高等数学公式&quot;&gt;&lt;/a&gt;高等数学公式&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;h2 id=&quot;立方公式&quot;&gt;&lt;a href=&quot;#立方公式&quot; class=&quot;headerlink&quot; title=&quot;立方公式&quot;&gt;&lt;/a&gt;立方公式&lt;/h2&gt;&lt;h3 id=&quot;1-立方和公式&quot;&gt;&lt;a href=&quot;#1-立方和公式&quot; class=&quot;headerlink&quot; title=&quot;1.立方和公式&quot;&gt;&lt;/a&gt;1.立方和公式&lt;/h3&gt;&lt;p&gt;$a^3+b^3=(a+b)(a^2-ab+b^2)$&lt;/p&gt;
&lt;h3 id=&quot;2-立方差公式&quot;&gt;&lt;a href=&quot;#2-立方差公式&quot; class=&quot;headerlink&quot; title=&quot;2.立方差公式&quot;&gt;&lt;/a&gt;2.立方差公式&lt;/h3&gt;&lt;p&gt;$a^3-b^3=(a-b)(a^2+ab+b^2)$&lt;/p&gt;
&lt;h3 id=&quot;3-三项立方和公式&quot;&gt;&lt;a href=&quot;#3-三项立方和公式&quot; class=&quot;headerlink&quot; title=&quot;3.三项立方和公式&quot;&gt;&lt;/a&gt;3.三项立方和公式&lt;/h3&gt;&lt;p&gt;$a^3+b^3+c^3-abc=(a+b+c)(a^2+b^2+c^2-ab-bc-ac)$&lt;/p&gt;
&lt;h3 id=&quot;4-完全立方和公式&quot;&gt;&lt;a href=&quot;#4-完全立方和公式&quot; class=&quot;headerlink&quot; title=&quot;4.完全立方和公式&quot;&gt;&lt;/a&gt;4.完全立方和公式&lt;/h3&gt;&lt;p&gt;$(a+b)^3=a^3+3a^2b+3ab^2+b^3$&lt;/p&gt;
&lt;p&gt;$(a-b)^3=a^3-3a^2b+3ab^2-b^3$&lt;/p&gt;
&lt;h3 id=&quot;5-立方和累加&quot;&gt;&lt;a href=&quot;#5-立方和累加&quot; class=&quot;headerlink&quot; title=&quot;5.立方和累加&quot;&gt;&lt;/a&gt;5.立方和累加&lt;/h3&gt;&lt;p&gt;$1^3+2^3+\ldots +n^3=[\frac{n(n+1)}{2}]^2=(1+2+\ldots+n)^2$&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;和差化积公式&quot;&gt;&lt;a href=&quot;#和差化积公式&quot; class=&quot;headerlink&quot; title=&quot;和差化积公式&quot;&gt;&lt;/a&gt;和差化积公式&lt;/h2&gt;&lt;p&gt;$\sin \alpha+\sin \beta=2\sin \frac{\alpha+ \beta}{2} \cos \frac{\alpha- \beta}{2}$&lt;/p&gt;
&lt;p&gt;$\sin \alpha-\sin\beta=2\cos \frac{\alpha+ \beta}{2}\sin \frac{\alpha- \beta}{2}$&lt;/p&gt;
&lt;p&gt;$\cos \alpha+\cos \beta=2\cos \frac{\alpha + \beta}{2}\cos \frac{\alpha- \beta}{2}$&lt;/p&gt;
&lt;p&gt;$\cos \alpha - \cos \beta=-2\sin \frac{\alpha+ \beta}{2}\sin \frac{\alpha- \beta}{2}$&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;积化和差公式&quot;&gt;&lt;a href=&quot;#积化和差公式&quot; class=&quot;headerlink&quot; title=&quot;积化和差公式&quot;&gt;&lt;/a&gt;积化和差公式&lt;/h2&gt;&lt;p&gt;$\sin \alpha \sin \beta=\frac12[\sin(\alpha + \beta)+\sin(\alpha - \beta)]$&lt;/p&gt;
&lt;p&gt;$\sin \alpha \cos \beta=\frac12[\sin(\alpha + \beta)-\sin(\alpha - \beta)]$&lt;/p&gt;
&lt;p&gt;$\cos \alpha \sin \beta=\frac12[\cos(\alpha + \beta)+\cos(\alpha - \beta)]$&lt;/p&gt;
&lt;p&gt;$\cos \alpha \cos \beta=\frac12[cos(\alpha + \beta)-cos(\alpha - \beta)]$&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="微积分" scheme="https://G-SS-Hacker.github.io/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>常用等价无穷小</title>
    <link href="https://g-ss-hacker.github.io/%E5%B8%B8%E7%94%A8%E7%AD%89%E4%BB%B7%E6%97%A0%E7%A9%B7%E5%B0%8F/"/>
    <id>https://g-ss-hacker.github.io/%E5%B8%B8%E7%94%A8%E7%AD%89%E4%BB%B7%E6%97%A0%E7%A9%B7%E5%B0%8F/</id>
    <published>2019-10-13T13:43:36.000Z</published>
    <updated>2019-10-15T16:48:29.195Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/10/13/z8NK7uv6wXtTFS5.jpg" alt></p><h1 id="常用等价无穷小"><a href="#常用等价无穷小" class="headerlink" title="常用等价无穷小"></a>常用等价无穷小</h1><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><p></p><h2 id="基础版"><a href="#基础版" class="headerlink" title="基础版"></a>基础版</h2><p>当$x\to0$时，</p><p>$(1)\sin x \sim x$</p><p>$(2)\tan x \sim x$</p><p>$(3)\arcsin x \sim x$</p><p>$(4)\arctan x \sim x$</p><p>$(5)1-\cos x \sim \frac12 x^2$</p><p>$(6)a^x-1 \sim x \ln a$</p><p>$(7)e^x-1 \sim x$</p><p>$(8)(1+x)^a-1 \sim ax$<sup><a href="#fn_ *" id="reffn_ *"> *</a></sup></p><p>$(9)\ln (1+x) \sim x$</p><p>$(10)\sqrt{1+x}-1 \sim \frac12x$</p><a id="more"></a><h2 id="进阶版"><a href="#进阶版" class="headerlink" title="进阶版"></a>进阶版</h2><p>当$x\to0$时，</p><p>$(11)\log_a(1+x) \sim \frac{x}{\ln a}$</p><p>$(12)\sqrt[n]{1+x}-1\sim \frac{x}{n}$</p><p>$(13)x-\sin x\sim \frac16x^3$</p><p>$(14)\tan x-x\sim\frac13x^3$</p><p>$(15)\arcsin x-x\sim\frac16x^3$</p><p>$(16)x-\arctan x\sim \frac13x^3$</p><p>$(17)\tan x-\sin x\sim \frac12x^3$</p><hr><blockquote id="fn_ *"><sup> *</sup>. 见<code>Bernoulli</code>不等式：$(1+x)^n \ge 1+nx$<a href="#reffn_ *" title="Jump back to footnote [ *] in the text."> &#8617;</a></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/10/13/z8NK7uv6wXtTFS5.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;常用等价无穷小&quot;&gt;&lt;a href=&quot;#常用等价无穷小&quot; class=&quot;headerlink&quot; title=&quot;常用等价无穷小&quot;&gt;&lt;/a&gt;常用等价无穷小&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;h2 id=&quot;基础版&quot;&gt;&lt;a href=&quot;#基础版&quot; class=&quot;headerlink&quot; title=&quot;基础版&quot;&gt;&lt;/a&gt;基础版&lt;/h2&gt;&lt;p&gt;当$x\to0$时，&lt;/p&gt;
&lt;p&gt;$(1)\sin x \sim x$&lt;/p&gt;
&lt;p&gt;$(2)\tan x \sim x$&lt;/p&gt;
&lt;p&gt;$(3)\arcsin x \sim x$&lt;/p&gt;
&lt;p&gt;$(4)\arctan x \sim x$&lt;/p&gt;
&lt;p&gt;$(5)1-\cos x \sim \frac12 x^2$&lt;/p&gt;
&lt;p&gt;$(6)a^x-1 \sim x \ln a$&lt;/p&gt;
&lt;p&gt;$(7)e^x-1 \sim x$&lt;/p&gt;
&lt;p&gt;$(8)(1+x)^a-1 \sim ax$&lt;sup&gt;&lt;a href=&quot;#fn_ *&quot; id=&quot;reffn_ *&quot;&gt; *&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;$(9)\ln (1+x) \sim x$&lt;/p&gt;
&lt;p&gt;$(10)\sqrt{1+x}-1 \sim \frac12x$&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="微积分" scheme="https://G-SS-Hacker.github.io/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>导数基本公式</title>
    <link href="https://g-ss-hacker.github.io/%E5%AF%BC%E6%95%B0%E5%9F%BA%E6%9C%AC%E5%85%AC%E5%BC%8F/"/>
    <id>https://g-ss-hacker.github.io/%E5%AF%BC%E6%95%B0%E5%9F%BA%E6%9C%AC%E5%85%AC%E5%BC%8F/</id>
    <published>2019-10-13T08:47:40.000Z</published>
    <updated>2019-10-13T13:27:20.998Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/10/13/e4F7haguPTV1UrG.jpg" alt></p><h1 id="导数基本公式"><a href="#导数基本公式" class="headerlink" title="导数基本公式"></a>导数基本公式</h1><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><br>$(1)(C)’ = 0$<p></p><p>$(2)(x^a)’=ax^{a-1}$</p><p>$(3)(a^x)’=a^x\ln a    (a&gt;0且a\not=1)$</p><p>$(4)(e^x)’=e^x$</p><p>$(5)(\log_ax)’=\frac{1}{x\ln a}(a&gt;0且a\not=1)$</p><p>$(6)(\ln x)’=\frac1{x}$</p><p>$(7)(\sin x)’=\cos x$</p><p>$(8)(\cos x)’=-\sin x$</p><p>$(9)(\tan x)’=\frac1{\cos^2x}=\sec^2x$</p><p>$(10)(\cot x)’=\frac1{-\sin^x}=-\csc^2x$</p><a id="more"></a><p>$(11)(\sec x)’=\sec x\tan x$</p><p>$(12)(\csc x)’=-\csc x\cot x$</p><p>$(13)(\arcsin x)’=\frac1{\sqrt{1-x^2}}$</p><p>$(14)(\arccos x)’=-\frac1{\sqrt{1-x^2}}$</p><p>$(15)(\arctan x)’=\frac1{1+x^2}$</p><p>$(16)(\mathrm{arccot} x)’=-\frac1{1+x^2}$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/10/13/e4F7haguPTV1UrG.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;导数基本公式&quot;&gt;&lt;a href=&quot;#导数基本公式&quot; class=&quot;headerlink&quot; title=&quot;导数基本公式&quot;&gt;&lt;/a&gt;导数基本公式&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;br&gt;$(1)(C)’ = 0$&lt;p&gt;&lt;/p&gt;
&lt;p&gt;$(2)(x^a)’=ax^{a-1}$&lt;/p&gt;
&lt;p&gt;$(3)(a^x)’=a^x\ln a    (a&amp;gt;0且a\not=1)$&lt;/p&gt;
&lt;p&gt;$(4)(e^x)’=e^x$&lt;/p&gt;
&lt;p&gt;$(5)(\log_ax)’=\frac{1}{x\ln a}(a&amp;gt;0且a\not=1)$&lt;/p&gt;
&lt;p&gt;$(6)(\ln x)’=\frac1{x}$&lt;/p&gt;
&lt;p&gt;$(7)(\sin x)’=\cos x$&lt;/p&gt;
&lt;p&gt;$(8)(\cos x)’=-\sin x$&lt;/p&gt;
&lt;p&gt;$(9)(\tan x)’=\frac1{\cos^2x}=\sec^2x$&lt;/p&gt;
&lt;p&gt;$(10)(\cot x)’=\frac1{-\sin^x}=-\csc^2x$&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="微积分" scheme="https://G-SS-Hacker.github.io/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>图的表示</title>
    <link href="https://g-ss-hacker.github.io/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA/"/>
    <id>https://g-ss-hacker.github.io/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA/</id>
    <published>2019-10-08T12:56:45.000Z</published>
    <updated>2019-10-27T06:38:58.269Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/10/08/8NwDaiMFQ7kHndV.png" alt></p><h1 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h1><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><p></p><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><p>对于图 $G=(V,E)$<sup><a href="#fn_ 1" id="reffn_ 1"> 1</a></sup>，可以用多种表示方法来表示，其中不同的表示方法分别适用与<strong>不同特点的图</strong>和<strong>对图进行不同的操作</strong>。在此介绍三种图的表示方法：<strong>邻接表</strong>、<strong>邻接矩阵</strong>和<strong>边集数组</strong>，并将呈现三种存图方法的<code>C</code>和<code>C++</code>代码实现。</p><h2 id="存图方法"><a href="#存图方法" class="headerlink" title="存图方法"></a>存图方法</h2><h3 id="1-邻接矩阵"><a href="#1-邻接矩阵" class="headerlink" title="1.邻接矩阵"></a>1.邻接矩阵</h3><p>邻接矩阵是一种<strong>简单、易用但有较大局限性</strong>的存图方式。由于图是由<strong>点集</strong>和<strong>边集</strong>两部分组成，难以找到一种线性结构来同时表示两者，那么，由于每条特定的边都可由其两端顶点唯一确定（假设无重边），我们很自然地可以想到使用一个$|V|$ $*$ $|V|$的方矩阵$A = (a_{ij})$来表示，对于<strong>无权图</strong>，该矩阵满足：</p><script type="math/tex; mode=display">a_{ij} = \left\{    \begin{array}{}        1, \ (i, j) \in E\\        0, \ (i, j) \notin E    \end{array}\right.</script><p>对于<strong>带权图</strong>，该矩阵满足：</p><script type="math/tex; mode=display">a_{ij} = \left\{    \begin{array}{}        w, \ (i, j) \in E\\        \infty \ or \ 0\ or-1, \ (i, j) \notin E    \end{array}\right.</script><hr><a id="more"></a><p><strong>【例1】</strong></p><p><strong>无向带权图</strong>示例如下图所示：</p><p><img src="https://i.loli.net/2019/10/08/Q3LHBXuIGgOeztS.jpg" alt></p><p>上图对应的邻接矩阵表示如图：</p><script type="math/tex; mode=display">\mathbf{A} =\left( \begin{array}{ccc}a_{11} & a_{12} & a_{13} & a_{14} \\\\a_{21} & a_{22} & a_{23} & a_{24} \\\\a_{31} & a_{32} & a_{33} & a_{34} \\\\a_{41} & a_{42} & a_{43} & a_{44}\end{array} \right)\mathbf{} =\left( \begin{array}{ccc}\infty & 4 & 5 & 7 \\\\4 & \infty & 2 & 2 \\\\5 & 2 & \infty & 3 \\\\7 & 2 & 3 & \infty\end{array} \right)</script><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Run on C/C++</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">4</span>;  <span class="comment">//n个顶点</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;  <span class="comment">//正无穷</span></span><br><span class="line"><span class="keyword">int</span> G[n][n] = &#123;</span><br><span class="line">&#123;inf, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>&#125;, </span><br><span class="line">&#123;<span class="number">4</span>, inf, <span class="number">2</span>, <span class="number">2</span>&#125;, </span><br><span class="line">&#123;<span class="number">5</span>, <span class="number">2</span>, inf, <span class="number">3</span>&#125;, </span><br><span class="line">&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, inf&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>【例2】</strong></p><p><strong>有向带权图</strong>示例如下图所示：</p><p><img src="https://i.loli.net/2019/10/08/2rLUQ5gi9NdXGIs.jpg" alt></p><p>上图对应的邻接矩阵表示如图：</p><script type="math/tex; mode=display">\mathbf{A} =\left( \begin{array}{ccc}a_{11} & a_{12} & a_{13} & a_{14} \\\\a_{21} & a_{22} & a_{23} & a_{24} \\\\a_{31} & a_{32} & a_{33} & a_{34} \\\\a_{41} & a_{42} & a_{43} & a_{44}\end{array} \right)\mathbf{} =\left( \begin{array}{ccc}\infty & 4 & 5 & 7 \\\\0 & \infty & 2 & 2 \\\\0 & 0 & \infty & 3 \\\\0 & 0 & 0 & \infty\end{array} \right)</script><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Run on C/C++</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">4</span>;  <span class="comment">//n个顶点</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;  <span class="comment">//正无穷</span></span><br><span class="line"><span class="keyword">int</span> G[n][n] = &#123;</span><br><span class="line">&#123;inf, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>&#125;, </span><br><span class="line">&#123;<span class="number">0</span>, inf, <span class="number">2</span>, <span class="number">2</span>&#125;, </span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">0</span>, inf, <span class="number">3</span>&#125;, </span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, inf&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>【例1】【例2】</strong>分别给出了<strong>无向无权图</strong>和<strong>有向无权图</strong>的邻接矩阵表示，不管一个图有多少条边，邻接矩阵的空间复杂度都为$O(V^2)$。</p><p>不难看出，无向图的邻接矩阵是一个<strong>对称矩阵</strong>。由于在无向图中，边$(u,v)$与边$(v,u)$表示同一条边，无向图的邻接矩阵$A$就是自己的转置，即$A = A^T$。在存储时，可以只存放<strong>主对角线</strong>及其以上的这部分邻接矩阵（即半个矩阵），从而将图存储空间需求减少几乎一半。</p><p>邻接矩阵表示简单、容易理解，对已知的边操作的效率高（插入、删除、查询的时间复杂度都是$O(1)$。但是邻接矩阵的缺陷在于其空间复杂度巨大，在<strong>稠密图</strong>上邻接矩阵可以取得较好的利用率，但是在<strong>稀疏图</strong><sup><a href="#fn_ 2" id="reffn_ 2"> 2</a></sup>上使用邻接矩阵将会造成大量内存空间的浪费，很容易导致内存溢出。因此，在使用邻接矩阵存图时一定要格外注意内存空间的限制，不可盲目追求简单而忽略了内存空间的优化。</p><hr><h3 id="2-邻接表"><a href="#2-邻接表" class="headerlink" title="2.邻接表"></a>2.邻接表</h3><p>邻接表是一种<strong>具有高度鲁棒性</strong><sup><a href="#fn_ 3" id="reffn_ 3"> 3</a></sup><strong>、适用于大多数情况</strong>的存图方法。对于图$ G = (V,E)$，其邻接表表示由一个包含$|V|$条链表的数组<code>Adj[]</code><sup><a href="#fn_ 4" id="reffn_ 4"> 4</a></sup>所构成，每个顶点有一条链表。对于每个顶点$u\in V$，邻接表<code>Adj[u]</code>包含所有与顶点$u$之间有边相连的顶点$v$，即<code>Adj[u]</code>包含图$G$中所有与$u$邻接的顶点。邻接表本质上是使用链表存边，一条链表代表着一个点发出的所有边，通过链表存储和遍历和一个顶点相连的所有边，并根据实际应用情况选择是否存储边权。在<code>C/C++</code>中，实现邻接表的方法主要有两种：<code>链式向前星</code>和<code>vector</code>存图。</p><p><strong>【例3】</strong></p><p><strong>有向带权图</strong>示例如下图所示：</p><p><img src="https://i.loli.net/2019/10/08/2rLUQ5gi9NdXGIs.jpg" alt></p><p>上图对应的邻接表表示如图：</p><p><img src="https://i.loli.net/2019/10/08/tX9s5WZrmzoIYES.jpg" alt></p><p><code>链式向前星</code>存图法是利用了一种特殊的链表，这种链表具有普通链表链式存储的特征，但其插入新元素的方式却是“向前星”，即从链表表头插入元素，每次只更新表头，因此得名<code>链式向前星</code>。在使用<code>链式向前星</code>时，应很好的理解这种数据结构与普通链表的区别。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链式向前星</span></span><br><span class="line"><span class="comment">//Run on C/C++</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">4</span>, m = <span class="number">6</span>;  <span class="comment">//n个顶点，m条边</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> w, v, nxt;  <span class="comment">//nxt指向同一个顶点发出的另一条边</span></span><br><span class="line">&#125;E[n];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> head[m];  <span class="comment">//假设从0号顶点开始存储</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span>  <span class="comment">//改变编号为cnt的边</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">E[++cnt].v = v;  <span class="comment">//出边指向v</span></span><br><span class="line">E[cnt].w = w;  <span class="comment">//记录边权</span></span><br><span class="line">E[cnt].nxt = head[u];  <span class="comment">//将其指向目前链表的表头（重要！）</span></span><br><span class="line">head[u] = cnt;  <span class="comment">//将表头更新为目前的编号（重要！）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    add(<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>);</span><br><span class="line">    add(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    add(<span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line">    add(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    add(<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>vector</code>存图实际上是利用了一个不定长的链表该存储从一个顶点出发的所有边的情况，与普通链表类似，<code>vector</code>也是从链表的尾端进行插入操作，因此<code>vector</code>存图法在理解难度上比<code>链式向前星</code>要简单。然而由于<code>C/C++</code>语言的原因，使用<code>vector</code>存图实际使用的内存比<code>链式向前星</code>的要大，因此内存溢出的风险也会更大。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vector存图，使用stl::pair版</span></span><br><span class="line"><span class="comment">//Run on C/C++</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">4</span>;  <span class="comment">//n个顶点</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; E[n + <span class="number">1</span>];  <span class="comment">//int（first）为u，int（second）为v</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    E[u].push_back(&#123;v, w&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    add(<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>);</span><br><span class="line">    add(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    add(<span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line">    add(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    add(<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;(<span class="keyword">int</span>)E[i].size(); j++)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>&lt;&lt;E[i][j].first&lt;&lt;<span class="string">" "</span>&lt;&lt;E[i][j].second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vector存图，使用结构体版</span></span><br><span class="line"><span class="comment">//Run on C/C++</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">4</span>;  <span class="comment">//n个顶点</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> v, w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt;E[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    E[u].push_back(&#123;v, w&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    add(<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>);</span><br><span class="line">    add(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    add(<span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line">    add(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    add(<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;(<span class="keyword">int</span>)E[i].size(); j++)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>&lt;&lt;E[i][j].v&lt;&lt;<span class="string">" "</span>&lt;&lt;E[i][j].w&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不管是用<code>链式向前星</code>存图还是<code>vector</code>存图，邻接表的空间复杂度都为$O(E + V)$。与邻接矩阵相比，邻接表的空间复杂度更小，空间利用率更高。但是邻接表使用链式结构存储边，这导致了对边操作的时间复杂度为$O(n)$，因此邻接表并不适用于需要频繁对边操作的情况；对于<strong>稠密图</strong>，邻接表的性能也不比邻接矩阵更占上风。然而，对于不需要频繁对边进行操作的<strong>稀疏图</strong>，使用邻接表存图比使用邻接矩阵存图可以期待更高的效率。综上，邻接表不失为一种性能优秀的存图方法。</p><hr><h3 id="3-边集数组"><a href="#3-边集数组" class="headerlink" title="3.边集数组"></a>3.边集数组</h3><p>边集数组也是一种<strong>简单、易用但有较大局限性</strong>的存图方式。边集数组由一个一维结构体数组<code>e[]</code>构成，数组的每个数据元素由一条边的起点下标（<code>u</code>），终点下标（<code>v</code>）和权值（<code>w</code>）组成，如下图所示。不难看出，边集数组关注<strong>边的集合</strong>，而不关注<strong>点的集合</strong>。因此，使用这种存图方法在需要遍历图的边集时可以获得很高的效率，但是在遍历图的点集时效率简直是灾难。不论一个图有多少个顶点，边集数组的空间复杂度都为$O(E)$。</p><p><strong>【例4】</strong></p><p><strong>有向带权图</strong>示例如下图所示：</p><p><img src="https://i.loli.net/2019/10/08/2rLUQ5gi9NdXGIs.jpg" alt></p><p>上图对应的边集数组如下表所示：</p><div class="table-container"><table><thead><tr><th></th><th>u</th><th>v</th><th>w</th></tr></thead><tbody><tr><td>e[1]</td><td>1</td><td>2</td><td>4</td></tr><tr><td>e[2]</td><td>1</td><td>4</td><td>7</td></tr><tr><td>e[3]</td><td>1</td><td>3</td><td>5</td></tr><tr><td>e[4]</td><td>3</td><td>4</td><td>3</td></tr><tr><td>e[5]</td><td>3</td><td>2</td><td>2</td></tr><tr><td>e[6]</td><td>2</td><td>4</td><td>2</td></tr></tbody></table></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Run on C/C++</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> m = <span class="number">6</span>;  <span class="comment">//m条边</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> u, v, w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">edge E[m] = &#123;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>&#125;, </span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;,</span><br><span class="line">&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>&#125;,</span><br><span class="line">&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>&#125;,</span><br><span class="line">&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>据观察，这种存图方法主要用于实现<strong>最小生成树</strong>的<code>Krusal</code>算法，其他情况下较少使用。</p><hr><blockquote id="fn_ 1"><sup> 1</sup>. 图，graph，记为“G”；顶点，vertex，记为“V”；边，edge，记为“E”。<a href="#reffn_ 1" title="Jump back to footnote [ 1] in the text."> &#8617;</a></blockquote><blockquote id="fn_ 2"><sup> 2</sup>. 稠密图与稀疏图的判断标准：(1)定性分析：稠密图的边数非常接近于完全图（即$n(n-1)$），而稀疏图的边数比完全图少得多。(2)定量分析：边数多于$nlogn$的图为稠密图，边数少于$nlogn$的图为稀疏图。<a href="#reffn_ 2" title="Jump back to footnote [ 2] in the text."> &#8617;</a></blockquote><blockquote id="fn_ 3"><sup> 3</sup>. 鲁棒性，robust，即健壮性<a href="#reffn_ 3" title="Jump back to footnote [ 3] in the text."> &#8617;</a></blockquote><blockquote id="fn_ 4"><sup> 4</sup>. 邻接表，adjlist，记为”Adj”<a href="#reffn_ 4" title="Jump back to footnote [ 4] in the text."> &#8617;</a></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/10/08/8NwDaiMFQ7kHndV.png&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;图的表示&quot;&gt;&lt;a href=&quot;#图的表示&quot; class=&quot;headerlink&quot; title=&quot;图的表示&quot;&gt;&lt;/a&gt;图的表示&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;h2 id=&quot;绪论&quot;&gt;&lt;a href=&quot;#绪论&quot; class=&quot;headerlink&quot; title=&quot;绪论&quot;&gt;&lt;/a&gt;绪论&lt;/h2&gt;&lt;p&gt;对于图 $G=(V,E)$&lt;sup&gt;&lt;a href=&quot;#fn_ 1&quot; id=&quot;reffn_ 1&quot;&gt; 1&lt;/a&gt;&lt;/sup&gt;，可以用多种表示方法来表示，其中不同的表示方法分别适用与&lt;strong&gt;不同特点的图&lt;/strong&gt;和&lt;strong&gt;对图进行不同的操作&lt;/strong&gt;。在此介绍三种图的表示方法：&lt;strong&gt;邻接表&lt;/strong&gt;、&lt;strong&gt;邻接矩阵&lt;/strong&gt;和&lt;strong&gt;边集数组&lt;/strong&gt;，并将呈现三种存图方法的&lt;code&gt;C&lt;/code&gt;和&lt;code&gt;C++&lt;/code&gt;代码实现。&lt;/p&gt;
&lt;h2 id=&quot;存图方法&quot;&gt;&lt;a href=&quot;#存图方法&quot; class=&quot;headerlink&quot; title=&quot;存图方法&quot;&gt;&lt;/a&gt;存图方法&lt;/h2&gt;&lt;h3 id=&quot;1-邻接矩阵&quot;&gt;&lt;a href=&quot;#1-邻接矩阵&quot; class=&quot;headerlink&quot; title=&quot;1.邻接矩阵&quot;&gt;&lt;/a&gt;1.邻接矩阵&lt;/h3&gt;&lt;p&gt;邻接矩阵是一种&lt;strong&gt;简单、易用但有较大局限性&lt;/strong&gt;的存图方式。由于图是由&lt;strong&gt;点集&lt;/strong&gt;和&lt;strong&gt;边集&lt;/strong&gt;两部分组成，难以找到一种线性结构来同时表示两者，那么，由于每条特定的边都可由其两端顶点唯一确定（假设无重边），我们很自然地可以想到使用一个$|V|$ $*$ $|V|$的方矩阵$A = (a_{ij})$来表示，对于&lt;strong&gt;无权图&lt;/strong&gt;，该矩阵满足：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
a_{ij} = 
\left\{
    \begin{array}{}
        1, \ (i, j) \in E\\
        0, \ (i, j) \notin E
    \end{array}
\right.&lt;/script&gt;&lt;p&gt;对于&lt;strong&gt;带权图&lt;/strong&gt;，该矩阵满足：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
a_{ij} = 
\left\{
    \begin{array}{}
        w, \ (i, j) \in E\\
        \infty \ or \ 0\ or-1, \ (i, j) \notin E
    \end{array}
\right.&lt;/script&gt;&lt;hr&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="C" scheme="https://G-SS-Hacker.github.io/tags/C/"/>
    
      <category term="C-plus-plus" scheme="https://G-SS-Hacker.github.io/tags/C-plus-plus/"/>
    
      <category term="算法" scheme="https://G-SS-Hacker.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://G-SS-Hacker.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="图论" scheme="https://G-SS-Hacker.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>排序算法性能比较</title>
    <link href="https://g-ss-hacker.github.io/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/"/>
    <id>https://g-ss-hacker.github.io/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/</id>
    <published>2019-09-28T01:51:41.000Z</published>
    <updated>2019-10-21T11:02:26.327Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/09/28/kF9XINxlEd4wZ8U.jpg" alt></p><h1 id="排序算法性能比较"><a href="#排序算法性能比较" class="headerlink" title="排序算法性能比较"></a>排序算法性能比较</h1><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><p></p><p><style type="text/css"><br>.tg  {border-collapse:collapse;border-spacing:0;}<br>.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}<br>.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}<br>.tg .tg-cly1{text-align:left;vertical-align:middle}<br>.tg .tg-0lax{text-align:left;vertical-align:top}</style></p><table class="tg">  <tr>    <th class="tg-cly1" rowspan="2">类别</th>    <th class="tg-cly1" rowspan="2">排序方法</th>    <th class="tg-cly1" colspan="2">时间复杂度</th>    <th class="tg-0lax" rowspan="2">空间复杂度</th>    <th class="tg-0lax" rowspan="2">稳定性</th>  </tr>  <tr>    <th class="tg-cly1">平均情况</th>    <th class="tg-0lax">最坏情况</th>  </tr>  <tr>    <td class="tg-cly1" rowspan="2">插入排序</td>    <td class="tg-cly1">直接插入</td>    <td class="tg-cly1">O(n<sup>2</sup>)</td>    <td class="tg-0lax">O(n<sup>2</sup>)</td>    <td class="tg-0lax">O(1)</td>    <td class="tg-0lax">稳定</td>  </tr>  <tr>    <td class="tg-cly1">希尔排序</td>    <td class="tg-cly1">O(n<sup>1.3</sup>)<br></td>    <td class="tg-0lax">O(n<sup>2</sup>)</td>    <td class="tg-0lax">O(1）</td>    <td class="tg-0lax">不稳定</td>  </tr>  <tr>    <td class="tg-cly1" rowspan="2">选择排序</td>    <td class="tg-cly1">直接选择</td>    <td class="tg-cly1">O(n<sup>2</sup>)</td>    <td class="tg-0lax">O(n<sup>2</sup>)</td>    <td class="tg-0lax">O(1)</td>    <td class="tg-0lax">不稳定<br></td>  </tr>  <tr>    <td class="tg-cly1">堆排序</td>    <td class="tg-cly1">O(nlogn)</td>    <td class="tg-0lax">O(nlogn)</td>    <td class="tg-0lax">O(1)</td>    <td class="tg-0lax">不稳定</td>  </tr>  <tr>    <td class="tg-cly1" rowspan="2">交换排序</td>    <td class="tg-cly1">冒泡排序</td>    <td class="tg-cly1">O(n<sup>2</sup>)</td>    <td class="tg-0lax">O(n<sup>2</sup>)</td>    <td class="tg-0lax">O(1)</td>    <td class="tg-0lax">稳定</td>  </tr>  <tr>    <td class="tg-cly1">快速排序</td>    <td class="tg-cly1">O(nlogn)</td>    <td class="tg-0lax">O(n<sup>2</sup>)</td>    <td class="tg-0lax">O(logn)</td>    <td class="tg-0lax">不稳定</td>  </tr>  <tr>    <td class="tg-cly1" colspan="2">归并排序</td>    <td class="tg-cly1">O(nlogn)</td>    <td class="tg-0lax">O(nlogn)</td>    <td class="tg-0lax">O(n)</td>    <td class="tg-0lax">稳定</td>  </tr>  <tr>    <td class="tg-cly1" colspan="2">基数排序</td>    <td class="tg-cly1">O(d(r+n))</td>    <td class="tg-0lax">O(d(r+n))</td>    <td class="tg-0lax">O(r+n)</td>    <td class="tg-0lax">稳定</td>  </tr>  <tr>    <td class="tg-cly1" colspan="2">桶排序</td>    <td class="tg-cly1">O(2(m+n))</td>    <td class="tg-0lax">O(2(m+n))</td>    <td class="tg-0lax">O(max{key})</td>    <td class="tg-0lax">稳定</td>    </tr></table><a id="more"></a><p>*注：基数排序中，d表示关键字的位数长度，r表示关键字每一个数位有r中可能的取值</p><p>**注：桶排序中，m表示桶的个数</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/09/28/kF9XINxlEd4wZ8U.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;排序算法性能比较&quot;&gt;&lt;a href=&quot;#排序算法性能比较&quot; class=&quot;headerlink&quot; title=&quot;排序算法性能比较&quot;&gt;&lt;/a&gt;排序算法性能比较&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;style type=&quot;text/css&quot;&gt;&lt;br&gt;.tg  {border-collapse:collapse;border-spacing:0;}&lt;br&gt;.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}&lt;br&gt;.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}&lt;br&gt;.tg .tg-cly1{text-align:left;vertical-align:middle}&lt;br&gt;.tg .tg-0lax{text-align:left;vertical-align:top}
&lt;/style&gt;&lt;/p&gt;
&lt;table class=&quot;tg&quot;&gt;
  &lt;tr&gt;
    &lt;th class=&quot;tg-cly1&quot; rowspan=&quot;2&quot;&gt;类别&lt;/th&gt;
    &lt;th class=&quot;tg-cly1&quot; rowspan=&quot;2&quot;&gt;排序方法&lt;/th&gt;
    &lt;th class=&quot;tg-cly1&quot; colspan=&quot;2&quot;&gt;时间复杂度&lt;/th&gt;
    &lt;th class=&quot;tg-0lax&quot; rowspan=&quot;2&quot;&gt;空间复杂度&lt;/th&gt;
    &lt;th class=&quot;tg-0lax&quot; rowspan=&quot;2&quot;&gt;稳定性&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;th class=&quot;tg-cly1&quot;&gt;平均情况&lt;/th&gt;
    &lt;th class=&quot;tg-0lax&quot;&gt;最坏情况&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-cly1&quot; rowspan=&quot;2&quot;&gt;插入排序&lt;/td&gt;
    &lt;td class=&quot;tg-cly1&quot;&gt;直接插入&lt;/td&gt;
    &lt;td class=&quot;tg-cly1&quot;&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;O(1)&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;稳定&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-cly1&quot;&gt;希尔排序&lt;/td&gt;
    &lt;td class=&quot;tg-cly1&quot;&gt;O(n&lt;sup&gt;1.3&lt;/sup&gt;)&lt;br&gt;&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;O(1）&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;不稳定&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-cly1&quot; rowspan=&quot;2&quot;&gt;选择排序&lt;/td&gt;
    &lt;td class=&quot;tg-cly1&quot;&gt;直接选择&lt;/td&gt;
    &lt;td class=&quot;tg-cly1&quot;&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;O(1)&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;不稳定&lt;br&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-cly1&quot;&gt;堆排序&lt;/td&gt;
    &lt;td class=&quot;tg-cly1&quot;&gt;O(nlogn)&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;O(nlogn)&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;O(1)&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;不稳定&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-cly1&quot; rowspan=&quot;2&quot;&gt;交换排序&lt;/td&gt;
    &lt;td class=&quot;tg-cly1&quot;&gt;冒泡排序&lt;/td&gt;
    &lt;td class=&quot;tg-cly1&quot;&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;O(1)&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;稳定&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-cly1&quot;&gt;快速排序&lt;/td&gt;
    &lt;td class=&quot;tg-cly1&quot;&gt;O(nlogn)&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;O(logn)&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;不稳定&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-cly1&quot; colspan=&quot;2&quot;&gt;归并排序&lt;/td&gt;
    &lt;td class=&quot;tg-cly1&quot;&gt;O(nlogn)&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;O(nlogn)&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;O(n)&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;稳定&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-cly1&quot; colspan=&quot;2&quot;&gt;基数排序&lt;/td&gt;
    &lt;td class=&quot;tg-cly1&quot;&gt;O(d(r+n))&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;O(d(r+n))&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;O(r+n)&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;稳定&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-cly1&quot; colspan=&quot;2&quot;&gt;桶排序&lt;/td&gt;
    &lt;td class=&quot;tg-cly1&quot;&gt;O(2(m+n))&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;O(2(m+n))&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;O(max{key})&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;稳定&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="算法" scheme="https://G-SS-Hacker.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="https://G-SS-Hacker.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>加密算法</title>
    <link href="https://g-ss-hacker.github.io/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    <id>https://g-ss-hacker.github.io/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</id>
    <published>2019-09-15T11:52:03.000Z</published>
    <updated>2019-11-10T03:29:34.249Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1568558578017&amp;di=57d5d6ff4f7325e56b649d15feda62b9&amp;imgtype=0&amp;src=http%3A%2F%2Fwww.elecfans.com%2Fuploads%2Fallimg%2F171210%2F2755779-1G2100944092M.png" alt></p><h1 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h1><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><p></p><h2 id="加密算法的历史"><a href="#加密算法的历史" class="headerlink" title="加密算法的历史"></a>加密算法的历史</h2><p>加密算法是一种古老的算法，在人类几千年来的历史进程中，加密算法随着一场场战争的爆发而不断进步，从古罗马时代到第二次世界大战，从<strong>凯撒密码</strong>到<strong>恩尼格玛密码</strong>。然而，就像矛和盾的关系一样，加密技术和解密技术也在不断螺旋式发展。下面，笔者将向读者朋友们介绍一种古老的科技：<strong>凯撒密码</strong>。</p><p>在战争中，命令的传递往往需要通过传令兵。如：</p><p><center><b><font size="5">后方指挥部</font> ———<font color="red">传令兵携带命令“攻打X城”</font>———><font size="5">我方部队</font></b></center><br>可是，一旦传令兵被敌方抓获，重要的军事情报就会泄露给敌方。</p><p><center><b><font size="5">后方指挥部</font>—<font color="red">命令“攻打X城”</font>—><font size="5">敌方部队</font></b></center><br>甚至，敌人可能会篡改命令，并收买传令兵把假情报传给我方部队。</p><p><center><b><font size="5">后方指挥部</font>—<font color="red">命令“攻打X城”</font>—><font size="5">敌方部队</font>—<font color="red">命令“攻打Y城”</font>—><font size="5">我方部队</font></b></center><br>这样一来，我方部队就会完全落入敌方陷阱中。为了防止这种情况发生，在没有更好的传达命令的方法的情况下，我们不妨修改命令的内容，让敌人即使截获了命令，也无法看懂命令的内容，这就是对信息的加密。</p><p><center><b><font size="5">后方指挥部</font>—<font color="red">命令“@#￥！！”</font>—><font size="5">敌方部队：？？？</font></b></center><br>如何进行加密呢？有一种非常朴素的加密方法叫<strong>凯撒密码</strong>，它的基本思路就是<strong>偏移</strong>。</p><p><img src="https://i.loli.net/2019/09/15/Kg1b8A3iHamFlx5.png" alt></p><p>如图所示，图中第一行的字母代表<strong>明文</strong>，第二行字母代表<strong>密文</strong>。这个加密算法十分简单，选择一个偏移量，此处是3，把明文当中的所有字母按照字母表的顺序向后偏移三位，从而生成密文。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A - &gt; D</span><br><span class="line">B - &gt; E</span><br><span class="line">C - &gt; F</span><br><span class="line">LOL - &gt; MPM</span><br></pre></td></tr></table></figure><p>这样一来，就算我军的密码被敌军截获，敌军也无法看懂。一旦我方部队收到了我方的命令，只要逆转原来加密的过程，把密文以偏移量3往左偏移解密为明文，就可以正确收到我方的命令。假设敌军已知我方的加密算法，想要破解，把26个字母都试一遍，终究可以得到正确的原文，这就叫暴力破解。</p><a id="more"></a><h2 id="现代加密算法"><a href="#现代加密算法" class="headerlink" title="现代加密算法"></a>现代加密算法</h2><h3 id="1-对称加密算法"><a href="#1-对称加密算法" class="headerlink" title="1.对称加密算法"></a>1.对称加密算法</h3><p><center><font size="5"><b>明文</b></font>--<font color="red">密钥</font>--><font size="5"><b>密文</b></font>--<font color="red">密钥</font>--><font size="5"><b>明文</b></font></center><br>这很好理解，这就好比给你需要传递的信息加上一把锁，这把锁的钥匙只有你和信息接收方拥有，这样就算信息被截获，也只能看出一堆乱码。只要传递方与接收方事先得到一致的密钥，双方就可以安全进行信息往来。</p><p>常见的对称加密算法有<code>DES</code>算法和<code>3DES</code>算法，它的基本方法是<strong>替换</strong>+<strong>移位</strong>；还有美国联邦政府采用的<code>AES</code>算法；还有<code>RC-5</code>算法和<code>IDEA</code>算法。<code>office Word</code>、<code>Excel</code>、<code>Powerful</code>、<code>pdf</code>、<code>WinRAR</code>的加密算法都属于对称加密算法。</p><p>对称加密算法的优点是<strong>简单高效</strong>，然而缺点却也很明显，那就是<strong>安全性低</strong>。比如下面这种情况：</p><p>你想要给某人通过QQ发送一个加了密的<code>word</code>文档，你发过去了但你的小伙伴打不开，那他当然会向你要密码。为了让他能顺利打开这个文档，你又要给他发送文档的密码。这样一来，你的文档就没有任何安全性可言了。如果你的文档被不怀好意的人截获，那他当然也能截获你的密码。</p><p>为了解决对称加密算法安全性低的问题，科学家发明了非对称加密算法。</p><h3 id="2-非对称加密算法"><a href="#2-非对称加密算法" class="headerlink" title="2. 非对称加密算法"></a>2. 非对称加密算法</h3><p><center><font size="5"><b>明文</b></font>--<font color="red">公钥</font>--><font size="5"><b>密文</b></font>--<font color="red">私钥</font>--><font size="5"><b>明文</b></font></center></p><p><center><font size="5"><b>明文</b></font>--<font color="red">私钥</font>--><font size="5"><b>密文</b></font>--<font color="red">公钥</font>--><font size="5"><b>明文</b></font></center><br>在非对称加密算法中有一对密钥，其中一个叫公钥、另一个叫私钥。如果要加密一个文档，我们既可以用公钥加密文档，用私钥解密文档；也可以用私钥加密文档，用公钥解密文档。最常见的非对称加密算法就是大名鼎鼎的<code>RSA</code>算法，几乎无法破解。</p><p>非对称加密算法的缺点是<strong>效率低下</strong>，然而其优点是<strong>安全性极高</strong>，解决了对称加密算法的安全性低的问题。比如下面这种情况：</p><p>在一间公司中，每一个员工都有自己的一对公钥和私钥，公钥可以交给他人，但是私钥只有自己知道。员工之一的你想要给同样为员工的某人通过QQ发送一个文档，你只需要向接受者索要他的公钥，他就会光明正大地通过QQ发给你，你再利用他的公钥给文档加密，然后光明正大地通过QQ发给他，他接收到你发送的已用他的公钥加密过的文档之后，就可以用他的私钥解密，从而顺利的查看文档了。在这个过程中，就算文档和公钥都被截获，因为没有相应的私钥，也无法正常还原。因此，这个非对称加密算法的安全性比对称加密算法提高了一个等级。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1568558578017&amp;amp;di=57d5d6ff4f7325e56b649d15feda62b9&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fwww.elecfans.com%2Fuploads%2Fallimg%2F171210%2F2755779-1G2100944092M.png&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;加密算法&quot;&gt;&lt;a href=&quot;#加密算法&quot; class=&quot;headerlink&quot; title=&quot;加密算法&quot;&gt;&lt;/a&gt;加密算法&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;h2 id=&quot;加密算法的历史&quot;&gt;&lt;a href=&quot;#加密算法的历史&quot; class=&quot;headerlink&quot; title=&quot;加密算法的历史&quot;&gt;&lt;/a&gt;加密算法的历史&lt;/h2&gt;&lt;p&gt;加密算法是一种古老的算法，在人类几千年来的历史进程中，加密算法随着一场场战争的爆发而不断进步，从古罗马时代到第二次世界大战，从&lt;strong&gt;凯撒密码&lt;/strong&gt;到&lt;strong&gt;恩尼格玛密码&lt;/strong&gt;。然而，就像矛和盾的关系一样，加密技术和解密技术也在不断螺旋式发展。下面，笔者将向读者朋友们介绍一种古老的科技：&lt;strong&gt;凯撒密码&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在战争中，命令的传递往往需要通过传令兵。如：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;b&gt;&lt;font size=&quot;5&quot;&gt;后方指挥部&lt;/font&gt; ———&lt;font color=&quot;red&quot;&gt;传令兵携带命令“攻打X城”&lt;/font&gt;———&gt;&lt;font size=&quot;5&quot;&gt;我方部队&lt;/font&gt;&lt;/b&gt;&lt;/center&gt;&lt;br&gt;可是，一旦传令兵被敌方抓获，重要的军事情报就会泄露给敌方。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;b&gt;&lt;font size=&quot;5&quot;&gt;后方指挥部&lt;/font&gt;—&lt;font color=&quot;red&quot;&gt;命令“攻打X城”&lt;/font&gt;—&gt;&lt;font size=&quot;5&quot;&gt;敌方部队&lt;/font&gt;&lt;/b&gt;&lt;/center&gt;&lt;br&gt;甚至，敌人可能会篡改命令，并收买传令兵把假情报传给我方部队。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;b&gt;&lt;font size=&quot;5&quot;&gt;后方指挥部&lt;/font&gt;—&lt;font color=&quot;red&quot;&gt;命令“攻打X城”&lt;/font&gt;—&gt;&lt;font size=&quot;5&quot;&gt;敌方部队&lt;/font&gt;—&lt;font color=&quot;red&quot;&gt;命令“攻打Y城”&lt;/font&gt;—&gt;&lt;font size=&quot;5&quot;&gt;我方部队&lt;/font&gt;&lt;/b&gt;&lt;/center&gt;&lt;br&gt;这样一来，我方部队就会完全落入敌方陷阱中。为了防止这种情况发生，在没有更好的传达命令的方法的情况下，我们不妨修改命令的内容，让敌人即使截获了命令，也无法看懂命令的内容，这就是对信息的加密。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;b&gt;&lt;font size=&quot;5&quot;&gt;后方指挥部&lt;/font&gt;—&lt;font color=&quot;red&quot;&gt;命令“@#￥！！”&lt;/font&gt;—&gt;&lt;font size=&quot;5&quot;&gt;敌方部队：？？？&lt;/font&gt;&lt;/b&gt;&lt;/center&gt;&lt;br&gt;如何进行加密呢？有一种非常朴素的加密方法叫&lt;strong&gt;凯撒密码&lt;/strong&gt;，它的基本思路就是&lt;strong&gt;偏移&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/09/15/Kg1b8A3iHamFlx5.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;如图所示，图中第一行的字母代表&lt;strong&gt;明文&lt;/strong&gt;，第二行字母代表&lt;strong&gt;密文&lt;/strong&gt;。这个加密算法十分简单，选择一个偏移量，此处是3，把明文当中的所有字母按照字母表的顺序向后偏移三位，从而生成密文。比如：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;A - &amp;gt; D&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;B - &amp;gt; E&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;C - &amp;gt; F&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;LOL - &amp;gt; MPM&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样一来，就算我军的密码被敌军截获，敌军也无法看懂。一旦我方部队收到了我方的命令，只要逆转原来加密的过程，把密文以偏移量3往左偏移解密为明文，就可以正确收到我方的命令。假设敌军已知我方的加密算法，想要破解，把26个字母都试一遍，终究可以得到正确的原文，这就叫暴力破解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="网络与信息安全" scheme="https://G-SS-Hacker.github.io/tags/%E7%BD%91%E7%BB%9C%E4%B8%8E%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>OSI/RM七层模型</title>
    <link href="https://g-ss-hacker.github.io/OSIRM%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/"/>
    <id>https://g-ss-hacker.github.io/OSIRM%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/</id>
    <published>2019-09-14T02:20:02.000Z</published>
    <updated>2019-09-22T07:45:44.611Z</updated>
    
    <content type="html"><![CDATA[<p><center><font size="5">OSI/RM = Open System Interconnection Reference Model</font></center><br><img src="https://i.loli.net/2019/09/14/wtziFSY5JeTrXum.png" alt></p><h1 id="计算机网络：OSI-RM七层模型"><a href="#计算机网络：OSI-RM七层模型" class="headerlink" title="计算机网络：OSI/RM七层模型"></a>计算机网络：OSI/RM七层模型</h1><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><br>在计算机网络建立之初，各大计算机企业之间并没有一套通用的标准来规范计算机网络的建设，相反，各企业在自己的计算机系统上实行自己的标准，这就造成了一种局面：不同品牌计算机之间不能实现互连。要知道互联网建立之初的目的就是让把全世界的计算机连接起来，实现信息共享。这个目标在今天已经基本实现，然而在上个世纪七八十年代，苹果的计算机和IBM的计算机的网路接口都不一样，更不用说两者互连了。这种情况在不同品牌    的计算机之间比比皆是，制约了世界互联网的发展，同时也制约了互联网市场规模的增长。<p></p><p>此时，各计算机企业需要一套公用的标准来规范计算机网络的建设。然而，每一家企业都希望推行自己的标准，不愿意使用别人的标准。正如现在我们所说：“一流的公司定标准。”当别人制定好了标准，你再依据这个标准开发产品的时候，实际上你已经比别人落后了，也就是说标准制定者永远站在领先的位置。各计算机企业争执不下，标准的制定再次陷入僵局。</p><p>既然各计算机企业都不愿意放弃自己的标准，使用别人的标准，那么有人提议，我们全部放弃自己的标准，由国际标准化组织（nternational Organization for Standardization, ISO)来制定一套标准，我们就全部采用那套标准。这一提议得到了计算机企业的广泛认可。于是ISO就制定了开放系统互连(OSI)模型，并由全世界的计算机企业以此为标准开发和建立计算机网络。虽然从今天的角度看，这套标准有些繁琐，层次显得太多，但是因为这套标准已经被遵循多年，所以被一直延续了下来，未曾改变。</p><a id="more"></a><p><center>OSI/RM七层模型</center></p><p><style type="text/css"><br>.tg  {border-collapse:collapse;border-spacing:0;}<br>.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}<br>.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}<br>.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}</style></p><table class="tg">  <tr>    <th class="tg-0pky">层次<br></th>    <th class="tg-0pky">名称<br></th>    <th class="tg-0pky">主要功能</th>    <th class="tg-0pky">主要设备及协议</th>  </tr>  <tr>    <td class="tg-0pky">7</td>    <td class="tg-0pky">应用层</td>    <td class="tg-0pky">实现具体的应用功能</td>    <td class="tg-0pky" rowspan="3">POP3、FTP、HTTP、Telnet、SMTP<br>DHCP、TFTP、SNMP、DNS<br></td>  </tr>  <tr>    <td class="tg-0pky">6</td>    <td class="tg-0pky">表示层</td>    <td class="tg-0pky">数据的格式与表达、加密、压缩<br></td>  </tr>  <tr>    <td class="tg-0pky">5<br></td>    <td class="tg-0pky">会话层</td>    <td class="tg-0pky">建立、管理和终止对话</td>  </tr>  <tr>    <td class="tg-0pky">4<br></td>    <td class="tg-0pky">传输层</td>    <td class="tg-0pky">端到端的连接</td>    <td class="tg-0pky">TCP、UDP<br></td>  </tr>  <tr>    <td class="tg-0pky">3</td>    <td class="tg-0pky">网络层</td>    <td class="tg-0pky">分组传输和路由选择</td>    <td class="tg-0pky">三层交换机、路由器<br>ARP、RARP、IP、ICMP、IGMP<br></td>  </tr>  <tr>    <td class="tg-0pky">2</td>    <td class="tg-0pky">数据链路层</td>    <td class="tg-0pky">传输以帧为单位的信息</td>    <td class="tg-0pky">网桥、交换机、网卡<br>PPTP、L2TP、SLIP、PPP<br></td>  </tr>  <tr>    <td class="tg-0pky">1</td>    <td class="tg-0pky">物理层</td>    <td class="tg-0pky">二进制传输</td>    <td class="tg-0pky">中继器、集线器</td>  </tr></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;&lt;font size=&quot;5&quot;&gt;OSI/RM = Open System Interconnection Reference Model&lt;/font&gt;&lt;/center&gt;&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2019/09/14/wtziFSY5JeTrXum.png&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;计算机网络：OSI-RM七层模型&quot;&gt;&lt;a href=&quot;#计算机网络：OSI-RM七层模型&quot; class=&quot;headerlink&quot; title=&quot;计算机网络：OSI/RM七层模型&quot;&gt;&lt;/a&gt;计算机网络：OSI/RM七层模型&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;br&gt;在计算机网络建立之初，各大计算机企业之间并没有一套通用的标准来规范计算机网络的建设，相反，各企业在自己的计算机系统上实行自己的标准，这就造成了一种局面：不同品牌计算机之间不能实现互连。要知道互联网建立之初的目的就是让把全世界的计算机连接起来，实现信息共享。这个目标在今天已经基本实现，然而在上个世纪七八十年代，苹果的计算机和IBM的计算机的网路接口都不一样，更不用说两者互连了。这种情况在不同品牌    的计算机之间比比皆是，制约了世界互联网的发展，同时也制约了互联网市场规模的增长。&lt;p&gt;&lt;/p&gt;
&lt;p&gt;此时，各计算机企业需要一套公用的标准来规范计算机网络的建设。然而，每一家企业都希望推行自己的标准，不愿意使用别人的标准。正如现在我们所说：“一流的公司定标准。”当别人制定好了标准，你再依据这个标准开发产品的时候，实际上你已经比别人落后了，也就是说标准制定者永远站在领先的位置。各计算机企业争执不下，标准的制定再次陷入僵局。&lt;/p&gt;
&lt;p&gt;既然各计算机企业都不愿意放弃自己的标准，使用别人的标准，那么有人提议，我们全部放弃自己的标准，由国际标准化组织（nternational Organization for Standardization, ISO)来制定一套标准，我们就全部采用那套标准。这一提议得到了计算机企业的广泛认可。于是ISO就制定了开放系统互连(OSI)模型，并由全世界的计算机企业以此为标准开发和建立计算机网络。虽然从今天的角度看，这套标准有些繁琐，层次显得太多，但是因为这套标准已经被遵循多年，所以被一直延续了下来，未曾改变。&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="计算机网络" scheme="https://G-SS-Hacker.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Windows10常用快捷键</title>
    <link href="https://g-ss-hacker.github.io/Windows10%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>https://g-ss-hacker.github.io/Windows10%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</id>
    <published>2019-08-12T07:21:26.000Z</published>
    <updated>2019-09-23T05:04:46.525Z</updated>
    
    <content type="html"><![CDATA[<p><center><font size="5">Life is short, you need shortcuts</font></center><br><img src="https://i.loli.net/2019/08/14/OnshLMAPtv3745b.png" alt></p><h1 id="Windows-10常用快捷键"><a href="#Windows-10常用快捷键" class="headerlink" title="Windows 10常用快捷键"></a>Windows 10常用快捷键</h1><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">Windows 徽标键 + I　—&gt;　打开“设置”</span><br><span class="line"></span><br><span class="line">Windows 徽标键 + E　—&gt;　打开“文件资源管理器”</span><br><span class="line"></span><br><span class="line">Windows 徽标键 + D　—&gt;　显示和隐藏桌面</span><br><span class="line"></span><br><span class="line">Windows 徽标键 + L　—&gt;　锁定电脑</span><br><span class="line"></span><br><span class="line">Windows 徽标键 + M　—&gt;　最小化所有窗口</span><br><span class="line"></span><br><span class="line">Windows 徽标键 + R　—&gt;　打开“运行”对话框</span><br><span class="line"></span><br><span class="line">Windows 徽标键 + 逗号 (,)　—&gt;　临时快速查看桌面</span><br><span class="line"></span><br><span class="line">Windows 徽标键 + 数字　—&gt;　打开桌面，并启动固定到任务栏的位于该数字所表示位置的应用。如果该应用已在运行，则切换到该应用。</span><br><span class="line"></span><br><span class="line">Windows 徽标键 + Tab　—&gt;　打开“任务视图”</span><br><span class="line"></span><br><span class="line">Windows 徽标键 + 向上键　—&gt;　最大化窗口</span><br><span class="line"></span><br><span class="line">Windows 徽标键 + 向下键　—&gt;　从屏幕中删除当前应用或最小化桌面窗口</span><br><span class="line"></span><br><span class="line">Windows 徽标键 + 向左键　—&gt;　将应用或桌面窗口最大化到屏幕左侧</span><br><span class="line"></span><br><span class="line">Windows 徽标键 + 向右键　—&gt;　将应用或桌面窗口最大化到屏幕右侧</span><br><span class="line"></span><br><span class="line">Alt + Enter　—&gt;　打开选定项的“属性”对话框</span><br><span class="line"></span><br><span class="line">Backspace　—&gt;　查看上一个文件夹</span><br><span class="line"></span><br><span class="line">F2　—&gt;　重命名选定项</span><br><span class="line"></span><br><span class="line">F3　—&gt;　在文件资源管理器中搜索文件或文件夹</span><br><span class="line"></span><br><span class="line">Ctrl + X　   —&gt;　剪切选定项</span><br><span class="line"></span><br><span class="line">Ctrl + C（或 Ctrl + Insert）　—&gt;　复制选定项</span><br><span class="line"></span><br><span class="line">Ctrl + V（或 Shift + Insert）　—&gt;　粘贴选定项</span><br><span class="line"></span><br><span class="line">Ctrl + Z　—&gt;　撤消操作</span><br><span class="line"></span><br><span class="line">Ctrl + Y　—&gt;　重做操作</span><br><span class="line"></span><br><span class="line">Alt + Tab　—&gt;　在打开的应用之间切换</span><br><span class="line"></span><br><span class="line">Alt + F4　—&gt;　关闭活动项，或者退出活动应用</span><br></pre></td></tr></table></figure><p></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;&lt;font size=&quot;5&quot;&gt;Life is short, you need shortcuts&lt;/font&gt;&lt;/center&gt;&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2019/08/14/OnshLMAPtv3745b.png&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;Windows-10常用快捷键&quot;&gt;&lt;a href=&quot;#Windows-10常用快捷键&quot; class=&quot;headerlink&quot; title=&quot;Windows 10常用快捷键&quot;&gt;&lt;/a&gt;Windows 10常用快捷键&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Windows 徽标键 + I　—&amp;gt;　打开“设置”&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Windows 徽标键 + E　—&amp;gt;　打开“文件资源管理器”&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Windows 徽标键 + D　—&amp;gt;　显示和隐藏桌面&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Windows 徽标键 + L　—&amp;gt;　锁定电脑&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Windows 徽标键 + M　—&amp;gt;　最小化所有窗口&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Windows 徽标键 + R　—&amp;gt;　打开“运行”对话框&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Windows 徽标键 + 逗号 (,)　—&amp;gt;　临时快速查看桌面&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Windows 徽标键 + 数字　—&amp;gt;　打开桌面，并启动固定到任务栏的位于该数字所表示位置的应用。如果该应用已在运行，则切换到该应用。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Windows 徽标键 + Tab　—&amp;gt;　打开“任务视图”&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Windows 徽标键 + 向上键　—&amp;gt;　最大化窗口&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Windows 徽标键 + 向下键　—&amp;gt;　从屏幕中删除当前应用或最小化桌面窗口&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Windows 徽标键 + 向左键　—&amp;gt;　将应用或桌面窗口最大化到屏幕左侧&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Windows 徽标键 + 向右键　—&amp;gt;　将应用或桌面窗口最大化到屏幕右侧&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Alt + Enter　—&amp;gt;　打开选定项的“属性”对话框&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Backspace　—&amp;gt;　查看上一个文件夹&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;F2　—&amp;gt;　重命名选定项&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;F3　—&amp;gt;　在文件资源管理器中搜索文件或文件夹&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Ctrl + X　   —&amp;gt;　剪切选定项&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Ctrl + C（或 Ctrl + Insert）　—&amp;gt;　复制选定项&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Ctrl + V（或 Shift + Insert）　—&amp;gt;　粘贴选定项&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Ctrl + Z　—&amp;gt;　撤消操作&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Ctrl + Y　—&amp;gt;　重做操作&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Alt + Tab　—&amp;gt;　在打开的应用之间切换&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Alt + F4　—&amp;gt;　关闭活动项，或者退出活动应用&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Windows10" scheme="https://G-SS-Hacker.github.io/tags/Windows10/"/>
    
  </entry>
  
  <entry>
    <title>Typora常用快捷键大全</title>
    <link href="https://g-ss-hacker.github.io/Typora%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/"/>
    <id>https://g-ss-hacker.github.io/Typora%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/</id>
    <published>2019-08-12T05:48:16.000Z</published>
    <updated>2019-12-02T13:45:32.212Z</updated>
    
    <content type="html"><![CDATA[<p><center><font size="5">Life is short, you need shortcuts</font></center><br><img src="https://i.loli.net/2019/10/02/EmLBQfI6HrVnPXd.jpg" alt></p><h1 id="Typora常用快捷键大全"><a href="#Typora常用快捷键大全" class="headerlink" title="Typora常用快捷键大全"></a>Typora常用快捷键大全</h1><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><p></p><p><style type="text/css"><br>.tg  {border-collapse:collapse;border-spacing:0;}<br>.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}<br>.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}<br>.tg .tg-m9r4{background-color:#ffffc7;text-align:left;vertical-align:top}<br>.tg .tg-ncd7{background-color:#ffffc7;border-color:inherit;text-align:left;vertical-align:top}<br>.tg .tg-0lax{text-align:left;vertical-align:top}<br>.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}</style></p><table class="tg">  <tr>    <th class="tg-m9r4">操作类型</th>    <th class="tg-ncd7">操作</th>    <th class="tg-ncd7">快捷键</th>  </tr>  <tr>    <td class="tg-0lax" rowspan="8">文件操作</td>    <td class="tg-0pky">新建</td>    <td class="tg-0pky">Ctrl + N</td>  </tr>  <tr>    <td class="tg-0pky">新建窗口<br></td>    <td class="tg-0pky">Ctrl + Shift + N</td>  </tr>  <tr>    <td class="tg-0pky">打开</td>    <td class="tg-0pky">Ctrl + O</td>  </tr>  <tr>    <td class="tg-0lax">快速打开</td>    <td class="tg-0lax">Ctrl + P</td>  </tr>  <tr>    <td class="tg-0lax">保存<br></td>    <td class="tg-0lax">Ctrl + S</td>  </tr>  <tr>    <td class="tg-0lax">另存为</td>    <td class="tg-0lax">Ctrl + Shift + S</td>  </tr>  <tr>    <td class="tg-0lax">偏好设置</td>    <td class="tg-0lax">Ctrl + 逗号</td>  </tr>  <tr>    <td class="tg-0lax">关闭</td>    <td class="tg-0lax">Ctrl + W</td>  </tr>  <tr>    <td class="tg-0lax" rowspan="7">编辑操作</td>    <td class="tg-0lax">选中当前行/句</td>    <td class="tg-0lax">Ctrl + L</td>  </tr>  <tr>    <td class="tg-0lax">选中当前格式文本</td>    <td class="tg-0lax">Ctrl + E</td>  </tr>  <tr>    <td class="tg-0lax">选中当前词</td>    <td class="tg-0lax">Ctrl + D</td>  </tr>  <tr>    <td class="tg-0lax">查找<br></td>    <td class="tg-0lax">Ctrl + F</td>  </tr>  <tr>    <td class="tg-0lax">替换</td>    <td class="tg-0lax">Ctrl + H<br></td>  </tr>  <tr>    <td class="tg-0lax">查找下一个</td>    <td class="tg-0lax">F3</td>  </tr>  <tr>    <td class="tg-0lax">查找上一个</td>    <td class="tg-0lax">Shift + F3</td>  </tr>  <tr>    <td class="tg-0lax" rowspan="2">段落操作</td>    <td class="tg-0lax">提升标题等级</td>    <td class="tg-0lax">Ctrl + =</td>  </tr>  <tr>    <td class="tg-0lax">降低标题等级</td>    <td class="tg-0lax">Ctrl + -</td>  </tr>  <tr>    <td class="tg-0lax" rowspan="8">格式操作</td>    <td class="tg-0lax">加粗</td>    <td class="tg-0lax">Ctrl +Ｂ</td>  </tr>  <tr>    <td class="tg-0lax">斜体</td>    <td class="tg-0lax">Ctrl + I<br></td>  </tr>  <tr>    <td class="tg-0lax">下划线<br></td>    <td class="tg-0lax">Ctrl + U</td>  </tr>  <tr>    <td class="tg-0lax">代码</td>    <td class="tg-0lax">Ctrl + Shift + `</td>  </tr>  <tr>    <td class="tg-0lax">删除线</td>    <td class="tg-0lax">Alt + Shift + 5</td>  </tr>  <tr>    <td class="tg-0lax">超链接</td>    <td class="tg-0lax">Ctrl + K</td>  </tr>  <tr>    <td class="tg-0lax">图像<br></td>    <td class="tg-0lax">Ctrl + Shift + I</td>  </tr>  <tr>    <td class="tg-0lax">清除样式</td>    <td class="tg-0lax">Ctrl + \</td>  </tr></table><a id="more"></a><font color="#407600">【其他文章·Markdown·Windows10】</font><ul><li><p><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/Markdown需要转义的字符及其转义方法/">Markdown需要转义的字符及其转义方法</a></p></li><li><p><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/Typora常用快捷键大全/">Typora常用快捷键大全</a></p></li><li><p><a href="https://g-ss-hacker.github.io/G-SS-Hacker.github.io/Windows10常用快捷键/">Windows10常用快捷键</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;&lt;font size=&quot;5&quot;&gt;Life is short, you need shortcuts&lt;/font&gt;&lt;/center&gt;&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2019/10/02/EmLBQfI6HrVnPXd.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;Typora常用快捷键大全&quot;&gt;&lt;a href=&quot;#Typora常用快捷键大全&quot; class=&quot;headerlink&quot; title=&quot;Typora常用快捷键大全&quot;&gt;&lt;/a&gt;Typora常用快捷键大全&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;style type=&quot;text/css&quot;&gt;&lt;br&gt;.tg  {border-collapse:collapse;border-spacing:0;}&lt;br&gt;.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}&lt;br&gt;.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}&lt;br&gt;.tg .tg-m9r4{background-color:#ffffc7;text-align:left;vertical-align:top}&lt;br&gt;.tg .tg-ncd7{background-color:#ffffc7;border-color:inherit;text-align:left;vertical-align:top}&lt;br&gt;.tg .tg-0lax{text-align:left;vertical-align:top}&lt;br&gt;.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
&lt;/style&gt;&lt;/p&gt;
&lt;table class=&quot;tg&quot;&gt;
  &lt;tr&gt;
    &lt;th class=&quot;tg-m9r4&quot;&gt;操作类型&lt;/th&gt;
    &lt;th class=&quot;tg-ncd7&quot;&gt;操作&lt;/th&gt;
    &lt;th class=&quot;tg-ncd7&quot;&gt;快捷键&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-0lax&quot; rowspan=&quot;8&quot;&gt;文件操作&lt;/td&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;新建&lt;/td&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;Ctrl + N&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;新建窗口&lt;br&gt;&lt;/td&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;Ctrl + Shift + N&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;打开&lt;/td&gt;
    &lt;td class=&quot;tg-0pky&quot;&gt;Ctrl + O&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;快速打开&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;Ctrl + P&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;保存&lt;br&gt;&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;Ctrl + S&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;另存为&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;Ctrl + Shift + S&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;偏好设置&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;Ctrl + 逗号&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;关闭&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;Ctrl + W&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-0lax&quot; rowspan=&quot;7&quot;&gt;编辑操作&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;选中当前行/句&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;Ctrl + L&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;选中当前格式文本&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;Ctrl + E&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;选中当前词&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;Ctrl + D&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;查找&lt;br&gt;&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;Ctrl + F&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;替换&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;Ctrl + H&lt;br&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;查找下一个&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;F3&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;查找上一个&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;Shift + F3&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-0lax&quot; rowspan=&quot;2&quot;&gt;段落操作&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;提升标题等级&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;Ctrl + =&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;降低标题等级&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;Ctrl + -&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-0lax&quot; rowspan=&quot;8&quot;&gt;格式操作&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;加粗&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;Ctrl +Ｂ&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;斜体&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;Ctrl + I&lt;br&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;下划线&lt;br&gt;&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;Ctrl + U&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;代码&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;Ctrl + Shift + `&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;删除线&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;Alt + Shift + 5&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;超链接&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;Ctrl + K&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;图像&lt;br&gt;&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;Ctrl + Shift + I&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;清除样式&lt;/td&gt;
    &lt;td class=&quot;tg-0lax&quot;&gt;Ctrl + \&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Markdown" scheme="https://G-SS-Hacker.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Think before you ask</title>
    <link href="https://g-ss-hacker.github.io/%E5%85%88%E6%80%9D%E8%80%83%EF%BC%8C%E5%86%8D%E6%8F%90%E9%97%AE/"/>
    <id>https://g-ss-hacker.github.io/%E5%85%88%E6%80%9D%E8%80%83%EF%BC%8C%E5%86%8D%E6%8F%90%E9%97%AE/</id>
    <published>2019-08-10T18:55:01.000Z</published>
    <updated>2019-09-28T02:04:17.333Z</updated>
    
    <content type="html"><![CDATA[<p><center><font size="5">If you want something done right, do it yourself.</font></center><br><img src="https://i.loli.net/2019/09/28/Y1dwxQmaAu5fHFM.jpg" alt></p><h1 id="Think-before-you-ask"><a href="#Think-before-you-ask" class="headerlink" title="Think before you ask"></a>Think before you ask</h1><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><p></p><h2 id="自己动手，丰衣足食"><a href="#自己动手，丰衣足食" class="headerlink" title="自己动手，丰衣足食"></a>自己动手，丰衣足食</h2><p>毛泽东曾经说过：“自己动手，丰衣足食。”关于求助这件事，其实很多时候看源代码或者帮助文档能解决很多问题，如果实在没有，一般你遇到的问题别人可能也遇到过，善用搜索引擎能解决更多问题。有一个说法:普通程序员 + google = 超级程序员。所以在平时要养成一些习惯，<strong>仔细阅读帮助文档，阅读源代码，善用搜索引擎</strong>，实在没辙了再提问。</p><a id="more"></a><p>在一些问答网站上，经常可见回答的一些缩写，很有趣也很有用，在此将其列举出来：</p><ul><li>RTFSC(Read the fucking source code)</li><li>RTFM(Read the fucking manual)</li><li>UTFH (Use The Fucking Help)</li><li>STFW (Search The Fucking Web)</li><li>STFG (Search The Fucking Google)</li><li>GIYF (Google Is Your Friend)</li><li>JFGI (Just Fucking Google It)</li><li>UTSL (Use The Source Luke)</li><li>RTFA (Read The Fucking Article)</li><li>RTFE (Read The Fucking Email)</li><li>RTFC (“Read The Fucking Code” or “Reboot The Fucking Computer”)</li><li>RTFQ (Read The Fucking Question)</li><li>LMGTFY (Let Me Google That For You)</li><li>WIDGI (When In Doubt Google It)</li><li>FIOTI (Find It On The Internet)</li></ul><p>通常，给出这些答案的人已经通过这些办法找到了解决问题的关键，正在一边看一边敲键盘。这些回复意味着他认为：第一，你要的信息可以靠你自己的力量找到。第二，自已找要比别人喂到嘴里能学得更多。你不应该觉得这样就被冒犯了，按黑客的标准，他没有不理你就是在向你表示某种尊敬，你反而应该感谢他热切地想帮助你。</p><!--more--><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><blockquote><p>The tools we use have a profound influence on our thinking habits, and therefore, on our thinking abilities.        ---from Edsger Dijkstra, 1972 Turing Awards receiver</p><p>我们使用的工具深刻地影响着我们的思维习惯，因此，也深刻影响着我们的思维能力。        ——艾兹格·迪科斯彻，1972年图灵奖得主</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;&lt;font size=&quot;5&quot;&gt;If you want something done right, do it yourself.&lt;/font&gt;&lt;/center&gt;&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2019/09/28/Y1dwxQmaAu5fHFM.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;Think-before-you-ask&quot;&gt;&lt;a href=&quot;#Think-before-you-ask&quot; class=&quot;headerlink&quot; title=&quot;Think before you ask&quot;&gt;&lt;/a&gt;Think before you ask&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;h2 id=&quot;自己动手，丰衣足食&quot;&gt;&lt;a href=&quot;#自己动手，丰衣足食&quot; class=&quot;headerlink&quot; title=&quot;自己动手，丰衣足食&quot;&gt;&lt;/a&gt;自己动手，丰衣足食&lt;/h2&gt;&lt;p&gt;毛泽东曾经说过：“自己动手，丰衣足食。”关于求助这件事，其实很多时候看源代码或者帮助文档能解决很多问题，如果实在没有，一般你遇到的问题别人可能也遇到过，善用搜索引擎能解决更多问题。有一个说法:普通程序员 + google = 超级程序员。所以在平时要养成一些习惯，&lt;strong&gt;仔细阅读帮助文档，阅读源代码，善用搜索引擎&lt;/strong&gt;，实在没辙了再提问。&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="方法" scheme="https://G-SS-Hacker.github.io/tags/%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>题解：约瑟夫环问题</title>
    <link href="https://g-ss-hacker.github.io/%E9%A2%98%E8%A7%A3%EF%BC%9A%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98/"/>
    <id>https://g-ss-hacker.github.io/%E9%A2%98%E8%A7%A3%EF%BC%9A%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98/</id>
    <published>2019-08-07T12:59:28.000Z</published>
    <updated>2019-10-21T10:56:03.391Z</updated>
    
    <content type="html"><![CDATA[<p><center><font size="5">约瑟夫是一个无聊的人</font></center><br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1565762530709&amp;di=17e409616ad317bd92b1683d92387c27&amp;imgtype=0&amp;src=http%3A%2F%2Freader008.dokumen.tips%2Freader008%2Fslide%2F20181109%2F56649d565503460f94a348ce%2Fdocument-2.png" alt></p><h1 id="题解：约瑟夫环问题"><a href="#题解：约瑟夫环问题" class="headerlink" title="题解：约瑟夫环问题"></a>题解：约瑟夫环问题</h1><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><p></p><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>据说著名犹太历史学家 Josephus有过以下的故事：在罗马人占领乔塔帕特后，39个犹太人与Josephus及他的朋友躲在一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。然而Josephus 和他的朋友并不想遵从。问题是，给定了总人数n和报数值m，一开始要站在什么地方才能避免被处决？Josephus要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>n个人(n&lt;=100)围成一圈,从第一个人开始报数,数到m的人出列,再由下一个人重新从1开始报数,数到m的人再出圈,……依次类推,直到所有的人都出圈,请输出依次出圈人的编号。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>n m </p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>出圈的编号</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入 #1"></a>输入 #1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 3</span><br></pre></td></tr></table></figure><h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出 #1"></a>输出 #1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 6 9 2 7 1 8 5 10 4</span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p>m, n ≤ 100</p><h2 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h2><h3 id="解法一：模拟-指针模拟链表"><a href="#解法一：模拟-指针模拟链表" class="headerlink" title="解法一：模拟 + 指针模拟链表"></a>解法一：模拟 + 指针模拟链表</h3><p>时间复杂度：$O(m * n)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Run on C++</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    node* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">node *head, *p, *r;  <span class="comment">//head为头结点，p表示新节点，r表示当前节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    head = <span class="keyword">new</span> node;</span><br><span class="line">    head-&gt;data = <span class="number">1</span>;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    r = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = <span class="keyword">new</span> node;</span><br><span class="line">        p-&gt;data = i;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        r-&gt;next = p;</span><br><span class="line">        r = p;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = head; r = head; <span class="comment">//使链表首尾相连</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m - <span class="number">2</span>; j++)    r = r-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,r-&gt;next-&gt;data);</span><br><span class="line">        r-&gt;next = r-&gt;next-&gt;next;</span><br><span class="line">        r = r-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解法二：模拟-数组模拟链表"><a href="#解法二：模拟-数组模拟链表" class="headerlink" title="解法二：模拟 + 数组模拟链表"></a>解法二：模拟 + 数组模拟链表</h3><a id="more"></a><p>时间复杂度：$O(m * n)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Run on C++</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nxt[<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) nxt[i] = i + <span class="number">1</span>;</span><br><span class="line">    nxt[n] = <span class="number">1</span>; <span class="comment">//使链表首尾相连</span></span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">1</span>; <span class="comment">//当前位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m - <span class="number">2</span>; j++) pos = nxt[pos];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, nxt[pos]);</span><br><span class="line">        nxt[pos] = nxt[nxt[pos]];</span><br><span class="line">        pos = nxt[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解法三：模拟-数组"><a href="#解法三：模拟-数组" class="headerlink" title="解法三：模拟 + 数组"></a>解法三：模拟 + 数组</h3><p>时间复杂度：$O(m * n)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Run on C++</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">1</span>, i = <span class="number">1</span>, cnt = <span class="number">0</span>; <span class="comment">//t为出去的人的数量，i为数组下标索引，cnt为计数器</span></span><br><span class="line">    <span class="keyword">while</span>(t &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == n + <span class="number">1</span>) i = <span class="number">1</span>; <span class="comment">//到了最后一个重新从第一个开始</span></span><br><span class="line">        <span class="keyword">if</span>(a[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span>(cnt == m) <span class="comment">//到了第m个开始新一轮计数</span></span><br><span class="line">            &#123;</span><br><span class="line">                a[i] = <span class="number">1</span>;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">                t++;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解法四：模拟-队列"><a href="#解法四：模拟-队列" class="headerlink" title="解法四：模拟 + 队列"></a>解法四：模拟 + 队列</h3><p>时间复杂度：$O(m * n)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Run on C++</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) q.push(i);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) q.push(q.front()), q.pop(); <span class="comment">//每数一个就把它放到队尾</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,q.front());</span><br><span class="line">        q.pop(); <span class="comment">//队头出圈</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ul><li>你也可以不用<code>stl</code>提供的队列，自己编写一个队列</li><li>你也可以用<code>stl</code>提供的双端队列<code>deque</code>，不过据笔者观察除了装逼效果之外并没有其他用处</li></ul><h3 id="解法五：递归（运用递推公式）"><a href="#解法五：递归（运用递推公式）" class="headerlink" title="解法五：递归（运用递推公式）"></a>解法五：递归（运用递推公式）</h3><p>时间复杂度：$O(n^2)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Run on C++</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Josephus</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (z == <span class="number">1</span>) <span class="keyword">return</span> (y - <span class="number">1</span>) % x;</span><br><span class="line">    <span class="keyword">return</span> (Josephus(x - <span class="number">1</span>, y, z - <span class="number">1</span>) + y) % x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, Josephus(n, m, i) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解法六：迭代（运用递推公式）"><a href="#解法六：迭代（运用递推公式）" class="headerlink" title="解法六：迭代（运用递推公式）"></a>解法六：迭代（运用递推公式）</h3><p>时间复杂度：$O(n^2)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Run on C++</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">1</span>) ans = (m - <span class="number">1</span>) % (n - i + j);</span><br><span class="line">            <span class="keyword">else</span> ans = (ans + m) % (n - i + j);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="推导递推公式"><a href="#推导递推公式" class="headerlink" title="推导递推公式*"></a><a href="https://blog.csdn.net/yanweibujian/article/details/50876631" target="_blank" rel="noopener">推导递推公式</a><sup><a href="#fn_*" id="reffn_*">*</a></sup></h3><p>以解法五为例，在递归函数部分代码中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Josephus</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (z == <span class="number">1</span>) <span class="keyword">return</span> (y - <span class="number">1</span>) % x;</span><br><span class="line">    <span class="keyword">return</span> (Josephus(x - <span class="number">1</span>, y, z - <span class="number">1</span>) + y) % x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>x</code>代表总人数，<code>y</code>代表每次报<code>y</code>的人出列，<code>z</code>是次数，该函数可以求第<code>y</code>次出圈的人的编号。</p><p>举个例子：总人数<code>x</code>为6人，从1开始，每报到3就出圈（<code>z = 3</code>）</p><p>初始情况：<code>1 2 3 4 5 6</code></p><p>通过递推的方式使第一个幸运观众出圈之后：<code>1 2   4 5 6</code></p><p>此时，这些编号已经不能组成一个环，但是<code>2</code>和<code>4</code>之间还是连着的，且下一次报数将从<code>4</code>开始。然而，之后的报数将总要考虑<code>3</code>处的空位问题。</p><p><strong>如何避免空位对报数所造成的影响？</strong></p><p>可以将剩下的4个数重新组合成一个新的环，这样报数的时候就不必在意<code>3</code>的空缺了。但是新产生的环的数字并非连续的，报数时不能直接用<code>+ y</code>再<code>% x</code>的简单递推方式，这下真令人头大。</p><p><strong>如何使新环上的编号依然能够递推？</strong></p><p>可以建立一种<strong>有确定规则的映射</strong>，要求映射之后的数字可以递推，且可以将在新环中继续按原规则报数得到的结果<strong>逆推</strong>出在旧环中的对应数字。</p><p>阻止我们使用老办法递推的因素就是<code>3</code>号出圈之后产生的新环编号不连续，那么，我们可以通过建立某种<strong>映射</strong>，使得新环的编号依然连续，方便我们继续使用递推的方法。</p><p>原始：<code>1 2 3 4 5 6</code></p><p>旧环：<code>1 2 _ 4 5 6</code></p><p>新环：<code>4 5 _ 1 2 3</code></p><p>正如你所见，相比于旧环中<code>2</code>和<code>4</code>之间被割裂开，新环的<code>5</code>和<code>1</code>之间在对<code>5</code>取余的基础上是完美连续的，这就意味着我们可以继续从新环的<code>1</code>（即旧环的<code>4</code>）开始实施我们的递推方法。且只要推导出<strong>新环与旧环的映射关系</strong>，就能从在新环中报数的结果得知在旧环中的报数结果。</p><p>对于第二个幸运观众：</p><p>旧环：<code>1 2 _ 4 5 *6</code></p><p>新环：<code>4 5 _ 1 2 *3</code></p><p>如何从新环的<code>3</code>得到旧环的<code>6</code>呢？其实可以简单地逆推回去 : 新环是由<code>(旧环中编号 - 报数值) % 旧环总人数</code>得到的，所以逆推时可以由<code>(新环编号 + 报数值) % 旧环总人数</code>得到。</p><p>如：<code>(3 + 3) % 6 = 0</code></p><p>咦？奇怪怎么是<code>0</code>？不是应该是<code>6</code>吗？这就涉及到一个进位的问题。由于旧环的编号为<code>1~6</code>，而我们在新环依然保留了<code>1~5</code>的编号并确保<code>5</code>和<code>1</code>之间在对<code>5</code>取余的基础上连续，这就导致了<code>5 % 5 = 0</code>，也就是说<code>5</code>与<code>0</code>是无法区分的。因此，虽然实际上旧环编号为<code>6</code>的幸运观众出圈，但是我们的计算结果依然<strong>不可避免</strong>地把它对<code>6</code>取余，得到一个<strong>看似奇怪却又顺理成章</strong>的<code>0</code>。</p><p><strong>如何避免错误地把最大的数算成0的情况？</strong></p><p>把所有数减<code>1</code>即可，最后输出结果的时候再加上<code>1</code>。让我们再来一遍：</p><p>对于第二个幸运观众：</p><p>旧环：<code>0 1 _ 3 4 *5</code></p><p>新环：<code>3 4 _ 0 1 *2</code></p><p>从新环推出旧环的幸运观众：<code>(2 + 3) % 6 = 5</code></p><p>由上得，原序列<code>x</code>中第二次出圈的编号可以由新序列<code>x - 1</code>第一次出圈的编号通过特定的逆推运算得出。<strong>即在以<code>y</code>为出环报数值的约瑟夫环中，<code>x</code>人环的第<code>z</code>次出环编号可以由<code>x - 1</code>人环中的第<code>z - 1</code>次出环编号通过也定的运算推出。</strong></p><p>幸运的是，第一次出环的编号是可以直接求出的，也就是说，对于任意次出环的编号，我们可以将之<strong>一直转化为第一次出环的编号问题</strong>，再一一迭代求出；也可以把第一次出环的编号作为递归基础，通过递归求出。</p><p>因此我们可以写出<code>Josephus</code>函数的递推公式如下：</p><script type="math/tex; mode=display">Josephus(x,y,z) = \begin{cases} [Josephus(x-1,y,z-1) + y] \% x ,& \text{z > 1} \\ (y-1)\%x , & \text{z = 1} \end{cases}</script><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>以上就是关于约瑟夫环问题的六种解法，并送上调试过的<code>C++</code>代码，作者水平不高，将就看看吧 ╮(╯_╰)╭</p><blockquote id="fn_*"><sup>*</sup>. <font color="grey">参考该网站，感谢作者的写作</font><a href="#reffn_*" title="Jump back to footnote [*] in the text."> &#8617;</a></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;&lt;font size=&quot;5&quot;&gt;约瑟夫是一个无聊的人&lt;/font&gt;&lt;/center&gt;&lt;br&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1565762530709&amp;amp;di=17e409616ad317bd92b1683d92387c27&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Freader008.dokumen.tips%2Freader008%2Fslide%2F20181109%2F56649d565503460f94a348ce%2Fdocument-2.png&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;题解：约瑟夫环问题&quot;&gt;&lt;a href=&quot;#题解：约瑟夫环问题&quot; class=&quot;headerlink&quot; title=&quot;题解：约瑟夫环问题&quot;&gt;&lt;/a&gt;题解：约瑟夫环问题&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目背景&quot;&gt;&lt;a href=&quot;#题目背景&quot; class=&quot;headerlink&quot; title=&quot;题目背景&quot;&gt;&lt;/a&gt;题目背景&lt;/h2&gt;&lt;p&gt;据说著名犹太历史学家 Josephus有过以下的故事：在罗马人占领乔塔帕特后，39个犹太人与Josephus及他的朋友躲在一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。然而Josephus 和他的朋友并不想遵从。问题是，给定了总人数n和报数值m，一开始要站在什么地方才能避免被处决？Josephus要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;n个人(n&amp;lt;=100)围成一圈,从第一个人开始报数,数到m的人出列,再由下一个人重新从1开始报数,数到m的人再出圈,……依次类推,直到所有的人都出圈,请输出依次出圈人的编号。&lt;/p&gt;
&lt;h2 id=&quot;输入格式&quot;&gt;&lt;a href=&quot;#输入格式&quot; class=&quot;headerlink&quot; title=&quot;输入格式&quot;&gt;&lt;/a&gt;输入格式&lt;/h2&gt;&lt;p&gt;n m &lt;/p&gt;
&lt;h2 id=&quot;输出格式&quot;&gt;&lt;a href=&quot;#输出格式&quot; class=&quot;headerlink&quot; title=&quot;输出格式&quot;&gt;&lt;/a&gt;输出格式&lt;/h2&gt;&lt;p&gt;出圈的编号&lt;/p&gt;
&lt;h2 id=&quot;输入输出样例&quot;&gt;&lt;a href=&quot;#输入输出样例&quot; class=&quot;headerlink&quot; title=&quot;输入输出样例&quot;&gt;&lt;/a&gt;输入输出样例&lt;/h2&gt;&lt;h3 id=&quot;输入-1&quot;&gt;&lt;a href=&quot;#输入-1&quot; class=&quot;headerlink&quot; title=&quot;输入 #1&quot;&gt;&lt;/a&gt;输入 #1&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;10 3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;输出-1&quot;&gt;&lt;a href=&quot;#输出-1&quot; class=&quot;headerlink&quot; title=&quot;输出 #1&quot;&gt;&lt;/a&gt;输出 #1&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;3 6 9 2 7 1 8 5 10 4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;说明-提示&quot;&gt;&lt;a href=&quot;#说明-提示&quot; class=&quot;headerlink&quot; title=&quot;说明/提示&quot;&gt;&lt;/a&gt;说明/提示&lt;/h2&gt;&lt;p&gt;m, n ≤ 100&lt;/p&gt;
&lt;h2 id=&quot;解题方法&quot;&gt;&lt;a href=&quot;#解题方法&quot; class=&quot;headerlink&quot; title=&quot;解题方法&quot;&gt;&lt;/a&gt;解题方法&lt;/h2&gt;&lt;h3 id=&quot;解法一：模拟-指针模拟链表&quot;&gt;&lt;a href=&quot;#解法一：模拟-指针模拟链表&quot; class=&quot;headerlink&quot; title=&quot;解法一：模拟 + 指针模拟链表&quot;&gt;&lt;/a&gt;解法一：模拟 + 指针模拟链表&lt;/h3&gt;&lt;p&gt;时间复杂度：$O(m * n)$&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//Run on C++&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;cstdio&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;node&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; data;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    node* next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n, m;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;node *head, *p, *r;  &lt;span class=&quot;comment&quot;&gt;//head为头结点，p表示新节点，r表示当前节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d%d&quot;&lt;/span&gt;, &amp;amp;n, &amp;amp;m);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    head = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; node;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    head-&amp;gt;data = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    head-&amp;gt;next = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    r = head;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;; i &amp;lt;= n; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        p = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; node;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        p-&amp;gt;data = i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        p-&amp;gt;next = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        r-&amp;gt;next = p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        r = p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    r-&amp;gt;next = head; r = head; &lt;span class=&quot;comment&quot;&gt;//使链表首尾相连&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i &amp;lt;= n; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; j &amp;lt;= m - &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;; j++)    r = r-&amp;gt;next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d &quot;&lt;/span&gt;,r-&amp;gt;next-&amp;gt;data);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        r-&amp;gt;next = r-&amp;gt;next-&amp;gt;next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        r = r-&amp;gt;next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;解法二：模拟-数组模拟链表&quot;&gt;&lt;a href=&quot;#解法二：模拟-数组模拟链表&quot; class=&quot;headerlink&quot; title=&quot;解法二：模拟 + 数组模拟链表&quot;&gt;&lt;/a&gt;解法二：模拟 + 数组模拟链表&lt;/h3&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://G-SS-Hacker.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="C-plus-plus" scheme="https://G-SS-Hacker.github.io/tags/C-plus-plus/"/>
    
  </entry>
  
  <entry>
    <title>C++指针变量</title>
    <link href="https://g-ss-hacker.github.io/c-%E6%8C%87%E9%92%88%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
    <id>https://g-ss-hacker.github.io/c-%E6%8C%87%E9%92%88%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</id>
    <published>2019-08-05T13:15:09.000Z</published>
    <updated>2019-10-21T10:54:39.296Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=588336344,1667439626&amp;fm=26&amp;gp=0.jpg" alt></p><h1 id="指针变量"><a href="#指针变量" class="headerlink" title="指针变量"></a>指针变量</h1><p></p><p><font color="grey"> <em>Guderian出品</em> </font></p><p></p><h2 id="指针变量的定义、赋值"><a href="#指针变量的定义、赋值" class="headerlink" title="指针变量的定义、赋值"></a>指针变量的定义、赋值</h2><p>对指针变量的类型说明，一般形式为：</p><p><code>类型说明符 *变量名;</code></p><p>其中，<em>表示这是一个<strong>指针变量</strong>，变量名即为定义的<strong>指针变量名</strong>，类型说明符表示<em>*该指针变量所指向的变量的数据类型</em></em>。</p><h3 id="1、普通变量定义"><a href="#1、普通变量定义" class="headerlink" title="1、普通变量定义"></a><strong>1、普通变量定义</strong></h3><p><code>int a = 3;</code></p><p>定义了变量<code>a</code>，是<code>int</code>型的，值为3。内存中有一块内存空间是放<code>a</code>的值，对<code>a</code>的存取操作就是直接到这个内存空间存取。内存空间的位置叫<strong>地址</strong>，存放3的地址可以用<strong>取地址操作符</strong><code>&amp;</code>对<code>a</code>运算得到：<code>&amp;a</code>。</p><h3 id="2、指针变量定义"><a href="#2、指针变量定义" class="headerlink" title="2、指针变量定义"></a><strong>2、指针变量定义</strong></h3><p><code>int *p = NULL;</code></p><p>定义了一个指针变量<code>p</code>，<code>p</code>指向一个内存空间，里面存放的是一个内存地址。现在赋值为<code>NULL</code>（其实就是0，表示<strong>特殊的空地址</strong>）。</p><h3 id="3、给指针变量p赋值"><a href="#3、给指针变量p赋值" class="headerlink" title="3、给指针变量p赋值"></a>3、给指针变量p赋值</h3><p><code>p = &amp;a;</code></p><p><img src="https://i.loli.net/2019/08/04/7LRzME9rpsk3bdo.png" alt></p><a id="more"></a><p>即把<code>a</code>变量的内存空间地址（比如：XXX）给了<code>p</code>。显然，直接对<code>p</code>存取，操作的是地址。通过这个地址<strong>间接</strong>地操作，才是整数3。P的间接操作要使用指针操作符<code>“*”</code>，即<code>*p</code>的值才是3。设有指向整型变量的指针变量<code>p</code>，如要把整型变量<code>a</code>的地址赋予<code>p</code>可以有以下两种方式：</p><p>①指针变量初始化的方法</p><p><code>int a; int *p = &amp;a;</code></p><p>②赋值语句的方法</p><p><code>int a; int *p; p = &amp;a;</code></p><p>不允许把一个数赋予指针变量，故如下的赋值是错误的：<code>int *p；p = 1000；</code>。被赋值的指针变量前不能再加<code>“*”</code>说明符，故如下的赋值也是错误的：<code>*p = &amp;a；</code>。</p><p><div class="text" style=" text-align:center;">指针的几个相关操作说明表</div><br>| 说明                               | 样例                             |<br>| ————————————————— | ————————————————|<br>| 指针定义：<code>类型说明符 *指针变量名</code> | <code>int *p;</code>                        |<br>| 取地址运算符：<code>&amp;</code>                  | <code>p = &amp;a;</code>                        |<br>| 间接运算符：<code>*</code>                    | <code>*p = 20;</code>                       |<br>| 指针变量直接存取的是内存地址       | <code>cout&lt;&lt;p;</code>结果可能是：<code>0x24ae9d</code> |<br>| 间接存取的才是存储类型的值         | <code>cout&lt;&lt;*p;</code>结果是：<code>20</code>          |</p><p>指针变量同普通变量一样，使用之前不仅要定义说明，而且必须被赋值具体的值，未经赋值的指针变量不能使用。如定义了<code>int a; int *p = &amp;a;</code>，则<code>*p</code>表示<code>p</code>指向的整型变量，而<code>p</code>中存放的是变量<code>a</code>占用单元的起始地址，所以<code>*p</code>实际上访问了变量<code>a</code>，也就是说<code>*p</code>$ \Longleftrightarrow $<code>a</code>。</p><p><strong>【例1】输入两个不同的数，通过指针对两个数进行相加和相乘，并输出。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a, b, s, t, *pa, *pb;</span><br><span class="line">pa = &amp;a; pb = &amp;b;</span><br><span class="line">a = <span class="number">10</span>; b = <span class="number">20</span>;</span><br><span class="line">s = *pa + *pb;</span><br><span class="line">t = *pa * *pb;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d, b = %d\n"</span>, *pa, *pb);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"s = %d, t = %d\n"</span>, s, t);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span>, b = <span class="number">20</span></span><br><span class="line">s = <span class="number">30</span>, t = <span class="number">200</span></span><br></pre></td></tr></table></figure><h2 id="指针的引用与运算"><a href="#指针的引用与运算" class="headerlink" title="指针的引用与运算"></a>指针的引用与运算</h2><p>一般的，指针(<code>int *p</code>)与普通变量(<code>int a</code>)的对应关系为：</p><div class="table-container"><table><thead><tr><th>指针变量</th><th>普通变量</th></tr></thead><tbody><tr><td><code>p</code></td><td><code>&amp;a</code></td></tr><tr><td><code>*p</code></td><td><code>a</code></td></tr><tr><td><code>*p = 3</code></td><td><code>a = 3</code></td></tr></tbody></table></div><p>以下为指针的一些运算：</p><h3 id="1、指针变量的初始化"><a href="#1、指针变量的初始化" class="headerlink" title="1、指针变量的初始化"></a><strong>1、指针变量的初始化</strong></h3><p><div class="text" style=" text-align:center;">指针的几个初始化操作说明表</div><br>| 方法                  | 说明                              |<br>| ——————————- | ————————————————- |<br>| <code>int *p = NULL;</code>      | <code>NULL</code>是特殊的地址0，叫零指针     |<br>| <code>int a; int *p = &amp;a;</code> | <code>p</code>初始化为<code>a</code>的地址              |<br>| <code>int *p = new(int);</code>  | 申请一个空间给<code>p</code>，<code>*p</code>内容不确定 |</p><p>要强调的是，对于定义的局部指针变量，其内容（地址）是随机的，直接对它操作可能会破坏程序或系统内存的值，引发不可预测的错误。所有编程中指针变量要保证先初始化或赋值，给予正确的地址再使用，避免产生*<strong>野指针</strong>。</p><h3 id="2、指针变量的-、-运算"><a href="#2、指针变量的-、-运算" class="headerlink" title="2、指针变量的+、-运算"></a><strong>2、指针变量的+、-运算</strong></h3><p>指针变量的内容是内存地址，它有两个常用的运算：加、减，这两个运算一般都是配合数组操作的。</p><p><strong>【例2】输入N个整数，使用指针变量访问输出。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">101</span>], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line"><span class="keyword">int</span> p = &amp;a[<span class="number">1</span>]; <span class="comment">//定义指针变量int p，初始化为数组开始元素的地址，即a[1];</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, *p);</span><br><span class="line">p++;  <span class="comment">//p指向下一个数，详见说明</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输入：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">6</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">6</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>【说明】</strong></p><p><code>p++</code>的意思是“广义的加1”，不是<code>p</code>的值（地址）加1，而是根据类型<code>int</code>增加<code>sizeof（int）</code>，即刚好“<strong>跳过</strong>”一个整数的空间，达到下一个整数。</p><p>类似的：</p><p>①<code>p--</code>就是向前“跳过”一个整数的空间，达到前一个整数。</p><p>②<code>(p + 3)</code>就是指向后面第3个整数的地址。</p><h3 id="3、无类型指针"><a href="#3、无类型指针" class="headerlink" title="3、无类型指针"></a><strong>3、无类型指针</strong></h3><p>有时候，一个指针根据不同的情况，指向的内容是不同类型的值，我们可以<strong>先不明确</strong>定义它的类型，只是定义一个<strong>无类型</strong>的指针，以后根据需要再用<strong>强制类型转换</strong>的方法明确它的类型。</p><p><strong>【例3】无类型指针运用举例。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">double</span> b = <span class="number">3.5</span>;</span><br><span class="line"><span class="keyword">void</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p = &amp;a; <span class="comment">//p的地址赋值</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*(<span class="keyword">int</span>*)p&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//必须明确p指向的空间的数据类型，详见说明</span></span><br><span class="line">p = &amp;b;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*(<span class="keyword">double</span>*)p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">3.5</span><br></pre></td></tr></table></figure><p><strong>【说明】</strong></p><p>必须明确<code>p</code>指向的空间的数据类型，<strong>类型不一样的不仅空间大小不相同，储存的格式也不同</strong>。如果把<code>cout&lt;&lt;*(double*)p&lt;&lt;endl;</code>改成<code>cout&lt;&lt;*(long long*)p&lt;&lt;endl;</code>输出的结果将是：<code>4615063718147915776</code>。</p><h3 id="4、多重指针"><a href="#4、多重指针" class="headerlink" title="4、多重指针"></a><strong>4、多重指针</strong></h3><p>既然指针是指向其他类型的，指针本身也是一种类型。因此，C++允许递归地指针指向指针的指针——多重指针。</p><p><strong>【例4】双重指针运用举例。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> **pp; <span class="comment">//定义双重指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p = &amp;a; <span class="comment">//将p指向a</span></span><br><span class="line">pp = &amp;p; <span class="comment">//将pp指向p</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d = %d = %d\n"</span>, a, *p, **pp); <span class="comment">//**pp通过2次间接访问了a的变量的值10</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> = <span class="number">10</span> = <span class="number">10</span></span><br></pre></td></tr></table></figure><p><strong>【说明】</strong></p><p>多重指针可以多次“间接”访问数据；竞赛上主要的应用是*<strong>动态的多维数组</strong>，功能十分强大！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=588336344,1667439626&amp;amp;fm=26&amp;amp;gp=0.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;指针变量&quot;&gt;&lt;a href=&quot;#指针变量&quot; class=&quot;headerlink&quot; title=&quot;指针变量&quot;&gt;&lt;/a&gt;指针变量&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;grey&quot;&gt; &lt;em&gt;Guderian出品&lt;/em&gt; &lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;h2 id=&quot;指针变量的定义、赋值&quot;&gt;&lt;a href=&quot;#指针变量的定义、赋值&quot; class=&quot;headerlink&quot; title=&quot;指针变量的定义、赋值&quot;&gt;&lt;/a&gt;指针变量的定义、赋值&lt;/h2&gt;&lt;p&gt;对指针变量的类型说明，一般形式为：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;类型说明符 *变量名;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;em&gt;表示这是一个&lt;strong&gt;指针变量&lt;/strong&gt;，变量名即为定义的&lt;strong&gt;指针变量名&lt;/strong&gt;，类型说明符表示&lt;em&gt;*该指针变量所指向的变量的数据类型&lt;/em&gt;&lt;/em&gt;。&lt;/p&gt;
&lt;h3 id=&quot;1、普通变量定义&quot;&gt;&lt;a href=&quot;#1、普通变量定义&quot; class=&quot;headerlink&quot; title=&quot;1、普通变量定义&quot;&gt;&lt;/a&gt;&lt;strong&gt;1、普通变量定义&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;int a = 3;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;定义了变量&lt;code&gt;a&lt;/code&gt;，是&lt;code&gt;int&lt;/code&gt;型的，值为3。内存中有一块内存空间是放&lt;code&gt;a&lt;/code&gt;的值，对&lt;code&gt;a&lt;/code&gt;的存取操作就是直接到这个内存空间存取。内存空间的位置叫&lt;strong&gt;地址&lt;/strong&gt;，存放3的地址可以用&lt;strong&gt;取地址操作符&lt;/strong&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;对&lt;code&gt;a&lt;/code&gt;运算得到：&lt;code&gt;&amp;amp;a&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;2、指针变量定义&quot;&gt;&lt;a href=&quot;#2、指针变量定义&quot; class=&quot;headerlink&quot; title=&quot;2、指针变量定义&quot;&gt;&lt;/a&gt;&lt;strong&gt;2、指针变量定义&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;int *p = NULL;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;定义了一个指针变量&lt;code&gt;p&lt;/code&gt;，&lt;code&gt;p&lt;/code&gt;指向一个内存空间，里面存放的是一个内存地址。现在赋值为&lt;code&gt;NULL&lt;/code&gt;（其实就是0，表示&lt;strong&gt;特殊的空地址&lt;/strong&gt;）。&lt;/p&gt;
&lt;h3 id=&quot;3、给指针变量p赋值&quot;&gt;&lt;a href=&quot;#3、给指针变量p赋值&quot; class=&quot;headerlink&quot; title=&quot;3、给指针变量p赋值&quot;&gt;&lt;/a&gt;3、给指针变量p赋值&lt;/h3&gt;&lt;p&gt;&lt;code&gt;p = &amp;amp;a;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/04/7LRzME9rpsk3bdo.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://G-SS-Hacker.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="C-plus-plus" scheme="https://G-SS-Hacker.github.io/tags/C-plus-plus/"/>
    
  </entry>
  
</feed>
