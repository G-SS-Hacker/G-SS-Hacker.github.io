<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[题解：求解无向图上的哈密尔顿回路]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E9%A2%98%E8%A7%A3%EF%BC%9A%E6%B1%82%E8%A7%A3%E6%97%A0%E5%90%91%E5%9B%BE%E4%B8%8A%E7%9A%84%E5%93%88%E5%AF%86%E5%B0%94%E9%A1%BF%E5%9B%9E%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[题解：求解无向图上的哈密尔顿回路 Guderian出品 说明一个无向连通图$ G $点上的哈密尔顿（Hamiltion） 回路是指从图$ G $上的某个顶点出发， 经过图上所有其他顶点一次且仅一次， 最后回到该顶点的路径。 分析算法设计策略：回溯法+深度优先搜索+记忆化搜索 假设图$ G $存在一个从顶点$ V_0 $出发的哈密尔顿回路$ V_1-V_2-V_3-…-V_{n-1}-V_0$。算法从顶点$ V_0 $出发， 访问该顶点的一个未被访问的邻接顶点$ V_1$， 接着从顶点$ V_1 $出发， 访问$ V_1 $一个未被访问的邻接顶点$ V_2$，以此类推。对顶点$ V_i$， 重复进行以下操作： 访问$ V_i $的一个未被访问的邻接接点$ V_{i+1}$； 若$ V_i $的所有邻接顶点均已被访问， 则返回到顶点$ V_{i-1}$， 考虑$V_{i-1} $的下一个未被访问的邻接顶点， 仍记为$ V_i$； 知道找到一条哈密尔顿回路或者找不到哈密尔顿回路， 算法结束。 实现（1）常量和变量说明 n：图$G$中的顶点数 c[][]：图$G$的邻接矩阵 k：统计变量，当前已经访问的顶点数为k+1 x[k]：第k个访问的顶点编号，从0开始 visited[x[k]]：第k个顶点的访问标志，0表示未访问，1表示已访问 （2）C语言程序 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #define MAX 4 Void Hamilton(int n,int x[MAX],int c[MAX][MAX])&#123; int i; int visited[MAX]; int k; /*初始化x数组和visited数组*/ for(i=0;i&lt;n;i++)&#123; x[i]=0; Visited[i]=0; &#125; /*访问起初顶点*/ k=0; visited[0]=1; x[0]=0; k=k+1; /*访问其它顶点*/ while(k&gt;0)&#123; x[k]=x[k]+1; while(x[k]&lt;n)&#123; if(visited[x[k]]==0 &amp;&amp;c[x[k-1]][x[k]]==1)&#123;/*邻接顶点x[k]未被访问过*/ break; &#125; else&#123; x[k]=x[k]+1; &#125; &#125; if(x[k]&lt;n&amp;&amp;k==n-1&amp;&amp;c[x[0]][x[k]]==1)&#123;/*找到一条哈密尔顿回路*/ for(k=0;k&lt;n;k++)&#123; printf(“%d--”,x[k]);/*输出哈密尔顿回路*/ &#125; printf(“%d\n”,x[0]); return; &#125; else if(x[k]&amp;&amp;k&lt;n-1)&#123;/*设置当前顶点的访问标志，继续下一个顶点*/ visited[x[k]]=1 ; k=k+1; &#125; else &#123;/*没有未被访问过的领接顶点，回退到上一个顶点*/ x[k]=0; visited[x[k]]=0; k=k-1 ; &#125; &#125; &#125; （3）复杂度分析 时间复杂度：$O(n^n)$（爆搜） 空间复杂度：$O( n ^2)$]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解：切割钢条]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E9%A2%98%E8%A7%A3%EF%BC%9A%E5%88%87%E5%89%B2%E9%92%A2%E6%9D%A1%2F</url>
    <content type="text"><![CDATA[题解：切割钢条 故宫 by Gigi Guderian出品 说明某公司购买长钢条，将其切割后进行出售。切割钢条的成本可以忽略不计，钢条的长度为整英寸。已知价格表$ P$，其中中 $P_i（i＝1，2，…，m）$表示长度为$i$英寸的钢条的价格。现要求解使销售收益最大的切割方案 。 分析算法设计策略：动态规划 假设长钢条的长度为$ n $英寸，最佳切割方案的最左边切割段长度为$ i $英寸，则继续求解剩余长度为$ n－i $英寸钢条的最佳切割方案。考虑所有可能的$ i$，得到的最大收益$ r_n$对应的切割方案即为最佳切割方案。$r_n$的递归定义如下： r_n =\max_{1≤ i ≤n}(p_i +r_{n-i})对此递归式，给出自顶向下和自底向上两种实现方式。 实现（1）常量和变量说明 n：长钢条的长度 p[]：价格数组 （2）C语言程序 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;stdio.h&gt;#define LEN 100int Top_Down_Cut_Rod(int p[],int n)&#123; /*自顶向下*/ int r=0; int i; if(n==0)&#123; return 0; &#125; for(i=1;i&lt;=n;i++)&#123; int tmp=p[i]+Top_Down_Cut_Rod(p,n-i); r= (r&gt;=tmp) ? r : tmp; &#125; return r;&#125;int Bottom_Up_Cut_Rod(int p[],int n)&#123; /*自底向上*/ int r[LEN]=&#123;0&#125;; int temp=0; int i,j; for(j=1;j&lt;=n;j++)&#123; temp=0; for(i=1;i&lt;=j;i++)&#123; temp=(temp&gt;=p[i]+r[j-i]) ? temp : (p[i]+r[j-i]); &#125; r[j]=(temp&gt;=p[j]) ? temp : p[j]; &#125; return r[n];&#125;int main()&#123; /*示例数据*/ int p[11]=&#123;0,1,2,1,8,3,5,2,5,3,9&#125;; int a = Top_Down_Cut_Rod(p,10); int b = Bottom_Up_Cut_Rod(p,10); printf("%d %d\n",a,b); return 0;&#125; （3）复杂度分析 自顶向下（爆搜） 时间复杂度：$O(2^n)$ 空间复杂度：$O(1)$ 自底向上 时间复杂度：$O(n^2)$ 空间复杂度：$O(n)$]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解：字符配对]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E9%A2%98%E8%A7%A3%EF%BC%9A%E5%AD%97%E7%AC%A6%E9%85%8D%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[题解：字符配对 Aurora Guderian出品 说明给定一个字符$B=b_1 b_2\dots b_n$，其中$b_i \in \{A,C,G,U\}$。$B$上的二级结构是一组字符对集合$S=\{(b_i,b_j)\}$，其中$i,j\in \{1,2,\dots ,n\}$，并满足以下四个条件： （1）$S$中的每对字符是$(A,U),(U,A),(C,G),(G,C)$四种组合之一； （2）$S$中的每对字符之间至少有四个字符将其隔开，即$i&lt;j-4$； （3）$S$中的每一个字符（记为$b_k$）的配对存在两种情况：$b_k$不参与任何配对；$b_k$和$b_t$配对，其中$t&lt;k-4$； （4）（不交叉原则）若$(b_i,b_j)$和$(b_k,b_l)$是$S$种的两个字符对，且$i&lt;k$，则$i&lt;k&lt;j&lt;l$不成立。 $B$的具有最大可能字符对数的二级结构$S$被称为最优配对方案，求解最优配对方案中的字符对数的方法如下： 假设用$C(i,j)$表示字符序列$b_i b_{i+1} \dots b_j$的最优配对方案（即二级结构$S$）中的字符对数，则$C(i,j)$可以递归定义为： C(i,j)=\begin{cases} \max(C(i,j-1),\max(C(i,t-1)+1+C(t+1,j-1))), &b_t和b_j匹配且i]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解：N皇后问题]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E9%A2%98%E8%A7%A3%EF%BC%9AN%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题解：N皇后问题 Guderian出品 说明n皇后问题描述为：在一个$n \times n$的棋盘上摆放$n$个皇后，要求任意两个皇后不能冲突，即任意两个皇后不再同一行、同一列、同一斜线上。 分析算法设计策略：回溯法 将第$i$个皇后摆放在第$i$行，$i$从$1$开始，每个皇后都从第$1$列开始尝试。尝试时判断再该列摆放皇后是否与前面的皇后有冲突，如果没有冲突，则在该列摆放皇后，并考虑摆放下一个皇后；如果有冲突，则考虑下一列。 如果该行没有合适的位置，回溯到上一个皇后，考虑在原来位置的下一个位置上继续尝试摆放皇后，以此类推，直到找到所有合理的摆放方案。 实现解法一 新手回溯：朴素算法（1）常量和变量说明 n：皇后数，棋盘规模为$n\times n$ queen[]：皇后的摆放位置数组，queen[i]表示第$i$个皇后的位置，1&lt;=queen[i]&lt;=n （2）C语言程序 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;stdio.h&gt;#include&lt;math.h&gt;#define n 4int queen[n+1];void Show() //输出所有皇后摆放方案&#123; printf("("); for(int i = 1; i &lt;= n; i++) printf(" %d", queen[i]); printf(")\n");&#125;int Place(int j) //检查当前列能否放置皇后，不能返回0，能返回1&#123; for(int i = 1; i &lt; j; i++) //检查与已经摆放的皇后是否在通一列或者同一斜线上 if(queen[i] == queen[j] || fabs(queen[i]-queen[j]) == (j - i)) return 0; return 1;&#125;void Nqueen(int j)&#123; for(int i = 1; i &lt;= n; i++) &#123; queen[j] = i; if(Place(j)) if(j == n) //如果所有皇后都摆放好，则输出当前摆放方案 Show(); else //否则继续摆放下一个皇后 Nqueen(j + 1); &#125;&#125;int main()&#123; Nqueen(1); return 0;&#125; （3）复杂度分析 时间复杂度：$O(n!)$到$O(n^n)$ 空间复杂度：$O( n )$ 解法二 优化回溯：记忆化搜索（1）常量和变量说明 column[]：标记数组，对于第$i$列，column[i]为$0$说明没有皇后，为$1$说明有皇后 diagonal1[]：标记数组，对于第$i$条主对角线，diagonal1[]为$0$说明没有皇后，为$1$说明有皇后 diagonal2[]：标记数组，对于第$i$条次对角线，diagonal2[]为$0$说明没有皇后，为$1$说明有皇后 （2）C语言程序 123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;#include&lt;math.h&gt;#define n 4int queen[n+1],column[n+1],diagonal1[2*n+1],diagonal2[2*n+1]; //设置标记，回溯时不用枚举queen[]void Show()&#123; printf("("); for(int i = 1; i &lt;= n; i++) printf(" %d", queen[i]); printf(")\n");&#125;void Nqueen(int j)&#123; for(int i = 1; i &lt;= n; i++) if(column[i] + diagonal1[i - j + n] + diagonal2[i + j] == 0) &#123; queen[j] = i; column[i] = 1, diagonal1[i - j + n] = 1, diagonal2[i + j] = 1; if(j &lt; n) Nqueen(j + 1); else Show(); column[i] = 0, diagonal1[i - j + n] = 0, diagonal2[i + j] = 0; &#125;&#125;int main()&#123; Nqueen(1); return 0;&#125; （3）复杂度分析 时间复杂度：不超过$O(n!)$ 空间复杂度：$O( n )$ 对比当$n$较小时，解法二比解法一快至少$20$倍。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言常用字符串函数]]></title>
    <url>%2FG-SS-Hacker.github.io%2FC%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[C语言常用字符串函数 图：猎鹰重型🚀，SpaceX Falcon Heavy Guderian出品 用的时候要#include&lt;string.h&gt; 1 计算长度Prototype: int strlen(const *char str) Usage: 返回\0以前的字符串长度。 2 计算占用内存Prototype 1: unsigned int szieof(object) Prototype 2: unsigned int szieof object Prototype 3: unsigned int szieof(type_name) Usage: 返回对象或类型占用内存空间的大小 3 比较字符串 关于字符串大小：https://www.php.cn/faq/415854.html Prototype: int strcmp(const char *str1,const char *str2) Usage: 若str1比str2大，返回值大于0；若str1比str2小，返回值小于0；若str1大小与str2相等，返回值为0 4 复制字符串 可不要写出str1 = str2这样的代码，这可不是在复制数字 Prototype: char *strcpy(char *str1, const char *str2) Usage: 把串str2以\0截止的字符串写入串str1中，返回str1首地址，用的时候注意不要越界 5 拼接字符串Prototype: char *strcpy(char *str1, const char *str2)和char *strcat(char *str1, const char *str2,int n) Usage: 第一种，把str2拼到str1末尾；第二种，把str2前n个字符拼到str1末尾，返回str1首地址 6 字符串匹配Prototype: char *strstr(const char *str1, const char *str2) Usage: 返回在str1中第一次出现str2字符串的位置，如果未找到则返回null Guderian Present]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黎曼积分]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E9%BB%8E%E6%9B%BC%E7%A7%AF%E5%88%86%2F</url>
    <content type="text"><![CDATA[黎曼积分 图：silhouette of mountains and spectacular view from the mountain top Guderian出品 设$f(p)$是几何形体上的点函数，黎曼积分$\int_\Omega f(p) \mathrm{d} \Omega=\lim_{\lambda \to0} \sum_{i=1}^{n}f(p_i)\Delta\Omega_i$ 具体分为四类： 二重积分x-型域$\iint_\sigma f(x,y)\mathrm{d}\sigma=\iint_\sigma f(x,y)\mathrm{d}x\mathrm{d}y=\int_a^b\mathrm{d}x\int_{y_1(x)}^{y_2(x)} f(x,y)\mathrm{d}y$ y-型域$\iint_\sigma f(x,y)\mathrm{d}\sigma=\iint_\sigma f(x,y)\mathrm{d}x\mathrm{d}y=\int_c^d\mathrm{d}y\int_{x_1(x)}^{x_2(x)} f(x,y)\mathrm{d}x$ 极坐标$\iint_\sigma f(x,y)\mathrm{d}\sigma=\iint f(r,\theta)r\mathrm{d}r\mathrm{d}\theta=\int_\alpha^\beta\mathrm{d}\theta\int_{r_1(\theta)}^{r_2(\theta)}f(r,\theta)r\mathrm{d}r$ 三重积分投影法$\iiint_V f(x,y,z)\mathrm{d}x\mathrm{d}y\mathrm{d}z=\iint_{\sigma_{xy}}\mathrm{d}x\mathrm{d}y\int_{z_1(x,y)}^{z_2(x,y)}f(x,y,z)\mathrm{d}z$ 截面法$\iiint_V f(x,y,z)\mathrm{d}x\mathrm{d}y\mathrm{d}z=\int_a^b\mathrm{d}z\iint_{\sigma_z}f(x,y,z)\mathrm{d}x\mathrm{d}y$ 柱坐标系变换关系： $x=r\cos\theta$， $y=r\sin\theta$ 体积微元： $\mathrm{d}V=r\mathrm{d}r\mathrm{d}\theta\mathrm{d}z$ $\iiint_V f(x,y,z)\mathrm{d}x\mathrm{d}y\mathrm{d}z=\int_\alpha^\beta\mathrm{d}\theta\int_{r_1(\theta)}^{r_2(\theta)}r\mathrm{d}r\int_{z_1(r,\theta)}^{z_2(r,\theta)}f(r\cos\theta,r\sin \theta,z) \mathrm{d}z$ 球坐标系变换关系： $x=\rho\sin\phi\cos\theta$， $y=\rho\sin\phi\sin\theta$， $z=\rho\cos\theta$ 体积微元： $\mathrm{d}V=\rho^2\sin\phi\mathrm{d}\rho\mathrm{d}\phi\mathrm{d}\theta$ $\iiint_V f(x,y,z)\mathrm{d}x\mathrm{d}y\mathrm{d}z=\int_\alpha^\beta\mathrm{d}\theta\int_{\phi_1(\theta)}^{\phi_2(\theta)}\sin\phi\mathrm{d}\phi\int_{\rho_1(\theta,\phi)}^{\phi_2{\theta,\phi}}f(\rho\sin\phi\cos\theta,\rho\sin\phi\sin\theta,\rho\cos\theta)\rho^2\mathrm{d}\rho$ 第一型曲线积分$\int_lf(x,y,z)\mathrm{d}s=\int_\alpha^\beta f(x(t),y(t),z(t))\sqrt{x'^2(t)+y'^2(t)+z'^2(t)}\mathrm{d}t$ 第一型曲面积分$\iint_Sf(x,y,z)\mathrm{d}S=\iint_{\sigma_{xy}}f(x,y,z(x,y))\sqrt{1+(\frac{\partial z}{\partial x})^2+(\frac{\partial z}{\partial y})^2}\mathrm{d}\sigma$ 黎曼积分的应用曲面面积等价于积分函数为$1$的第一型曲面积分 $S=\iint_S\mathrm{d}S=\iint_{\sigma_{xy}}\sqrt{1+(\frac{\partial z}{\partial x})^2+(\frac{\partial z}{\partial y})^2}\mathrm{d}\sigma$ 曲顶柱体体积等价于积分函数为$1$的三重积分 $V=\iiint_V\mathrm{d}V=\iint_{\sigma_{xy}}z(x,y)\mathrm{d}\sigma$ 质心等价于积分函数$\mu(p)$为质量密度（及其与$x,y,z$乘积）的三重积分 $\bar{x}=\frac{\int_\Omega\mu(p)x\mathrm{d}\Omega}{\int_\Omega\mu(p)\mathrm{d}\Omega}$， $\bar{y}=\frac{\int_\Omega\mu(p)y\mathrm{d}\Omega}{\int_\Omega\mu(p)\mathrm{d}\Omega}$， $\bar{z}=\frac{\int_\Omega\mu(p)z\mathrm{d}\Omega}{\int_\Omega\mu(p)\mathrm{d}\Omega}$ 转动惯量仅针对坐标轴，等价于积分函数为质量密度$\mu(p)$与另外两个变量平方和的乘积的三重积分 $I_x=\int_\Omega\mu(p)(y^2+z^2)\mathrm{d}\Omega$，$I_y=\int_\Omega\mu(p)(x^2+z^2)\mathrm{d}\Omega$，$I_z=\int_\Omega\mu(p)(x^2+y^2)\mathrm{d}\Omega$ Presented by Guderian]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三角恒等变换所有公式]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E4%B8%89%E8%A7%92%E6%81%92%E7%AD%89%E5%8F%98%E6%8D%A2%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Licensed under cc0 license. Feel free to share it with others.😎]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基尔霍夫定律]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E5%9F%BA%E5%B0%94%E9%9C%8D%E5%A4%AB%E5%AE%9A%E5%BE%8B%2F</url>
    <content type="text"><![CDATA[基尔霍夫定律(Kirchhoff laws) Guderian出品 本文的讨论范围仅限于集中参数电路，适用于家庭电路，不适用于2000公里输电线或者洲际海底电缆。 这是什么？想必随便一个有初中文化的人都知道电路中的串联分压，并联分流定律，但是并非谁都知道基尔霍夫定律。基尔霍夫定律规定了电路中，电路结构对电流、电压的约束关系。分别称为基尔霍夫电流定律和基尔霍夫定律。根据基尔霍夫电压定律可以直接导出串联分压定律，根据基尔霍夫电流定律可以直接导出并联分流定律。 古斯塔夫·罗伯特·基尔霍夫（Gustav Robert Kirchhoff，1824～1887），德国物理学家，出生于柯尼斯堡（今俄罗斯加里宁格勒）。其人如图所示： 基尔霍夫电流定律（KCL） 基尔霍夫电流定律：流出（或流入）任一节点的支路电流代数和等于零。 即：$\sum i_k=0$（$i_k$表示第$k$条支路的电流）。规定$i_k$的参考方向为流出节点时，$i_k$取正号；$i_k$的参考方向为流入节点时，$i_k$取负号。 何谓节点？如图红圈所示 推论：广义基尔霍夫电流定律 流出（或流入）任一节点的闭合边界S电流代数和等于零。 这次我们把电路中的任意一个部分抽象为一个“节点”，同样的基尔霍夫电流定律依然成立。 推论：有进必有出 流出任一节点（闭合边界）电流的代数和等于流入该节点电流的代数和。 即：$\sum i_{流出}=\sum i_{流入}$ 性质：独立KCL方程个数 在含有n个节点的电路中，任意n-1个节点的KCL方程是一组独立方程，这些节点称为独立节点。（类似于线性代数中的向量线性无关） 基尔霍夫电压定律（KVL） 基尔霍夫电压定律：沿任一回路各支路电压的代数和等于零。 即：$\sum u_k=0$（$u_k$表示第$k$条支路的电压）。规定$u_k$的参考方向与回路方向相同时取+号，否则取-号。 何谓网孔？如图所示，回路$l1,l2,l3$皆为网孔，但$l4$不是网孔。可以把网孔理解为“最小回路”。 推论：有升必有降 沿任一回路，各支路电压降的代数和等于电压升的代数和。 即：$\sum u_{电压降}=\sum u_{电压升}$ 性质：路径无关性 任意两点之间的电压具有确定值，与计算路径无关。 性质：独立KVL方程个数 设电路有b个支路n个节点，平面电路的网孔数即独立KVL方程的个数等于b-n+1。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>电路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言实现单向链表]]></title>
    <url>%2FG-SS-Hacker.github.io%2FC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[C语言实现单向链表 图：武汉加油！中国必赢！ Guderian出品 完整代码 如图所示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/* * Presented by G-SS-Hacker * Share it if you like */ #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;//为节点申请内存空间#define NEW(x) NODE *x = (NODE *)malloc(sizeof(NODE))//释放内存空间#define DEL(x) free(x); x = NULL//检查是否成功申请内存#define JUD(x) if(x==NULL) exit(0)typedef struct node //结构体：节点&#123; int data; //数据 char name[20]; //名称 struct node *next; //后继节点指针&#125;NODE;typedef struct list //结构体：链表&#123; NODE *head; //头节点指针 NODE *tail; //尾节点指针 int len; //链表长度&#125;LIST;//初始化链表void InitList(LIST *list); //在链表尾部插入一个节点 void PushBack(LIST *list, int *data, const char name[]);//在链表尾部弹出一个节点 void PopBack(LIST *list);//在指定位置后插入一个节点 void InsertNode(LIST *list, int pos, int *data, const char name[]);//删除指定位置的节点 void DeleteNode(LIST *list, int pos);//访问指定位置的节点 NODE *GetNode(LIST *list, int pos);//打印整个链表 void PrintList(LIST *list);int main()&#123; LIST list = &#123;NULL, NULL, 0&#125;; InitList(&amp;list); /* 对链表的操作 int a1 = 123, a2 = 456; char c1[20] = "汤姆\0", c2[20] = "杰克\0"; PushBack(&amp;list, &amp;a1, c1); PushBack(&amp;list, &amp;a2, c2); NODE *p = GetNode(&amp;list, 1); PopBack(&amp;list); InsertNode(&amp;list, 0, &amp;a2, c2); PushBack(&amp;list, &amp;a2, c2); DeleteNode(&amp;list, 1); PrintList(&amp;list); */ return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116void InitList(LIST *list)&#123; NEW(node); JUD(node); node-&gt;next = NULL; list-&gt;head = node; list-&gt;tail = node;&#125;void PushBack(LIST *list, int *data, const char name[])&#123; NEW(node); JUD(node); node-&gt;data = *data; strcpy(node-&gt;name, name); node-&gt;next = NULL; list-&gt;tail-&gt;next = node; list-&gt;tail = node; list-&gt;len++;&#125;void PopBack(LIST *list)&#123; //检查非法输入 if (!list-&gt;len) return ; NODE *p = list-&gt;head; while(p-&gt;next!=list-&gt;tail) p = p-&gt;next; DEL(list-&gt;tail); list-&gt;tail = p; list-&gt;tail-&gt;next = NULL; list-&gt;len--;&#125;void InsertNode(LIST *list, int pos, int *data, const char name[])&#123; //检查非法输入 if (list-&gt;len&lt;pos || pos&lt;0) return ; //是否在链表尾部插入节点 if (pos==list-&gt;len) &#123; PushBack(list, data, name); return ; &#125; NODE *p = list-&gt;head; for(;pos;pos--) p = p-&gt;next; NEW(node); JUD(node); node-&gt;data = *data; strcpy(node-&gt;name, name); node-&gt;next = p-&gt;next; p-&gt;next = node; list-&gt;len++;&#125;void DeleteNode(LIST *list, int pos)&#123; //检查非法输入 if (list-&gt;len&lt;pos || !pos) return ; //是否在链表尾部删除节点 if (pos==list-&gt;len) &#123; PopBack(list); return ; &#125; NODE *p = list-&gt;head; for(--pos;pos;pos--) p = p-&gt;next; NODE *tmp = p-&gt;next; p-&gt;next = tmp-&gt;next; DEL(tmp); list-&gt;len--;&#125;NODE *GetNode(LIST *list, int pos)&#123; //检查非法输入 if (list-&gt;len&lt;pos || pos&lt;0) return NULL; printf("第%d个节点为", pos); NODE *p = list-&gt;head; for(;pos;pos--) p = p-&gt;next; printf("%.4d %s\n", p-&gt;data, p-&gt;name); return p; &#125;void PrintList(LIST *list)&#123; //检查非法输入 if (!list-&gt;len) return ; NODE *p = list-&gt;head-&gt;next; while(p!=NULL) &#123; printf("%.4d %s\n", p-&gt;data, p-&gt;name); p = p-&gt;next; &#125;&#125; 取消主函数中的注释，输出结果为： 123第1个节点为0123 汤姆0123 汤姆0456 杰克 【更多C语言系列】 C &amp; C++基本数据类型取值范围 C &amp; C++ memset 野指针的产生及其危害]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言基础学习笔记（11）：指针与数组的关系]]></title>
    <url>%2FG-SS-Hacker.github.io%2FC%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89%EF%BC%9A%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[C语言基础学习笔记（11）：指针与数组的关系 图： 北英格兰，惠特比港（Whitby Harbour） Guderian出品 指针与一维数组的关系一维数组在内存中是线性排列的。假设存在一个任意的int类型数组a[N]，数组名a代表了数组的首地址&amp;a[0]，则&amp;a[i]等价于(a+i)。注意这里a+1不是加上1个字节，而是取决于a的基类型（这里是int，即为4个字节）：a+1等价于a+sizeof(基类型)。因此我们可以得出一维数组元素的等价引用形式：a[i]等价于*(a+i)。下面举两个例子： 示例一用指针读入一维数组并用指针输出一维数组： 1234567891011121314151617#include &lt;stdio.h&gt;int main()&#123; int a[10], i, *p = NULL; p = a; for (i=0; i&lt;10; i++) scanf("%d", &amp;p[i]); p = a; for (i=0; i&lt;10; i++) printf("%d", p[i]); printf("\n"); return 0;&#125; 示例二示例一的另一种实现方式： 123456789101112131415#include &lt;stdio.h&gt;int main()&#123; int a[10], *p = NULL; for (p=a; p&lt;a+10; p++) scanf("%d", p); for (p=a; p&lt;a+10; p++) printf("%d", *p); printf("\n"); return 0;&#125; 指针与二维数组的关系 兄弟们，做好心理准备，下面的内容对萌新不友好 内存中数据的存储形式都是线性的，二维数组在内存中按行线性存储，但可以用两种方式看待它。 第一种方式：行是列的索引以a[2][3]为例，它的存储结构如图： 想要访问某一行某一列的元素，需要先访问某一行，再访问某一列：首先定义类型为int [3]的行指针int (*p)[3]（不要写成*p[3]，否则就成了有三个元素的指针数组）用于存储a[2][3]的行指针，只需这么做：p = a或者p = &amp;a[0]。 这里要正确理解a和&amp;a[0]的含义，一种较为简单的理解方式是：首先把a看做一个一维数组a[2]，有两个int [3]型元素，那么其首地址就是a或者&amp;a[0]；然后再把a[2]看成一个一维数组a[2][3]，那么其首地址就是a[0]或者*a。a和&amp;a[0]的含义就是第0行的行指针，*a和a[0]和&amp;a[0][0]的含义就是第0行第0列的指针（后面在第二种方式会讲到）。 123456789101112#include &lt;stdio.h&gt;int main()&#123; int a[2][3] = &#123;1,2,3,4,5,6&#125;; int (*p)[3]; p = a; for(int i=0; i&lt;2; i++) for(int j=0; j&lt;3; j++) printf("%d ", *(*(p+i)+j)); return 0;&#125; 输出结果为： 11 2 3 4 5 6 第二种方式：Only one dimension in RAM!这种方式模拟了数组在内存上存储的真实情况，把a[2][3]看做一维数组，先按行分块，每一块再按列排序，要访问一个元素只需计算它内存地址的偏移量即可。定义int *p;并令p = &amp;a[0][0]（或*a或a[0]），那么要访问a[i][j]只需等价于访问*(p+i*2+j)。 123456789101112#include &lt;stdio.h&gt;int main()&#123; int a[2][3] = &#123;1,2,3,4,5,6&#125;; int *p; p = *a; for(int i=0; i&lt;2; i++) for(int j=0; j&lt;3; j++) printf("%d ", *(p+i*2+j)); return 0;&#125; 输出结果为： 11 2 3 4 5 6 【更多C语言系列】 C &amp; C++基本数据类型取值范围 C &amp; C++ memset 野指针的产生及其危害]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言基础学习笔记（10）：字符串]]></title>
    <url>%2FG-SS-Hacker.github.io%2FC%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8810%EF%BC%89%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[C语言基础学习笔记（10）：字符串 图： 第一张黑洞照片（The first image of a black hole published in April 2019） ​ by 事件视野望远镜（Event Horizon Telescope） Guderian出品 C语言中没有专门的字符串数据类型。在定义字符串，字符数组的长度应比字符串长度多1，给\0留个位置： 12#define STR_LEN 80char str[STR_LEN+1]; C语言常用字符串处理操作函数：#include &lt;string.h&gt; （1）strlen(s);返回字符串s的长度 （2）strcpy(s1,s2);复制s2至s1，返回s1的指针 （3）strcat(s1,s2);复制s2接在s1末尾，返回s1的指针 （4）strcmp(s1,s2);比较s2和s1的大小，返回0表示相等，返回值大于零表示s1比s2大，返回值小于零表示s1比s2小。（比较规则：当出现第一对不相等的字符时，由这两个字符决定所在字符串的大小，返回其ASCII码比较的差值。） （5）strncpy(s1,s2,n);复制s2前面最多n个元素至s1中，比strcpy()更安全 （6）strncat(s1,s2,n);复制s2前面最多n个元素至s1末尾，比strcat()更安全 （7）strncmp(s1,s2,n);比较s2和s1前面最多n个元素的大小 向函数传递字符串的两种方法： （1）用字符数组作函数参数 （2）用字符指针作函数参数 用字符数组作函数参数示例：计算实际字符个数 12345678unsigned int MyStrlen(const char str[]) //防止原字符数组被修改&#123; int i; unsigned int len = 0; for (i=0; str[i]!='\0'; i++) len++; return len;&#125; 用字符指针作函数参数示例：计算实际字符个数 1234567unsigned int MyStrlen(const har *pstr) //防止原字符数组被修改&#123; unsigned int len = 0; for (; *pstr!='\0'; pstr++) len++; return len;&#125; 用字符指针作函数参数示例：计算实际字符个数（Optimized versoin） 1234567unsigned int MyStrlen(const char *pstr) //防止原字符数组被修改&#123; const char *start = pstr; while (*pstr) pstr++; return pstr-start;&#125; 用字符数组作函数参数示例：复制字符串 12345678910void MyStrcpy(char dst[], char src[])&#123; int i = 0; while (src[i]!='\0') &#123; dst[i] = src[i]; i++; &#125; dst[i] = '\0';&#125; 用字符指针作函数参数示例：复制字符串 12345678910void MyStrcpy(char *dst, char *src)&#123; while (*src!='\0') &#123; *dst = *src; src++; dst++ &#125; *dst = '\0';&#125; 用字符指针作函数参数示例：复制字符串（Insane versoin!!!） 1234void MyStrcpy(char *dst, const char *src)&#123; while (*dst++ = *src++); //空字符被赋值之后循环才结束&#125; 不要写没人能看懂的代码！第6点、第9点和第12点的代码风格仅供欣赏！DO NOT TRY IT AT HOME! 从函数返回字符指针，如strcpy()和strcat()的函数原型： strcpy()：char *strcpy(char *dstStr, const char *srcStr); strcat()：char *strcat(char *dstStr, const char *srcStr); 编程实现sgrcat()： 123456789101112131415161718192021#include &lt;stdio.h&gt;char *MyStrcat(char *dst, char *src);int main()&#123; char s1[10] = &#123;"123"&#125;; char s2[] = "45"; char *res = NULL; res = MyStrcat(s1,s2); printf("%s",res); return 0;&#125;char *MyStrcat(char *dst, char *src)&#123; char *pstr = dst; while (*dst!='\0') dst++; while (*dst++ = *src++); return pstr;&#125; 【更多C语言系列】 C &amp; C++基本数据类型取值范围 C &amp; C++ memset 野指针的产生及其危害]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言基础学习笔记（9）：指针]]></title>
    <url>%2FG-SS-Hacker.github.io%2FC%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%889%EF%BC%89%EF%BC%9A%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[C语言基础学习笔记（9）：指针 图：土星光环 Guderian出品 请把本文与本文与一篇上古时期的佛经C++的指针变量进行对比参考🕮 int *a和*a有着巨大的差别：int *a是定义一个指向int类型数据的指针a；*a是对指针a解引用（Pointer Dereference），*a*即为指针a所指向的内存地址上存储的数据。如： 123456789101112#include &lt;stdio.h&gt;int main()&#123; int a = 0, b = 1; int *pa, *pb; //不能写成int* pa, pb，这样只表示pa是一个指针变量，pb是一个整型变量 pa = &amp;a; pb = &amp;b; printf("a=%d, b=%d\n", a, b); printf("*pa=%d, *pb=%d\n", *pa, *pb); return 0;&#125; 输出结果为： 12a=0, b=1*pa=0, *pb=1 C语言中，只要pa指向a,*pa就是a的别名。 指针变量的一大应用就是用作函数参数，这样做的好处就是可以再被调函数中改变实参的值。比如： 123456789101112131415#include &lt;stdio.h&gt;void Func(int *par);int main()&#123; int arg = 1; printf("arg = %d\n", arg); Func(&amp;arg); printf("arg = %d\n", arg); return 0;&#125;void Func(int *par)&#123; printf("par = %d\n", *par); *par = 2;&#125; 输出结果为： 123arg = 1par = 1arg = 2 函数指针（Function Pointer）：就是指向函数的指针变量 数据类型 (*指针变量名)(形参列表) 函数指针示例： 若有函数原型：int Func(int a, int b); 则可定义函数指针int (*f)(int, int); 令f = Func;就是让f指向函数Func() 编译器将不带()的函数名解释为该函数的入口地址 函数指针变量存储的是函数在内存中的入口地址 正确写法int (*f)(int, int);。常见错误： （1）忘了写前一个()：int *f(int, int);，等价于声明了一个函数名为f、返回值是整型指针类型的函数； （2）忘了写后一个()：int (*f);，等价于定义了一个整型指针变量 看完再看：C++的指针变量 【更多C语言系列】 C &amp; C++基本数据类型取值范围 C &amp; C++ memset 野指针的产生及其危害]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言实现选择、插入、冒泡排序算法]]></title>
    <url>%2FG-SS-Hacker.github.io%2FC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E9%80%89%E6%8B%A9%E3%80%81%E6%8F%92%E5%85%A5%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[C语言实现选择、插入、冒泡排序算法 Guderian出品 准备工作123456789#include &lt;stdio.h&gt;const int N = 10;void swap(int *x, int *y);void Sort(int arr[], void(*f)(int *));void SelectionSort(int arr[]);void InsertionSort(int arr[]);void BubbleSort(int arr[]); 主函数1234567891011int main()&#123; int a[N] = &#123;2,1,3,9,8,6,5,0,4,7&#125;; Sort(a, InsertionSort); //此处选择排序算法 for (int i = 0; i &lt; N; i++) printf("%d ", a[i]); printf("\n"); return 0;&#125; 实现两数交换函数123456void swap(int *x, int *y)&#123; int tmp = *x; *x = *y; *y = tmp;&#125; 实现选择排序函数1234567891011void SelectionSort(int arr[])&#123; for (int i = 0; i &lt; N-1; i++) &#123; int min = i; for (int j = i+1; j &lt; N; j++) if (arr[j] &lt; arr[min]) min = j; swap(&amp;arr[i], &amp;arr[min]); &#125;&#125; 实现插入排序函数1234567891011121314void InsertionSort(int arr[])&#123; for (int i = 1; i &lt; N; i++) &#123; int j = i-1; int key = arr[i]; while(j &gt;= 0 &amp;&amp; arr[j] &gt;= key) &#123; arr[j+1] = arr[j]; j--; &#125; arr[j+1] = key; &#125;&#125; 实现冒泡排序函数12345678910111213void BubbleSort(int arr[])&#123; for (int i = 0, exchange = 1; exchange &amp;&amp; i &lt; N-1; i++) &#123; exchange = 0; for (int j = 0; j &lt; N-1-i; j++) if (arr[j] &gt; arr[j+1]) &#123; swap(&amp;arr[j], &amp;arr[j+1]); exchange = 1; &#125; &#125;&#125; 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;stdio.h&gt;#define N 10void swap(int *x, int *y);void Sort(int arr[], void(*f)(int *));void SelectionSort(int arr[]);void InsertionSort(int arr[]);void BubbleSort(int arr[]);int main()&#123; int a[N] = &#123;2,1,3,9,8,6,5,0,4,7&#125;; Sort(a, InsertionSort); //此处选择排序算法 for (int i = 0; i &lt; N; i++) printf("%d ", a[i]); printf("\n"); return 0;&#125;void swap(int *x, int *y)&#123; int tmp = *x; *x = *y; *y = tmp;&#125;void Sort(int arr[], void(*f)(int *))&#123; (*f)(arr);&#125;void SelectionSort(int arr[])&#123; for (int i = 0; i &lt; N-1; i++) &#123; int min = i; for (int j = i+1; j &lt; N; j++) if (arr[j] &lt; arr[min]) min = j; swap(&amp;arr[i], &amp;arr[min]); &#125;&#125;void InsertionSort(int arr[])&#123; for (int i = 1; i &lt; N; i++) &#123; int j = i-1; int key = arr[i]; while(j &gt;= 0 &amp;&amp; arr[j] &gt;= key) &#123; arr[j+1] = arr[j]; j--; &#125; arr[j+1] = key; &#125;&#125;void BubbleSort(int arr[])&#123; for (int i = 0, exchange = 1; exchange &amp;&amp; i &lt; N-1; i++) &#123; exchange = 0; for (int j = 0; j &lt; N-1-i; j++) if (arr[j] &gt; arr[j+1]) &#123; swap(&amp;arr[j], &amp;arr[j+1]); exchange = 1; &#125; &#125;&#125; 【更多C语言系列】 C &amp; C++基本数据类型取值范围 C &amp; C++ memset 野指针的产生及其危害]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>排序</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C和C++中memcpy用法]]></title>
    <url>%2FG-SS-Hacker.github.io%2FC%E5%92%8CC-%E4%B8%ADmemcpy%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[C和C++中memcpy()函数 Guderian出品 头文件 C： &lt;string.h&gt; C++： &lt;cstring&gt; 声明void *memcpy(void *str1, const void *str2, size_t n) 此处size_t变量类型等价于long unsigned int即无符号长整型，在32位机器上为32位，在64位机器为中64位。 注：32位机器指CPU通用寄存器的数据宽度为32位，也就是说CPU一次可以运行32bit数据 描述从内存 str2 复制 n 个字符到内存 str1 参数 str1 ——指向存储复制内容的目标数组。 str2 ——指向复制目标数组。 n——要被复制的字节数。 返回值返回一个指向存储区str1的指针。 实例12345678910111213#include &lt;stdio.h&gt;#include &lt;string.h&gt; int main ()&#123; char s[50] = "the quick brown fox jumps over the lazy dog"; char t[50]; memcpy(t, s, sizeof(s)); printf("%s\n", t); return(0);&#125; 输出结果： 1the quick brown fox jumps over the lazy dog 【更多C语言系列】 C &amp; C++基本数据类型取值范围 C &amp; C++ memset 野指针的产生及其危害]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C-plus-plus</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言基础学习笔记（8）：向函数传递数组]]></title>
    <url>%2FG-SS-Hacker.github.io%2FC%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%888%EF%BC%89%EF%BC%9A%E5%90%91%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[C语言基础学习笔记（8）：向函数传递数组 图：达拉斯（Dallas） Guderian出品 C语言中不允许用变量来定义数组的长度。 一维数组在内存中占用的字节数 = 数组长度 x sizeof（基类型）。 向函数传递一维数组，所传递的是数组的地址。因此，在函数中对形参进行修改，会使原来传入的数组发生变化。在调用函数时，应该使用不带下标的数组名作为函数实参（数组名就相当于数组的首地址）。 如：int func(int a[], int n); 注：通常不指定数组的长度，用另一个形参来制定数组的大小。 向函数传递二维数组，在声明函数的二维数组形参时，不能省略数组第二维的长度，必须知道列数才能正确计算a[i][j]在数组中相对于第一个元素的偏移位置。 如：int func(int a[][M], int n); 注：数组第二维的长度不可省略。 向函数传递一维数组示例：快速排序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;const int N = 10;void swap(int *x, int *y);void QuickSort(int arr[], int low, int high);int main()&#123; int a[N] = &#123;1,2,3,9,8,6,5,0,4,7&#125;; QuickSort(a, 0, N); for(int i = 0; i &lt; N; i++) printf("%d ", a[i]); printf("\n"); return 0;&#125;void swap(int *x, int *y)&#123; int tmp = *x; *x = *y; *y = tmp;&#125;void QuickSort(int arr[], int low, int high)&#123; if (low &gt;= high) return ; int mid = arr[high]; int left = low, right = high - 1; while(left &lt; right) &#123; while(arr[left] &lt; mid &amp;&amp; left &lt; right) left++; while(arr[right] &gt;= mid &amp;&amp; left &lt; right) right--; swap(&amp;arr[left], &amp;arr[right]); &#125; left += (arr[left] &lt; arr[high]); swap(&amp;arr[left], &amp;arr[high]); QuickSort(arr, low, left-1); QuickSort(arr, left+1, high);&#125; 输出结果为： 10 1 2 3 4 5 6 7 8 9 【更多C语言系列】 C &amp; C++基本数据类型取值范围 C &amp; C++ memset 野指针的产生及其危害]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>排序</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言基础学习笔记（7）：变量的存储类型]]></title>
    <url>%2FG-SS-Hacker.github.io%2FC%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%887%EF%BC%89%EF%BC%9A%E5%8F%98%E9%87%8F%E7%9A%84%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[C语言基础学习笔记（7）：变量的存储类型 Guderian出品 什么是变量的存储类型变量的存储类型：即编译器为变量分配内存的方式，决定了变量的生存期（Lifetime）。在静态存储区中分配内存的变量生存期是整个程序，全程占据内存；在动态存储区中分配内存的变量生存期是定义它的语句块。声明的方法是：存储类型 数据类型 变量名;。 编译器如何给变量分配内存编译器通过将变量名映射到不同的内存地址来实现作用域的划分，如全局变量位于RAM中的静态存储区，局部变量位于RAM中的动态存储区。 （1）只读存储区 存放机器代码和常量等只读数据 （2）静态存储区 存放全局变量和静态变量等 静态——发生在程序编译或链接时 （3）动态存储区 包括堆和栈。其中栈用于保存函数调用时的返回地址、形参、局部变量等 动态——发生在程序载入和运行时 变量的四种存储类型auto（自动变量）auto型变量属于动态存储类型变量，系统调用函数时临时分配内存空间，函数执行结束就释放。大多数情况下定义自动变量时可以省略auto，定义一个没有声明存储类型的变量，系统会缺省地认为这是一个自动变量。如： int a$\Longleftrightarrow$auto int a static（静态变量）从程序运行区占据内存，程序退出时释放内存。包括静态局部变量和静态全局变量。static变量的使用会损害程序的可读性，因此在能够满足算法功能的前提下尽量少用。 静态局部变量静态局部变量在函数执行结束时内存不被释放,函数下次执行变量的值不改变。如： 12345678910111213#include &lt;stdio.h&gt;int func(int foo);int main()&#123; for (int i = 1; i &lt;= 3; i++) printf("%d\n", func(1)); return 0;&#125;int func(int foo)&#123; static int bar = foo; //第一次执行函数后bar被赋初值 return ++bar; //第二次执行函数开始bar不会再被赋值&#125; 输出为： 123123 静态全局变量C语言编程涉及多文件结构时，每一个.c程序中的全局变量都可以被其他程序所调用。然而不同.c程序中的全局变量有可能重名，在调用同名全局变量时会导致错误的产生。因此，在使用全局变量时，为了保证该全局变量只能在本程序文件中被调用，可以把该全局变量声明为static类型。尽管如此，为了降低程序的耦合性，提高内聚程度，还是应该尽量减少全局变量的使用。 register（寄存器变量）相当于把一个auto类型的变量放入了CPU的寄存器中（而非内存中）。这么做的好处是读写该变量的速度大大加快（如控制循环语句的i,j.k等需要频繁读写的变量），但是众所周知CPU的寄存器空间很小，不能把大量变量放入CPU的寄存器中。 事实上，现代编译器会自动对我们写的代码进行优化，自动把需要提高读写速度的变量放入CPU寄存器中，无需我们手动声明。总之，没必要过于强调其作用。 extern（外部变量）如果我们想在全局变量的定义点前或在其他文件中访问这个变量，就要用到extern类型变量。extern变量的使用会损害程序的可读性，因此在能够满足算法功能的前提下尽量少用。 在全局变量的定义点前访问变量12345678910111213#include &lt;stdio.h&gt;void func();extern int a;int main()&#123; printf("%d\n", a); return 0;&#125;int a = 10;void func()&#123; printf("%d\n", a);&#125; 在其他文件中访问本文件的全局变量正确但不规范做法在同一个工程项目中，有两个文件main.c和a.c。main.c想要访问main.c中的a变量： main.c文件： 1234567#include &lt;stdio.h&gt;extern int a;int main()&#123; printf("%d\n", a); return 0;&#125; a.c文件： 1int a = 1; 正确且规范做法在同一个工程项目中，有三个文件main.c、a.h和a.c。main.c想要访问main.c中的a变量： main.c文件： 1234567#include &lt;stdio.h&gt;#include "a.h"int main()&#123; printf("%d\n", a); return 0;&#125; a.h文件： 1extern int a; a.c文件： 12#include "a.h"int a = 1; 【更多C语言系列】 C &amp; C++基本数据类型取值范围 C &amp; C++ memset 野指针的产生及其危害]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言基础学习笔记（6）：变量作用域、形参与实参]]></title>
    <url>%2FG-SS-Hacker.github.io%2FC%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89%EF%BC%9A%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E5%BD%A2%E5%8F%82%E4%B8%8E%E5%AE%9E%E5%8F%82%2F</url>
    <content type="text"><![CDATA[C语言基础学习笔记：变量作用域、形参与实参 图：联盟号飞船（Soyuz） Guderian出品 C语言中，作用域较小的局部变量隐藏作用于较大的局部变量。如： 1234567891011#include &lt;stdio.h&gt;int main()&#123; int a = 1, b = 2; &#123; int a = 3, b = 4; printf("a = %d, b = %d\n", a, b); &#125; printf("a = %d, b = %d", a, b); return 0;&#125; 输出结果为： 12a = 3, b = 4a = 1, b = 2 C语言中，局部变量隐藏全局变量。形参与全局变量同名不会相互干扰。 实参（argument）：在调用函数时传递给函数的参数，在调用时有确定的值 形参（parameter）：在定义函数名和函数体时使用的参数，目的是接收调用该函数时传入的参数。 总之，只要同名的变量出现在不同的作用域内二者互不干扰，编译器有能力区分不同作用域中的同名变量。 编译器如何区分不同作用域的同名变量呢？编译器没有变量名这个概念，只知道内存地址，通过将同名变量映射到不同的内存地址来实现作用域的划分，如全局变量位于RAM中的静态存储区，局部变量位于RAM中的动态存储区。 （1）只读存储区 存放机器代码和常量等只读数据 （2）静态存储区 存放全局变量和静态变量等 静态——发生在程序编译或链接时 （3）动态存储区 包括堆和栈。其中栈用于保存函数调用时的返回地址、形参、局部变量等 动态——发生在程序载入和运行时 【更多C语言系列】 C &amp; C++基本数据类型取值范围 C &amp; C++ memset 野指针的产生及其危害]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言基础学习笔记（5）：递归]]></title>
    <url>%2FG-SS-Hacker.github.io%2FC%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89%EF%BC%9A%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[C语言基础学习笔记（5）：递归 Guderian出品 把现成的代码拿来使用就称为复用，这么做可以大大提高编写效率。 C语言中的函数可以嵌套调用，不能嵌套定义。 定义.函数直接或间接调用了自己，称为递归调用（Recursive Call）。这样的函数，称为递归函数（Recursive Function）。 递归函数包含基本条件和一般条件。基本条件控制递归调用结束，一般条件控制递归调用项基本条件转化。如果没有基本条件或者一般条件不能转化为基本条件，此时递归无法结束，变成“无穷递归”。 通常下面三种情况需要使用递归： （1）数学定义是递归的：计算阶乘，最大公约数和斐波那契数列 （2）数据结构时递归的：队列、链表、树和图 （3）问题的解法是递归的：汉诺塔，骑士游历，八皇后问题 典型递归问题示例：汉诺塔问题（题目链接） 先考虑比较简单的情形：当只有2个圆盘的时候如何解决？ 将1号圆盘从A移到C 将2号圆盘从A移到B 将1号圆盘从C移到B 再考虑复杂的情形：当有n个圆盘的时候如何解决？使用数学归纳法，假设n-1个圆盘的汉诺塔问题已经解决，将“上面n-1个圆盘”看成一个整体： 将“上面n-1个圆盘”从A移到C 将第n号圆盘从A移到B 将“上面n-1个圆盘”从C移到B 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;void Hanoi(int n, char a, char b, char c);void Move(int n, char a, char b);int main()&#123; int n; printf("Input the number of disks:"); scanf("%d", &amp;n); printf("steps of moving %d disks form A to B by means of C:\n", n); Hanoi(n, 'A', 'B', 'C'); return 0;&#125;void Hanoi(int n, char a, char b, char c)&#123; if (n == 1) &#123; Move(n, a, b); &#125; else &#123; Hanoi(n-1, a, c, b); //将“上面n-1个圆盘”从A移到C Move(n, a, b); //将第n号圆盘从A移到B Hanoi(n-1, c, b, a); //将“上面n-1个圆盘”从C移到B &#125;&#125;void Move(int n, char a, char b)&#123; printf("Move %d: from %c to %c\n", n, a, b);&#125; 【更多C语言系列】 C &amp; C++基本数据类型取值范围 C &amp; C++ memset 野指针的产生及其危害]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言基础学习笔记（4）：函数与防御式编程]]></title>
    <url>%2FG-SS-Hacker.github.io%2FC%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89%EF%BC%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E9%98%B2%E5%BE%A1%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[C语言基础学习笔记（4）：函数与防御式编程 图：塔克拉玛干沙漠 Guderian出品 C语言函数的返回值类型，可以是数组以外的任意一种类型。 在函数调用的过程中，实参和形参占用不同的内存空间，可以同名。 当函数定义在函数调用之后，C89标准默认函数返回值类型为int，而C99不再支持隐含的函数声明。 把所有函数的定义都放在主函数的前面也不意味着不需要函数原型，因为不一定只有主函数会调用你定义的函数，还是有可能出现函数的调用出现在函数的定义之前的情况。 综合3和4，应该在程序开头写清所有的函数原型。 函数设计的基本原则： （1）函数规模要小 （2）函数功能要单一 （3）函数接口定义要清楚 断言：assert()为在&lt;assert.h&gt;中定义的宏，可把其“函数原型”视作void assert(int expression)。 （1）expression为真，pass （2）expression为假，中断程序 可以用if语句代替断言，代价是程序编译后的目标代码体积变大，运行效率下降；使用断言便于在调试程序时发现错误，不影响程序执行效率。断言仅用于debug版本调试程序，不能用作release版本；换句话说只能用它确保预期不会发生的状况的确不会发生，而不能用它检查可能发生的状况是否发生。注意一个assert只能检验一个条件。 【更多C语言系列】 C &amp; C++基本数据类型取值范围 C &amp; C++ memset 野指针的产生及其危害]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-gzip库压缩和解压方法]]></title>
    <url>%2FG-SS-Hacker.github.io%2FPython-gzip%E5%BA%93%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[python-gzip库压缩和解压方法 Guderian出品 使用gzip压缩文件 先用open()打开待压缩文件，再用gzip.opnen()打开压缩文件，最后读入待压缩文件内容并写入压文件中。 方法一1234567import gzip# 压缩文件：文件路径、待压缩文件名、压缩文件名def compress(path,name_in,name_out): with open(path+name_in,'rb') as f_in: with gzip.open(path+name_out,'wb') as f_out: f_out.write(f_in.read()) 方法二如果你不喜欢用with语句，还可以这么写（记得close()就行了）： 123456789import gzip# 压缩文件：文件路径、待压缩文件名、压缩文件名def compress(path,name_in,name_out): f_in = open(path+name_in,'rb') f_out = gzip.open(path+name_out,'wb') f_out.write(f_in.read()) f_in.close() f_out.close() 使用gzip解压文件 先用gzip.opnen()打开压缩文件，再用open()打开解压文件，最后读入压缩文件内容并写入解压文件中。 方法一1234567import gzip# 解压缩：文件路径、压缩文件名、解压缩文件名def decompress(path,name_in,name_out): with gzip.open(path+name_in,'rb') as f_in: with open(path+name_out,'wb') as f_out: f_out.write(f_in.read()) 方法二123456789import gzip# 解压缩：文件路径、压缩文件名、解压缩文件名def decompress(path,name_in,name_out): f_in = gzip.open(path+name_in,'rb') f_out = open(path+name_out,'wb') f_out.write(f_in.read()) f_in.close() f_out.close()]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[numpy中random.rand()和random.randn()函数]]></title>
    <url>%2FG-SS-Hacker.github.io%2Fnumpy%E4%B8%ADrandom-rand%E5%92%8Crandom-randn%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[numpy中random.rand()和random.randn()函数 图：芝加哥（Chicago） Guderian出品 random.rand()random.rand()的作用是产生一个随机数列表，其包含的所有数字的取值范围为[0, 1)且满足随机分布。其参数是用逗号,分隔的若干正整数，正整数的个数为产生列表的维度，每个正整数的大小为该维度列表的大小。不写参数即返回一个随机数。如： 123456789from numpy import random as rdprint(rd.rand())print('============================================================')print(rd.rand(4))print('============================================================')print(rd.rand(3,4))print('============================================================')print(rd.rand(2,2,2)) 以上代码输出结果为： 123456789101112130.25236670150458973============================================================[0.85489794 0.52771465 0.80216108 0.57248852]============================================================[[0.73314253 0.51901163 0.77088391 0.56885799] [0.46570988 0.34268891 0.06820935 0.37792418] [0.07962608 0.98281711 0.18161285 0.8118587 ]]============================================================[[[0.87496164 0.68841325] [0.56949441 0.16097144]] [[0.46688002 0.34517205] [0.22503996 0.59251187]]] random.randn()random.randn()的作用是产生一个随机数列表，其包含的所有数字满足标准正态分布（高斯分布）。其参数是用逗号,分隔的若干正整数，正整数的个数为产生列表的维度，每个正整数的大小为该维度列表的大小。不写参数即返回一个随机数。如： 123456789from numpy import random as rdprint(rd.randn())print('============================================================')print(rd.randn(4))print('============================================================')print(rd.randn(3,4))print('============================================================')print(rd.randn(2,2,2)) 以上代码输出结果为： 123456789101112130.5488828975747972============================================================[-0.24751502 -0.22512748 0.37969188 -0.11569475]============================================================[[-0.1466201 1.76939854 -0.00321878 -0.66646013] [-0.77183601 -0.26496068 1.10728223 -1.34873652] [ 0.59090275 0.03795507 -0.95272402 -1.20102365]]============================================================[[[-0.07904398 0.78989335] [ 2.18617751 -0.926691 ]] [[ 0.40184526 -0.79589304] [ 0.72023249 1.49161166]]] 标准正态分布（高斯分布）：均值为0，方差为1的分布]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言基础学习笔记（3）：关系运算符与逻辑运算符]]></title>
    <url>%2FG-SS-Hacker.github.io%2FC%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%EF%BC%9A%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[C语言基础学习笔记（3）：关系运算符与逻辑运算符 图：北极狐（Artic Fox） Guderian出品 C语言的“短路”特性：若表达式的值可由先计算的左操作数的值单独推导出来，那么将不再计算右操作数的值。“短路”特性有时很有用，如(i != 0) &amp;&amp; (j / i &gt; 0)使得不会发生除0的情况。 C条件表达式：表达式1 ? 表达式2 : 表达式3：如果表达式1为真，则返回表达式2；否则表达式3。 整数的数值溢出——上溢出：|一个数值运算结果| &gt; |类型能表示的最大数|。进位超过最高位而发生进位丢失或进位达到最高位而改变符号位。 对于无符号数，不能随意用a - b &lt; 0取代a &lt; b，因为前者可能发生数值溢出，导致判断结果发生错误。 浮点数的数值溢出，不仅有上溢出还有下溢出： 上溢出：|数值运算结果| &gt; |类型能表示的最大数| 下溢出：|数值运算结果| &lt; |类型能表示的最小数|，此时系统把该结果处理成机器0 把float赋值给int会丢失小数（不经四舍五入）。 &lt;stdlib.h&gt;中的exit(0)终止整个程序的执行强制返回操作系统。当其参数为0时表示正常退出，非0表示程序出错。 【更多C语言系列】 C &amp; C++基本数据类型取值范围 C &amp; C++ memset 野指针的产生及其危害]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C和C++中rand()函数]]></title>
    <url>%2FG-SS-Hacker.github.io%2FC%E5%92%8CC-%E4%B8%ADrand%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[C和C++中rand()函数 本文遵守cc0协议😎（图片和代码也是） Guderian出品 头文件&lt;stdlib.h&gt; 声明int rand(void) 描述生成一个随机数，其大小介于0和RAND_MAX之间。其中RAND_MAX在头文件&lt;stdlib.h和&lt;cstdlib&gt;中宏定义为#define RAND_MAX 0X7fff，十进制形式为32767即(1 &lt;&lt; 15) - 1。 使用方法调用rand()函数应该通过srand(unsigned int)设置随机数种子，一旦设置随机数种子，那么接下来程序将遵循同一个规则产生随机数。如果你没有设置随机数种子，那么程序将自动把随机数种子设置为1。 设置随机数种子为常数如果设置随机数种子为常数（如1），那么不管在什么时间、什么环境下运行程序都将得到相同的随机数。使用方法如下： 1234567891011//cc0#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; srand(1); int randnum = rand(); printf("%d\n", randnum); return 0;&#125; 设置随机数种子为系统时间戳如果想要得到不同的随机数，一种常用的方法是设置随机数种子为系统时间戳time(NULL)（先包含&lt;time.h&gt;头文件），即从1970年1月1日0时到当前时刻所经过的秒数。使用方法如下： 123456789101112//cc0#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;int main()&#123; srand (time(NULL)); int randnum = rand(); printf("%d\n", randnum); return 0;&#125; 【更多C语言系列】 C &amp; C++基本数据类型取值范围 C &amp; C++ memset 野指针的产生及其危害]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C-plus-plus</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言基础学习笔记（2）：格式化输入与输出]]></title>
    <url>%2FG-SS-Hacker.github.io%2FC%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%EF%BC%9A%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[C语言基础学习笔记（2）：格式化输入与输出 图：乞力马扎罗山（Kilimanjaro） Guderian出品 C语言格式化屏幕输出：printf(格式控制字符串, 输出值参数表); C语言格式化屏幕输入：scanf(格式控制字符串, 输入地址表); 问题：printf()用%作为格式字符的标识，那么如何输出%呢？C规定，连续两个百分号出现在格式控制字符串中就表示要输出一个百分号 如何分隔多个输入数据？ 1）空格、Tab或回车 2）达到输入位宽 3）遇到非法字符 如何判断scanf()函数读入了正确的数据项数呢？ 事实上，scanf()是有返回值的，它的返回值就是正确读入的数据项数。现在明白while(scanf(...))为什么正确了吧？ scanf()格式控制字符串中的普通字符原样输入。注意格式字符为%f, %e为输入float型且不能指定精度，格式字符为%c为一个字符包括空白字符（如空格和制表符）。 scanf()格式修饰符 字符型常量：所有的ASCII码都可以通过转义方式表示，其中\ddd为1到3位八进制ASCII码值所代表的字符，\xhh为1到2为十六进制ASCII码值所代表的字符。如：&#39;B&#39;等价于&#39;\102&#39;等价于&#39;\x42&#39;。 大小写英文字母的ASCII值相差32，即大写字母+32=小写字母。 单个字符的输入输出： putchar(ch)：向屏幕输出一个字符，字符型变量ch的值 ch = getchar()：从键盘接受的字符作为getchar()的函数值，无参数 用getchar()输入时应注意的问题：getchar()函数并不是直接读取用户输入的字符，而是将输入字符先放在输入缓冲队列中，再从缓冲队列读取字符，直到输入回车符或文件结束符EOF时，程序才认为输入结束；一行输入结束，getchar()才开始从输入缓冲队列读取字符，前面函数没读取的数据仍在缓冲队列中，将被下一个getchar()函数读取。 在Linux/Unix下键入Ctrl + D或在Windows下键入Ctrl + Z，getchar()函数的确是会返回-1即EOF（End Of File）的，严格意义上应该用int类型来接收getchar()的返回值。 注意用%c格式读入字符时，空格和回车等空白字符都会被当做有效字符读入，在%c前加一个空格可以忽略缓冲区中的空白字符。 【更多C语言系列】 C &amp; C++基本数据类型取值范围 C &amp; C++ memset 野指针的产生及其危害]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言基础学习笔记（1）：变量、算术运算与赋值运算]]></title>
    <url>%2FG-SS-Hacker.github.io%2FC%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E5%8F%98%E9%87%8F%E3%80%81%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E4%B8%8E%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[C语言基础学习笔记（1）：变量、算术运算与赋值运算 图：西安城墙 Guderian出品 C中取余运算的结果符号与被除数符号相同。 C中数字后面带个U， u, L, l, F,f的含义： U和u表示该数值是无符号整型（unsigned int）；L和l表示该数值是长整型（long）；F和f表示该数值是浮点型（float）。 C中数字后面带个H, h, B, b或数字前面带个0, 0x的含义： H和h表示该数值是十六进制数；B和b表示该数值是二进制数；前面带0表示该数值是八进制数；前面带0x表示该数值是十六进制数。 C标准常用数学函数： C中的多重赋值表达式：变量1 = 变量2 = 表达式。如a = b = 3，两个赋值运算符的优先级相同，在优先级相同的情况下考虑赋值表达式的结合性，赋值运算符的结合性是右结合的，即从右往左进行计算，即先执行右边的赋值运算b = 3，再执行a = (b = 3)。 C的算术表达式中不同类型数据的运算结果的类型是取值范围较大的那种类型。C编译器将所有操作数都转换成取值范围较大的操作数的类型，这一过程称为类型提升（Type Promotion）。其规则如下： 【更多C语言系列】 C &amp; C++基本数据类型取值范围 C &amp; C++ memset 野指针的产生及其危害]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习中的评价指标：F1-score]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87%EF%BC%9AF1-score%2F</url>
    <content type="text"><![CDATA[机器学习中的评价指标：F1-score 图：西雅图（Seattle） Guderian出品 回顾：F1-score的计算过程混淆矩阵（Confusion Matrix） 混淆矩阵也称误差矩阵，是表示精度评价的一种标准格式，用n行n列的矩阵形式来表示。 在机器学习领域，混淆矩阵用于衡量一个分类器的准确程度。对于二分类问题，将其样例根据真实类别和分类器的预测类别的组合划分为真正例$\mathrm{(True \, Positive)}$、假正例$\mathrm{(False \, Positive)}$、真反例$\mathrm{(True \, Negative)}$、假反例$\mathrm{(False \, Negative)}$四种情形。 对应混淆矩阵$\mathrm{(Confusion \, Matrix)}$如下表： .tg {border-collapse:collapse;border-spacing:0;}.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg .tg-0lax{text-align:left;vertical-align:top}.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top} 真实情况 预测结果 真 假 真 TP（真正例） FN（假反例） 假 FP（假正例） TN（真反例） 精确率（Precision）与召回率（Recall）根据混淆矩阵，我们可以得到如下定义： 精确率$\mathrm{(Precision)}$ $\mathrm{P=\frac{TP}{TP+FP} \times 100\%}$，表示真实情况和预测结果皆为真/预测结果为真 召回率$\mathrm{(Recall)}$ $\mathrm{R=\frac{TP}{TP+FN} \times 100 \%}$，表示真实情况和预测结果皆为真/真实情况为真 F1分数（F1-score） F1分数（$\mathrm{F1-score}$）即精确率与召回率的调和平均数（$\mathrm{Harmonic \, Mean}$），比算术平均数（$\mathrm{Arithmetic \, Mean}$）的评价效果更好。 $\mathrm{F1=\frac{2}{\frac1{P}+\frac1{R}}=\frac{2PR}{P+R}}$ 直观理解为什么F1-score能评价模型优劣在你训练的机器学习模型过程中，你往往希望能够兼顾精确率和召回率，并使用一个统一的单值评价指标来评价你的机器学习模型的训练效果。我们之所以使用调和平均而不是算术平均，是因为在算术平均中，任何一方对数值增长的贡献相当，任何一方对数值下降的责任也相当；而调和平均在增长的时候会偏袒较小值，也会惩罚精确率和召回率相差巨大的极端情况，很好地兼顾了精确率和召回率。 几何观点 上图为函数图象$z=f(x, y)=\frac{2xy}{x+y}$。显而易见当$x=1$，$y=0$或者$y=1$，$x=0$时，$z=0$，说明调和平均惩罚精确率和召回率相差很大的极端情况。当$x&lt;y$时，梯度$\mathrm{grad} \, z $在$x$方向增长比$y$方向快；当$y&lt;x$时，梯度$\mathrm{grad} \, z$在$y$方向增长比$x$方向快，即调和平均在增长的时候会偏袒较小值。 代数观点对函数$f(x, y)=\frac{2xy}{x+y}$，其图象关于平面$x=y$对称。分别求$f(x,y)$对$x$和$y$的偏导数： ​ $\frac{\partial f(x,y)}{\partial x}=\frac{2y^2}{(x+y)^2}$ ​ $\frac{\partial f(x,y)}{\partial y}=\frac{2x^2}{(x+y)^2}$ 当$x&lt;y$时，$\frac{\partial f(x,y)}{\partial x}&gt;\frac{\partial f(x,y)}{\partial y}$，梯度$\mathrm{grad} \, z $在$x$方向增长比$y$方向快； 当$y&lt;x$时，$\frac{\partial f(x,y)}{\partial y}&gt;\frac{\partial f(x,y)}{\partial x}$，梯度$\mathrm{grad} \, z$在$y$方向增长比$x$方向快，即调和平均在增长的时候会偏袒较小值。 可以看出，$\mathrm{F1-score}$是一种综合的评价指标,它要求总体高指标必须建立在同时满足高精确率和高召回率的情况之上。使得我们可以更方便快速地对不同模型进行比较，从而选择最优的那个模型。 Reference and lots of thanks：https://blog.csdn.net/otengyue/article/details/89426004]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C & C++基本数据类型取值范围]]></title>
    <url>%2FG-SS-Hacker.github.io%2FC%E5%92%8CC-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4%2F</url>
    <content type="text"><![CDATA[C &amp; C++基本数据类型取值范围 图：伦敦（London） Guderian出品 .tg {border-collapse:collapse;border-spacing:0;}.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top} 基本数据类型 关键字 存储大小 取数范围 整型 基本整型 int 4字节 -2^31 ~ 2^31-1 实型 长整型 long 4字节 -2^31 ~ 2^31-1 短整型 short 2字节 -2^15 ~ 2^15-1 无符号整型 unsigned unsigned int 4字节unsigned long 4字节unsigned short 2字节 unsigned int : 0 ~ 2^32-1unsigned long : 0 ~ 2^32-1unsigned short : 0 ~ 2^16-1 实型 单精度实型 float 4字节 1.2E-38 ~ 3.4E+38 精度6~7位有效数字 双精度实型 double 8字节 2.3E-308 ~ 1.7E+308 精度15~16位有效数字 长双精度实型 long double 16字节 3.4E-4932 ~ 1.1E+4932 精度19位有效数字 字符型 char 1字节 0 ~ 2^8-1 枚举类型 enum 我们不管遇到多复杂的数据类型都不要怕，我们戴口罩面对它。消除恐惧的最好办法就是面对恐惧！坚持就是胜利！学好C语言！奥利给！]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C-plus-plus</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Softmax函数反向传播求导详细过程]]></title>
    <url>%2FG-SS-Hacker.github.io%2FSoftmax%E5%87%BD%E6%95%B0%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E6%B1%82%E5%AF%BC%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Softmax函数反向传播求导详细过程 图：纽约，曼哈顿（Manhattan, New York） Guderian出品 回顾：Softmax函数正向传播第一步：计算Z函数对神经网络输出层（即第$ L $层）有$Z^{[L]}=W^{[L]}a^{[L-1]}+b^{[L]}$，其中$a^{[L-1]}$为上一层输出值。 第二步：计算Softmax函数for i in range(1, C + 1): ​ $\quad a_i^{[L]}=\frac{e^{Z_i^{[L]}}}{\sum_{k=1}^C e^{Z_k^{[L]}}}$ 其中$C$表示要预测的类别数，上式满足$\sum_{i=1}^C a_i{[L]}=1$，即输入样本属于各类别的概率和为$1$。 第三步：计算损失函数单个样本的损失函数为$L(a,y)=-\sum_{i=1}^C y_i\log{a_i}$，其中$y$为目标输出。 求导第一步：对Softmax函数求导​ 对$\mathrm{Softmax}$函数求导，即求$\frac{\partial a_i}{\partial z_j}$：第$\mathrm{i}$项输出对第$\mathrm{j}$项输入的偏导数。 ​ $\frac{\partial a_i}{\partial z_j}=\frac{\partial\frac{e^{z_i}}{\sum_{k=1}^C e^{z_k}}}{\partial z_j}$（省略$[ L ]$标记，默认为第$ L $层，下同），分类讨论： ​ $(1)$当$\mathrm{i=j}$时，把$a_i$分母中除$e^{z_j}$项外视作常量 ​ $\frac{\partial a_i}{\partial z_j}=\frac{\partial\frac{e^{z_j}}{\sum_{k=1}^C e^{z_k}}}{\partial z_j}=(\frac{e^{z_j}}{e^{z_j}+\sum_{k\ne j}^C e^{z_k}})^\prime=a_j(1-a_j)$ ​ $(2)$当$\mathrm{i\ne j}$时，把$a_i$分子和分母中除$e^{z_j}$项外视作常量 ​ $\frac{\partial a_i}{\partial z_j}=\frac{\partial\frac{e^{z_i}}{\sum_{k=1}^C e^{z_k}}}{\partial z_j}=(\frac{e^{z_i}}{e^{z_j}+\sum_{k\ne j}^C e^{z_k}})^\prime=\frac{e^{z_i}e^{z_j}}{\sum_{k=1}^C e^{z_k}}=-a_i a_j$ 第二步：对损失函数求导对损失函数求导，即求$\frac{\partial L}{\partial z_j}$：损失函数对第$\mathrm{j}$项输入的偏导数。 ​ $\because L(a,y)=-\sum_{i=1}^C y_i\log{a_i}$ ​ $\therefore \frac{\partial L}{\partial z_j}=-\sum_{i=1}^C y_i\frac{\partial \log a_i}{\partial z_j}=-\sum_{i=1}^C \frac{y_i}{a_i}\frac{\partial a_i}{\partial z_j}$ （把$y_i$视作常量，再用链导法则转化为对$\mathrm{Softmax}$函数求导） 分别代入$(1)(2)$得： $-\sum_{i=1}^C \frac{y_i}{a_i}\frac{\partial a_i}{\partial z_j}=-\frac{y_i}{a_i}\frac{\partial a_i}{\partial z_j} \, -\sum_{i=1,i \ne j}^C \frac{y_i}{a_i}\frac{\partial a_i}{\partial z_j}$ ​ ​ $\quad =$ $-\frac{y_j}{a_j}a_j(1-a_j)\,+\sum_{i=1,i \ne j}^C \frac{y_i}{a_i}a_ia_j$ ​ $\quad =$ $-y_j\, +y_ja_j\, +\sum_{i=1,i \ne j}^C y_ia_j$ ​ $\quad =$ $-y_j\, +\sum_{i=1}^C y_ia_j$ （合并$y_ja_j$至$\sum_{i=1,i \ne j}^C y_ia_j$中） ​ $\quad =$ $-y_i\, +a_j\sum_{i=1}^C y_i$ （提出$a_j$） ​ $\quad =$ $a_j-y_j$ 从上述结果可以看出，$\mathrm{Softmax}$回归和$\mathrm{Logistic}$回归中损失函数求导后具有相同的形式，这也说明了$\mathrm{Softmax}$回归和$\mathrm{Logistic}$回归具有相同的本质，$\mathrm{Softmax}$回归是$\mathrm{Logistic}$的推广。 Reference and lots of thanks：https://www.cnblogs.com/zhaopAC/p/9539118.html]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>神经网络</tag>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML建模工具——状态图]]></title>
    <url>%2FG-SS-Hacker.github.io%2FUML%E7%8A%B6%E6%80%81%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[【面向对象分析UML建模工具全部文章】 UML建模工具(1)——用例图 UML建模工具(2)——活动图 UML建模工具(3)——类图 UML建模工具(4)——顺序图 UML建模工具(5)——通信图 UML建模工具(6)——状态图 UML建模工具——状态图 图：马来西亚，吉隆坡（Kapa Lumpur） Guderian出品 状态图(Statechart Diagram)是描述一个实体（对象）基于事件反应的动态行为 完整的状态图例子 状态图的建模元素状态（State） 状态亮灯如上图所示，状态用圆角矩形表示，其中可以包括： 名称 进入动作 退出动作 内部迁移 子状态 事件（Event） 事件可视作引起一个状态迁移至另一个状态的激励条件 如以上状态图中，事件会员收货使得状态订单发货迁移至订单收货。 事件必须有意义，只有有意义的事件才会促成状态迁移，无意义的事件对状态不产生影响。 迁移（Transition） 如上图所示，迁移为状态之间的关联，且必须有事件触发器并满足一定触发条件才会产生状态间的迁移。 迁移由5部分组成： 源状态 事件触发器 触发条件 效应 目标状态 状态图建模注意事项 一个状态必须与其他状态有关联，不允许孤立存在 不允许只进不出或只出不进的迁移 不允许没有事件的迁移 Reference：https://edu.csdn.net/course/play/24559/273459]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>软件工程</tag>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML建模工具——通信图]]></title>
    <url>%2FG-SS-Hacker.github.io%2FUML%E9%80%9A%E4%BF%A1%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[【面向对象分析UML建模工具全部文章】 UML建模工具(1)——用例图 UML建模工具(2)——活动图 UML建模工具(3)——类图 UML建模工具(4)——顺序图 UML建模工具(5)——通信图 UML建模工具(6)——状态图 UML建模工具——通信图 图：旧金山湾，黑夜中的金门大桥（Golden Gate Bridge） Guderian出品 通信图（Communication diagram）和顺序图都属于UML交互图，与顺序图本质上是一样的，可以互换 但二者建模的角度不同 1 通信图 强调随着时间的推移，各对象是如何交互的 通信图 强调对象之间的结构关系 通信图的组成元素 对象（object） 链接（link） 注意虽然链接和关联的图形都是一条实线，但是此处的链接是对象之间的关系，而关联是类之间的关系 消息（message） 完整的通信图例子 技术员张三创建了一个工具 技术员张三使用了这个工具 2.1 工具检查了A103号锅炉 2.2 工具维修了A103号锅炉 技术员张三销毁了这个工具 1. http://coursehome.zhihuishu.com/courseHome/2049439#teachTeam &#8617;]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>软件工程</tag>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML建模工具——顺序图]]></title>
    <url>%2FG-SS-Hacker.github.io%2FUML%E9%A1%BA%E5%BA%8F%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[【面向对象分析UML建模工具全部文章】 UML建模工具(1)——用例图 UML建模工具(2)——活动图 UML建模工具(3)——类图 UML建模工具(4)——顺序图 UML建模工具(5)——通信图 UML建模工具(6)——状态图 UML建模工具——顺序图 图：旧金山湾区，晚霞下的泛美金字塔（Transamerica Pyramid） Guderian出品 顺序图和通信图都属于UML交互图 顺序图（Sequence）是场景（Scenario）的图形化表示，描述了以时间顺序组织的对象之间的交互活动 完整的UML顺序图例子 基本建模元素 对象 对象生命线 控制焦点 消息：调用消息、返回消息、异步消息、自关联消息 对象销毁 结构化控制 同步消息与异步消息同步消息 发送方向接收方发送消息，接收方接收此消息并回复发送方。发送者在收到接收者的回复之前不会发送另一条消息。 如：老师想张三问了一个问题，张三必须当场给予回复，老师才会问下一个同学问题。 异步消息 发送方向接收方发送消息，发送者在收到接收者的回复之前可以进行其他活动。 如：老师给张三布置了一个问题，让张三课后思考一下如何解决，然后问其他同学问题。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>软件工程</tag>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML建模工具——类图]]></title>
    <url>%2FG-SS-Hacker.github.io%2FUML%E7%B1%BB%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[【面向对象分析UML建模工具全部文章】 UML建模工具(1)——用例图 UML建模工具(2)——活动图 UML建模工具(3)——类图 UML建模工具(4)——顺序图 UML建模工具(5)——通信图 UML建模工具(6)——状态图 UML建模工具——类图 图：巴尔的摩（Baltimore） Guderian出品 本文部分内容（已用上标[1]标注）演绎自：https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html © Copyright 2014, Colin http://blog.me115.com 用例图和活动图用于需求分析，当需求明确之后，则需要用类图进行设计。 回顾什么是类（Class）？ 具有相同属性、方法的一组对象的描述符 什么是对象（Object）？ 对象是类的实例 什么是类图（Class diagram）？ 把类相关的元素画在一起，即为类图 （玄之又玄，众妙之门） 完整的类图例子 1 车的类图结构为&lt;&lt;abstract&gt;&gt;，表示车是一个抽象类； 它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示； 小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示； 小汽车与发动机之间是组合关系，使用带实心箭头的实线表示； 学生与班级之间是聚合关系，使用带空心箭头的实线表示； 学生与身份证之间为关联关系，使用一根实线表示； 学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示； 类图中的元素 类 接口 协作 类之间的关系 关系类型 说明 表示符号 依赖（Dependency） 独立事物发生变化会影响依赖事物 关联（Association） 整体与部分关系 泛化（Generalization） 特殊/一般关系 实现（Realization） 实现表示一个class类实现interface接口（可以是多个）的功能 聚合（Aggregation） A has B，B是A的一部分，但A不控制B的生命周期 组合（Composition） A has B，B是A的一部分，且A控制B的生命周期 依赖（Dependency） 1依赖关系是用一套带箭头的虚线表示的；如下图表示A依赖于B；他描述一个对象在运行期间会用到另一个对象的关系； 与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化； 依赖关系也可能发生变化； 显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生； 注：在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方外，还是“使用”对方的方法和属性； 关联（Association） 1关联关系是用一条直线表示的；它描述不同类的对象之间的结构关系；它是一种静态关系， 通常与运行状态无关，一般由常识等因素决定的；它一般用来定义对象之间静态的、天然的结构； 所以，关联关系是一种“强关联”的关系； 比如，乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系； 关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如下图，表示A知道B，但 B不知道A； 注：在最终代码中，关联对象通常是以成员变量的形式实现的； 泛化（Generalization） 1类的继承结构表现在UML中为：泛化(generalize)与实现(realize)： 继承关系为 is-a的关系；两个对象之间如果可以用 is-a 来表示，就是继承关系：（..是..) eg：自行车是车、猫是动物 泛化关系用一条带空心箭头的直接表示；如下图表示（A继承自B）； eg：汽车在现实中有实现，可用汽车定义具体的对象；汽车与SUV之间为泛化关系； 注：最终代码中，泛化关系表现为继承非抽象类； 实现（Realization） 1实现关系用一条带空心箭头的虚线表示； eg：”车”为一个抽象概念，在现实中并无法直接用来定义对象；只有指明具体的子类(汽车还是自行车)，才 可以用来定义对象（”车”这个类在C++中用抽象类表示，在JAVA中有接口这个概念，更容易理解） 注：最终代码中，实现关系表现为继承抽象类； 聚合（Aggregation） 1聚合关系用一条带空心菱形箭头的直线表示，如下图表示A聚合到B上，或者说B由A组成； 聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义；例如一个部门由多个员工组成； 与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如， 部门撤销了，人员不会消失，他们依然存在； 组合（Composition） 1组合关系用一条带实心菱形箭头直线表示，如下图表示A组成B，或者B由A组成； 与聚合关系一样，组合关系同样表示整体由部分构成的语义；比如公司由多个部门组成； 但组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了；例如， 公司不存在了，部门也将不存在了； 关联关系的修饰名称及其方向 角色及可见性 在关联的每一端，表明相连的类在该关联关系中的作用 多重性（Multiplicity） 修饰（Adornment） 语义（Semantics） 0..1 0or1 1 Exactly 1 0..* 0 or more 1..* 1 or more m..n m to n m..n, p..q m to n or p to q * 0 or more 名词说明： Fighter Jet：战斗机 Pilot：飞行员 Missile：导弹 Engine：发动机 在图中： 一架战斗机有一个飞行员 一架战斗机能携带零或多枚导弹 一架战斗机有两台发动机 1. Reference and lots of thanks：https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html &#8617;]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>软件工程</tag>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML建模工具——活动图]]></title>
    <url>%2FG-SS-Hacker.github.io%2FUML%E6%B4%BB%E5%8A%A8%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[【面向对象分析UML建模工具全部文章】 UML建模工具(1)——用例图 UML建模工具(2)——活动图 UML建模工具(3)——类图 UML建模工具(4)——顺序图 UML建模工具(5)——通信图 UML建模工具(6)——状态图 UML建模工具——活动图 图：香港九龙(Kowloon, Hong Kong) Guderian出品 定义 活动图（Activity Diagram）是一种特殊的状态图，它展现了在系统内从一个活动到另一个活动的流程 活动图与用例图互为补充，主要用于需求分析阶段 基本建模元素 开始（Initial Node）、结束（Final Node）、对象（Objects） 动作（Actions） 分支（Decision Nodes） 分岔和汇合（Forking and Joining） 泳道（Partition） 开始、结束、对象 动作/活动节点 一个活动节点是一个过程中进行的非原子的执行单元，活动的执行最终延伸为一些独立动作的（Action）的执行 分支 分支相当于编程语言中的if语句，可以有一个进入流和多个离去流 分岔和汇合 分差表示把一个单独的控制流分成两个或多个并发的控制流。汇合表示两个或多个并发控制流的同步发生，一个汇合可以有两个或多个进入转移和一个输出转移。用同步棒来说明并行控制流的分岔和汇合。 泳道 将一个活动图中的活动分组，每一组表示一个特定的类别、人或部门，他们负责组内的活动，每个组被称为一个泳道，用一条垂直的实线把它们分开。每个活动严格属于每一个泳道，转移（流）和同步棒（分差与汇合）可以跨越泳道。 完整的活动图例子电商平台 货物交易]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>软件工程</tag>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML建模工具——用例图]]></title>
    <url>%2FG-SS-Hacker.github.io%2FUML%E7%94%A8%E4%BE%8B%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[【面向对象分析UML建模工具全部文章】 UML建模工具(1)——用例图 UML建模工具(2)——活动图 UML建模工具(3)——类图 UML建模工具(4)——顺序图 UML建模工具(5)——通信图 UML建模工具(6)——状态图 UML建模工具——用例图 Guderian出品 系统 System 参与者 Actors 用例 Use Cases 关系 Relationships 系统（System） 一个系统就是你开发的所有东西，可以是网站、软件组件、业务流程、应用程序、etc. 用一个矩形代表一个系统，然后将系统名称放在顶部。矩形用于定义系统的范围，矩形内的所有内容都在系统内发生，矩形外的所有内容都不会在系统外发生。 如图所示，灰色区域即为飞行控制系统，而副驾驶、机长都是系统外内容，属于参与者。 参与者（Actor） 使用我们的系统（与系统交互）实现目标的某人或某物，可以是一个人、一个组织、另一个系统或一个外部设备 参与者的普通图形用火柴人表示；当另一个系统充当参与者时，参与者的图形用矩形表示。 在软件工程中，参与者告诉我们我们这个系统应该具有的功能。不同的参与者希望获得不同的功能，我们需要找到重要的参与者，认真调查他们的需求，并根据不同参与者的需求完善系统。 用例（Use Case） 系统为响应参与者引发的一个事件而执行的一系列的处理/动作，而这些处理应该为参与者产生一种有价值的结果 用椭圆形容一个用例，代表要系统做的一个任务。 关系（Relationship）用例图中涉及的关系有：关联、泛化、包含、扩展 关系类型 说明 表示符号 关联（Association） 参与者与用例之间的关系 泛化（Inheritance） 参与者之间或用例之间的关系 包含（Include） 用例之间的关系 扩展（Extend） 用例之间的关系 关联（Association） 关联关系，用实线表示。表示参与者与用例之间的通信，任何一方都可以发送和接受信息。 参与者Actor与用例Use Case相关联，参与者既要向用例发送信息，也要就收用例反馈的信息。 泛化（Inheritance） 泛化关系，实现+空心箭头，从子类指向父类。 （account拼错了） 如上图所示，用户User可以被细分为VIP用户和游客Guest；登录Log in也可以被细分为邮箱登录Log in by email和QQ登录Log in by QQ account。 包含（Include） 包含关系，把一个较复杂用例所表示的功能分解成较小的步骤，是上一个用例执行过程中必不可少的。箭头指向包含的子用例。 如上图所示，系统维护System Maintenance的工作包含了添加Add、删除Remove和修正Modify。 扩展（Extend） 扩展关系，用例功能的延伸，相当于为基础用例提供一个附加功能，不是必不可少的。箭头指向被扩展的父用例。 如上图所示，打喷嚏Sneeze必然包含闭眼Close Eyes的过程，因此Sneeze和Close Eyes是包含关系；打完喷嚏Sneeze之后不一定需要道歉Say Excuse Me，因此Sneeze和Say Excuse Me是扩展关系。 完整的用例图例子 这是一个Bank app系统，参与者包括用户Customer和银行数据库Bank，用户可以进行的操作包括登录Log in、验证余额Check Balance、转账Transfer Funds、支付Make Payment和建立档案Set Up Profile。 用户登录后，需要验证密码Verify Password，因此Log in和Verify Password是包含关系；如果用户输入密码错误，则展示错误信息Display Login Error，因此Log in和Display Login Error是扩展关系（用户不一定会输错密码）。 用户验证余额、转账和支付都需要银行数据库来帮助实现，因此验证余额、转账和支付和Bank都是关联关系。而用户进行转账和支付操作时，都必须验证用户账户资金是否足够Veirify Sufficient Funds，因此转账、支付和Verify Sufficient Funds是包含关系。 用户在支付时，可以选择使用支票支付Pay from Checking或余额支付Pay from Savings，故支票支付和余额支付与支付是泛化关系。 此处有一个带有扩展点Extension Points的用例：建立档案Set Up Profile。用例名称在上方，扩展点在下方。扩展点是扩展关系的详细叙述。这个用例表明用户可以再Banking App中建立自己的档案，当用户在建立他们的档案是，可以选择转移至几个不同的屏幕。如果用户感到困惑，他们可以转到档案帮助页面Go to Profile Help；如果用户希望了解隐私信息，他们可以转到隐私信息页面Show Privacy Info。还可以添加注释，以写明导致扩展的情况发生的条件。 Reference：https://www.youtube.com/watch?v=zid-MVo7M-E]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>软件工程</tag>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象绪论]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%AA%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[面向对象绪论 Guderian出品 面向对象的基本概念 类 Class 对象 Object 浅显理解：类是抽象的对象，对象是具体的类 概念之间的互用 属性 Attribute == 数据 Data == 状态 State == 信息 Information 操作 Operation == 方法 Method == 行为 Behavior == 职责 Responsibility 对象 Object == 实例 Instance 面向对象的核心特征 封装 Encapsulation 继承 Inheritance 多态 Polymorphism 封装、继承和多态被称为所谓的“面向对象三大特征” 聚合/组合 Aggregation / Composition 接口/实现 Interface / Implementation 抽象 Abstraction 封装 Encapsulation 是指隐藏对象的属性和实现细节，仅对外提供公共访问方式 封装什么？ 内部的、不想让其他人随意了解的信息 类的属性 Attribute 类的方法 Method 为什么要封装？ 保护隐私 保护数据安全 隔离复杂度 面向对象的封装有四种方式 Public Private Protected Package 继承 Inheritance 一个类从其他类获得它的状态和行为，同时还可以加上自己额外的状态和行为 父类中的属性和方法，在子类中可以重复使用，子类就不需要再定义了，这样即可实现代码的可重用性。如以下类图例子，定义类C1Dobject一维物体，它有一个属性x对应x轴上的一个坐标，两个方法getx()和setx(int)分别表示x坐标的获取和设置。如果我们需要定义二维物体，就没有必要把x坐标重复定义。我们在类C1Dobject的基础上派生出子类C2Dobject，只需再定义属性y和方法gety()及sety(int)就可以完整地抽象出一个二维物体；类似地，如果我们需要定义三维物体，没有必要把x坐标、y坐标重复定义，只需再类C2Dobject的基础上派生出子类C3Dobject，再定义属性z和方法getz()及setz(int)即可。显而易见，继承提高了代码的可重用性，减少了创建类的工作量。 以上类图对应的C++代码如下： 1234567891011121314151617181920212223242526class C1Dobject&#123;private: int x = 0;public: int getx() &#123; return x; &#125; void setx(int xPrime) &#123; x = xPrime; &#125;&#125;;class C2Dobject: public C1Dobject&#123;private: int y = 0;public: int gety() &#123; return y; &#125; void sety(int yPrime) &#123; y = yPrime; &#125;&#125;;class C3Dobject: public C2Dobject&#123;private: int z = 0;public: int getz() &#123; return z; &#125; void setz(int zPrime) &#123; z = zPrime; &#125;&#125;; 多态 Polymorphism 使用指向父类的指针或者引用，能够调用子类的对象 结论： 当一个类从另一个类继承而来，多态使得子类可以代替父类 消息发送方不需要知道消息接收方属于哪一个子类 同一类族的接收者可以按自己的方式处理消息 如以下类图例子，定义形状CShape作为父类，派生出矩形CRectangle和三角形CTriangle。现在假设我们知道一个图形shape，希望获取它的面积，而我们并不需要知道它的具体形状（属于哪一个子类），只需要确保shape所属的类在CShape的类组下即可。图形shape的面积可以通过调用函数area()实现。 C++中多态的实现涉及静态多态和动态多态以及虚函数的使用，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;using namespace std;class CShape&#123;protected: int width, height;public: CShape(int a = 0, int b = 0) &#123; width = a, height = b; &#125; //纯虚函数，具体功能在子类中实现 virtual int area() = 0;&#125;;class CRectangle: public CShape&#123;public: //显式调用父类的构造函数 CRectangle( int a = 0, int b = 0): CShape(a, b) &#123;&#125;; int area() &#123; cout &lt;&lt; "CRectangle area calls: "; return width * height; &#125;&#125;;class CTriangle: public CShape&#123;public: //显式调用父类的构造函数 CTriangle( int a = 0, int b = 0): CShape(a, b) &#123;&#125;; int area() &#123; cout &lt;&lt; "CTriangle area calls: "; return width * height / 2; &#125;&#125;;int main()&#123; CShape *ptr; CRectangle rect(10, 10); CTriangle tri(10, 10); //获取矩形的面积 ptr = &amp;rect; cout &lt;&lt; ptr-&gt;area() &lt;&lt; endl; //获取三角形的面积 ptr = &amp;tri; cout &lt;&lt; ptr-&gt;area() &lt;&lt; endl; return 0;&#125; C++中构成多态需要满足两个条件： 调用函数的对象须是指针或引用 被调用的函数须是重写 1的虚函数 2 聚合/组合 Aggregation / Composition聚合 Aggregation A has B，B是A的一部分，但A不控制B的生命周期 如：学校由学生组成，那么学校与学生是聚合关系 UML图中聚合关系的符号如下图 组合 Composition A has B，B是A的一部分，且A控制B的生命周期 如：树由树叶组成，那么树与树叶是组合关系 UML图中聚合关系的符号如下图 接口/实现 Interface / Implementation接口 Interface 描述一个类的用户如何与这个类交互 实现 Implementation 完成接口所定义的功能，如类、构建等完成的任务 如电视机、插座、发电厂的关系如何呢？ 电视机是用户 client 插座是接口 Interface 发电厂是实现 Implementation 抽象 Abstraction 抽取具体客观事物的共性 抽象是面向对象领域发现类的主要方法 （所谓抽象，玄之又玄，众妙之门） 1. 重写：函数重写必须函数名一致、参数一致、返回值一致 &#8617; 2. 虚函数：在类的成员函数前加virtual关键字 &#8617;]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C-plus-plus</tag>
        <tag>OOP</tag>
        <tag>面向对象</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二次曲面]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E4%BA%8C%E6%AC%A1%E6%9B%B2%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[二次曲面 图：Watch Dog 2 by Ubisoft Guderian出品 1.椭圆柱面 \frac{x^2}{a^2}+\frac{y^2}{b^2}=1 2.双曲柱面 \frac{x^2}{a^2}-\frac{y^2}{b^2}=1 3.抛物柱面 x^2=2py,(p\ne 0) 4.椭球面 \frac{x^2}{a^2}+\frac{y^2}{b^2}+\frac{z^2}{c^2}=1 5.单叶双曲面 \frac{x^2}{a^2}+\frac{y^2}{b^2}-\frac{z^2}{c^2}=1 6.双叶双曲面 \frac{x^2}{a^2}-\frac{y^2}{b^2}-\frac{z^2}{c^2}=1 7.椭圆抛物面 \frac{x^2}{2p}+\frac{y^2}{2q}=z,(p,q同号) 8.双曲抛物面 \frac{x^2}{2p}-\frac{y^2}{2q}=z,(p,q同号)变种： x^2-y^2=z 9.二次锥面 \frac{x^2}{a^2}+\frac{y^2}{b^2}+\frac{z^2}{c^2}=0 ~我们遇到什么困难也不要怕，微笑着面对它！消除恐惧的最好办法就是面对恐惧！坚持就是胜利！加油！奥利给！~ 【其他文章·微积分·线性代数】 不定积分公式 常用泰勒展开式 高阶求导公式 高等数学公式 常用等价无穷小 导数基本公式 矩阵章节总结 行列式章节总结 线性方程组章节总结]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象设计七大原则]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[面向对象设计七大原则 图：北京航空航天大学 Guderian出品 AKA：设计模式七大原则 1. 单一职责原则 SRP，Single Responsibility Principle 每一个对象有且只有一个职责，从而实现”高内聚、低耦合“ 防止一个类实现多个功能，改变一个功能后影响其他功能的正常运作 2. 开放-封闭原则 OCP，Open-Closed Principle 对拓展开放、对修改关闭 需要对程序进行拓展的时候，不能修改原有代码，只能在原有代码的基础上添加 3. 李氏替换原则 LSP，Liskov Substitution Principle 任何基类出现的地方，一定可以用派生类代替 派生类可以拓展基类的功能，但不能改变基类的功能 4. 依赖倒置原则 DIP，Dependence Inversion Principle 实现依赖于抽象，而抽象不依赖于实现 解除高层组件对低层组件的依赖，是实现开闭原则的重要基础 5. 接口隔离原则 ISP，Interface Segregation Principle 一个类对另外一个类的依赖性应当是建立在最小的接口上 在特定的使用场合给特定用户提供其需要的方法、屏蔽其不需要的方法 6. 组合重用原则 CRP, Composite Reuse Principle, 尽量使用组合，尽量不用继承 在新的对象里面使用已有的对象，使之成为新的对象的一部分 7. 迪米特原则 LoD，Law of Demeter 一个对象应该对其他对象又尽可能少的了解 尽量降低成员的访问权限，提供访问器而不公开成员变量 注：C++中只有抽象类的概念，JAVA中既有抽象类的概念，又有接口的概念。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++引用]]></title>
    <url>%2FG-SS-Hacker.github.io%2FC-%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[C++引用 图：LEGO小人仔 Guderian出品 笔记整理自《北京大学公开课：C++面向对象程序设计》 C++跟C相比，多了很多独特的内容，其中有很多都是为了实现面向对象编程范式而引入的，C++的引用就是其一。 引用的概念 定义一个引用，并将其初始化为引用某个变量的通用写法：类型名 &amp; 引用名 = 某变量名 某个变量的引用，等价于这个变量，相当于该变量的一个别名 12345678int n = 7;int &amp; r = n;//r引用了n，r的类型是int &amp;r = 4;cout &lt;&lt; r; //输出4cour &lt;&lt; n; //输出4n = 5;cout &lt;&lt; n; 定义引用时一定要将其初始化成引用某个变量，而不像指针可以指向某个变量也可以不指向某个变量 初始化后，它就一直引用该变量，不会再引用别的变量了（引用是从一而终的） 引用只能引用变量，不能引用常量和表达式 1234567double a = 3, b = 5;double &amp; r1 = a;double &amp; r2 = r1; //r2也引用ar2 = 10;cout &lt;&lt; a &lt;&lt; endl; //输出10r1 = b; //r1并没有引用bcout &lt;&lt; a &lt;&lt; endl; //输出5 引用的应用C中，如何编写交换两个整型变量值的函数? 这样写吗？ 12345678void swap(int a, int b)&#123; int tmp; tmp = a; a = b; b = tmp;&#125;int n1, n2;swap(n1, n2);//n1, n2的值没有被交换 这是错误的，改变形参不会改变实参。 或者用指针？ 12345678void swap(int *a, int *b)&#123; int tmp; tmp = *a; *a = *b; *b = tmp;&#125;int n1, n2;swap(&amp; n1, &amp; n2); //取地址//n1, n2的值被交换 正确，但丑陋！ 那么C++中，如何编写交换两个整型变量值的函数? 引用作为参数 C++示例：交换两个整数 12345678void swap(int &amp; a, int &amp; b) //a就是n1，b就是n2&#123; int tmp; tmp = a; a = b; b = tmp;&#125;int n1, n2;swap(n1, n2);//n1, n2的值被交换 引用作为返回值12345678910111213int n = 4;int &amp; SetValue() &#123; return n; &#125;int main()&#123; //神奇之处，对函数的返回值进行赋值 SetValue() = 40; //然而它究竟有什么作用呢？我还没想好... cout &lt;&lt; n; //输出：40 return 0;&#125; 注意被引用的对象不能超过作用域，返回一个局部变量的引用是不合法的，但是，可以返回一个静态类型变量的引用。 常引用定义引用时，在前面加const关键字即为“常引用”。 12int n;const int &amp; r = n; 注意不能通过常引用去修改其引用的内容！ 1234int n = 100;const int &amp; r = n;r = 200; //errn = 300; //ok 常引用和非常引用的转换 const T &amp;和T &amp;是不同的类型（千万要注意！！！） T &amp;类型的引用或T类型的变量可以用来初始化const T &amp;类型的引用 const T类型的常变量和const T &amp;类型的引用则不能用来初始化T &amp;类型的引用，除非进行强制类型转换 参考并整理自《C++面向对象设计》郭炜，北京大学，感谢原作者！编辑时有删改]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C-plus-plus</tag>
        <tag>OOP</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++继承和派生]]></title>
    <url>%2FG-SS-Hacker.github.io%2FC-%E7%BB%A7%E6%89%BF%E5%92%8C%E6%B4%BE%E7%94%9F%2F</url>
    <content type="text"><![CDATA[C++继承和派生 图：古老的地球 Guderian出品 本文整理自《北京大学公开课：C++面向对象程序设计》 基本概念 继承和派生实际上是一回事：在定义一个新的类B时，如果该类与某个已有的类A相似（指的是B拥有A的全部特点），那么可以把A作为一个基类，而把B作为基类的一个派生类（也称子类），这使得创建和维护一个程序更加容易 派生类拥有基类的全部特点，派生类还可以对基类进行修改和扩充。在派生类中，可以扩充新的成员变量和成员函数 派生类一经定义，可以独立使用，定义对象时不依赖于基类 派生类拥有基类的全部成员函数和成员变量。不论是private、protected、public 在派生类的各个成员函数中，不能访问基类的private成员 简单理解成员修饰符protected和private的区别：protected成员在派生类中可以被访问，而private不能 对象不同类型对应的访问权限： 类型 public protected private 本类 √ √ √ 派生类 √ √ × 其他类 √ × × 派生类的写法12345class 派生类名: 访问修饰符 基类名 //Zhclass derived-class: access-specifier base-class //En&#123; //...&#125;; 访问修饰符可以是private、protected、public中的一个。如果未使用访问修饰符，则默认为private。该访问修饰符规定了继承类型。 继承类型 公有继承（public）：继承public和protected且类型不变，不继承private 保护继承（protected）：继承public和protected且类型都为protected，不继承private 私有继承（private）：继承public和protected且类型都变为private，不继承private 一般使用公有继承。 写法示例：学生管理系统1234567891011121314151617181920212223242526272829class CStudent&#123; private: string sName; int nAge; public: bool IsThreeGood() &#123;&#125;; void SetName(const string &amp; name) &#123; sName = name; &#125; //...&#125;;class CUndergraduteStudent: public CStudent//本科生&#123; private: int nDepartment; public: bool IsThreeGood() &#123;/*...*/&#125;; //覆盖（不是重载！覆盖的参数表不变，重载的参数表改变！） //名字与基类一样，但行为不一样 bool CanBaoYan() &#123;/*...*/&#125;;&#125;;class CGraduatedStudent: public CStudent//研究生&#123; private: int nDepartment; char szMentorName[20]; public: int CountSalary() &#123;/*...*/&#125;;&#125;; 派生类对象的内存空间派生类对象的体积 = 基类对象的体积 + 派生类对象自己的成员变量的体积。 在派生类对象中，包含基类对象，而且基类对象的存储位置位于派生类对象新增的成员变量之前。 学籍管理程序实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class CStudent&#123; private: string name; string id; char gender; int age; public: void PrintInfo(); void SetInfo(const string &amp; name_, const string % id_, int age_, char gender_); string GetName() &#123; return name; &#125;&#125;;class CUndergraduteStudent: public CStudent&#123;//本科生类，继承了CStudent类 private: string department; //学生所属的系的名称 public: void QualifiedForBaoyan() //给予保研资格 &#123; cout &lt;&lt; "qualified for baoyan" &lt;&lt; endl; &#125; void PrintInfo() &#123; CStudent::PrintInfo(); //调用基类的PrintInfo cout &lt;&lt; "Department" &lt;&lt; department &lt;&lt; endl; &#125; void SetInfo(const string &amp; name_, const string % id_, int age_, char gender_) &#123; CStudent::SetInfo(name_, id_, age_, gender_); //调用基类的SetInfo department = department_; &#125;&#125;;int main()&#123; CUndergraduteStudent s2; s2.SetInfo("Guderian", "999999999", 21, "M", "Combat Command"); //古德里安，999999999，,2岁，男性，战役指挥学 s2.QualifiedForBaoyan(); //获得保研资格 s2.PrintInfo(); //打印信息 return 0;&#125;//输出：Guderian qualified for baoyanName: GuderianID: 999999999Age: 21Gender: MDepartment: Combat Command 派生类的使用方法 在派生类中，调用基类的成员函数，设置了从基类继承的信息之后，之后再设置自己独有的信息。这一方法在C++面向对象编程中是很常用的。 多继承：一个子类可以有多个父亲，继承多个父亲的特性 参考并整理自《C++面向对象设计》郭炜，北京大学，感谢原作者！编辑时有删改]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C-plus-plus</tag>
        <tag>OOP</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++友元]]></title>
    <url>%2FG-SS-Hacker.github.io%2FC-%E5%8F%8B%E5%85%83%2F</url>
    <content type="text"><![CDATA[C++友元 Guderian出品 本文整理自《北京大学公开课：C++面向对象程序设计》 友元很简单，在某种程度上算作是C++设计者对C使用者的妥协。友元分为友元函数和友元类两种。 友元函数一个类的友元函数可以访问该类的私有成员，友元函数不是这个类的成员函数，可以是一个普通的全局函数或其他类的成员函数 123456789101112131415161718192021222324252627class CCar; //提前声明CCar是一个类，以便后面的CDriver类使用class CDriver&#123; public: void ModifyCar(CCar *pCar);&#125;;class CCar&#123; private: int price; friend int MostExpensiveCar(CCar cars[], int total); //声明友元 friend void CDriver::ModifyCar(CCar *pCar) //声明友元&#125;;void CDriver::ModifyCar(CCar *pCar)&#123; pCar-&gt;price += 1000; //汽车改装后价值增加&#125;int MostExpensiveCar(CCar cars[], int total)&#123; int tmpMax = -1; for(int i = 0; i &lt; total; ++i) if(cars[i].price &gt; tmpMax) tmpMax = cars[i].price; return tmpMax; &#125; 可以将一个类的成员函数（包括构造、析构函数）说明为另一个类的友元 123456789class B&#123; public: void function();&#125;;class A&#123; friend void B::function();&#125;; 友元类如果A是B的友元类，那么A的所有成员函数可以访问B的所有私有成员 12345678910111213141516class CCar&#123; private: int price; friend class CDriver; //声明CDriver为友元类&#125;;class CDriver&#123; public: CCar myCar; void ModifyCar() //改装汽车 &#123; myCar.price += 1000; //因CDriver是CCar的友元类故可以访问其私有成员 &#125;&#125;; 友元类之间的关系不能传递：类A是类B的友元，类C是类B的友元，但类A不是类C的友元 友元类之间的关系不能继承]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C-plus-plus</tag>
        <tag>OOP</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++常量对象、常量成员函数和常引用]]></title>
    <url>%2FG-SS-Hacker.github.io%2FC-%E5%B8%B8%E9%87%8F%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B8%B8%E9%87%8F%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%92%8C%E5%B8%B8%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[C++常量对象、常量成员函数和常引用 图：广州塔 Guderian出品 本文整理自《北京大学公开课：C++面向对象程序设计》 常量对象如果不希望某个对象的值被改变，则定义该对象的时候可在前面加const关键字。 123456789class CDemo&#123; private: int vale; public: void SetValue() &#123;&#125;&#125;;const Demo obj; //常量对象 常量成员函数在类的成员函数说明后面可以加const关键字，则该成员函数成为常量成员函数。 常量成员函数执行期间不应该修改其所作用的对象。因此，在常量成员函数中不能修改成员变量的值（静态成员变量除外），也不能调用同类的非常量成员函数（静态成员函数除外）。 非常亮成员函数在执行的过程中是有可能修改掉常量成员函数中的值的。 12345678910111213141516171819202122232425class Sample&#123; public: int value; void GetValue() const; void func() &#123;&#125;; Sample() &#123;&#125;&#125;;void Sample::GetValue() const&#123; value = 0; //wrong,不能修改成员变量的值 func(); //wrong,不能调用同类的非常量成员函数&#125;int main()&#123; const Sample o; o.value = 100; //err,不能修改成员变量的值 o.func(); //err,不能调用同类的非常量成员函数 o.GetValue(); //ok,可以执行常量成员函数 return 0;&#125; 常量成员函数的重载两个成员函数，名字和参数表都一样，但是一个是const，一个不是，算重载，而不是重复定义。 12345678910111213141516171819202122class CTest&#123; private: int n; public: CTest() &#123; n = 1 ;&#125; int GetValue() const &#123; return n; &#125; int GetValue() &#123; return 2 * n; &#125; //这两个GetValue()函数是重载关系，而不是重复定义&#125;;int main()&#123; const CTest objTest1; CTest objTest2; cout &lt;&lt; objTest1.GetValue() &lt;&lt; ", " &lt;&lt; objTest2.GetValue(); //objTest1是常量对象，调用的是GetValue() const //objTest2是非常量对象，调用的是GetValue() return 0;&#125; 常引用引用前面可以加const关键字，成为常引用。不能通过常引用，修改其引用的变量。 123const int &amp;r = n;r = 5; //errorn = 4; //OK 对象作为函数的参数时，生成该参数需要调用复制构造函数，效率比较低。用指针作参数，代码又不好看，如何解决？可以用对象的引用作为参数。 12345678class Sample&#123; //... &#125;;void PrintfObj(Sample &amp;o)&#123; //...&#125; 但对象引用作为函数参数有一定风险性，若函数中不小心修改了形参o，则实参也跟着变，这不是我想要的。如何避免？使用常引用！ 12345678class Sample&#123; //... &#125;;void PrintfObj(const Sample &amp;o)&#123; //...&#125; 这样函数中就能确保不会出现无意中更改o值的语句了。 参考并整理自《C++面向对象设计》郭炜，北京大学，感谢原作者！编辑时有删改]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C-plus-plus</tag>
        <tag>OOP</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++复制构造函数]]></title>
    <url>%2FG-SS-Hacker.github.io%2FC-%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[C++复制构造函数 图：广州天河CBD Guderian出品 本文整理自《北京大学公开课：C++面向对象程序设计》 基本概念 只有一个参数，即对同类对象的引用 形如X::X(X &amp;)或X::X(const X &amp;)，二者选一，后者能以常量对象作为参数 如果没有定义复制构造函数，那么编译器生成默认的复制构造函数。默认的复制构造函数完成复制功能 构造函数与复制构造函数的异同 构造函数（或称无参构造函数）不一定存在，你不写构造函数，编译器就只会帮你生成一个什么也不做的无参构造函数 复制构造函数一定存在，你不写复制构造函数，编译器也会帮你写好一个具有复制功能的复制构造函数 12345678class Complex&#123; private: douebl real, imag;&#125;;Complex c1; //调用缺省的构造函数Complex c2(c1); //调用缺省的复制构造函数，将c2初始化成和c1一样 如果定义了自己的复制构造函数，则默认的复制构造函数不存在 12345678910111213141516class Complex&#123; public: double real, imag; Complex() &#123;&#125; Complex(const Complex &amp;c) &#123; real = c.real; imag = c.imag; cout &lt;&lt; "Copy constructor called"; &#125;&#125;;Complex c1;Complex c2(c1);//调用自己定义过的复制构造函数，输出Copy constructor called 特别强调1注意：不允许有形如X::X(X)的复制构造函数，参数一定是引用，不能是对象 12345678class CSample&#123; CSample(CSample c) &#123; //错，不允许出现这样的复制构造函数 //这样写的话，下面的内容要么变成了构造函数，要么语法是错误的 &#125;&#125;; 复制构造函数起作用的三种情况（1）当用一个对象去初始化同类的另一个对象时12Complex c2(c1);Complex c2 = c1; //初始化语句，非赋值语句，与上面写法是等价的 （2）当某函数有一个参数是类A的对象时那么该函数被调用时，类A的复制构造函数将被调用。C++规则：形参是实参的拷贝 123456789101112131415161718192021class A&#123; public: A() &#123;&#125;; A(A &amp;a) &#123; cout &lt;&lt; "Copy constructor called" &lt;&lt; endl; &#125;&#125;;void Func(A a1) &#123;&#125;int main()&#123; A a2; Func(a2); retrun 0;&#125;//输出：Copy constructor called （3）当函数的返回值是类A的对象时那么在函数返回时，A的复制构造函数被调用，作用是初始化作为返回值的类A对象 1234567891011121314151617181920212223242526272829class A&#123; public: int v; A(int n) &#123;v = n&#125;; A(const A &amp;a) &#123; v = a.v; cout &lt;&lt; "Copy constructor called" &lt;&lt; endl; &#125;&#125;;A.Func()&#123; A b(4); return b;&#125;int main()&#123; cout &lt;&lt; Func().v &lt;&lt; endl; //此处Func()的返回值没有名字，是一个复制构造函数初始化的对象 return 0;&#125;//输出：Copy constructor called4 特别强调2注意：对象间赋值并不导致复制构造函数被调用 123456789101112131415161718192021222324class CMyClass&#123; public: int n; CMyClass() &#123;&#125;; CMyClass(CMyClass &amp;c) &#123; n = 2 * c.n; &#125; //不推荐复制构造函数这样写，此处仅用于凸显调用复制构造函数与对象间赋值的区别&#125;;int main()&#123; CMyClass c1, c2; c1.n = 5; c2 = c1; //这是赋值语句 CMyClass c3(c1); //调用复制构造函数，c3并没有变得跟c1一样 cout &lt;&lt; c2.n &lt;&lt; ", "; cout &lt;&lt; c3.n &lt;&lt; endl; return 0;&#125;//输出：5, 10 定义函数时常量引用参数的使用1234void fun(CMyClass obj)&#123; cout &lt;&lt; "fun" &lt;&lt; endl;&#125; 这样的函数，调用时生成形参会引发复制构造函数调用，复制一遍时间开销比较大 所以可以考虑使用CMyClass &amp; 引用类型作为参数，本质上与实参是一样的 如果希望确保实参的值在函数中不应被改变，那么可以加上const关键字，这样的话如果你定义的函数中出现了改变实参的值得语句。编译器就会报错 我自己写的程序难道我自己不记得我没有改过参数吗？的确，你现在记得，明天也记得，但以后再改你的程序，就未必记得了。从代码规范的角度来讲，加上const关键字是必要的 1234void fun(const CMyClass &amp;obj)&#123; //如此一来，函数中任何试图改变obj值得语句都将是非法&#125; 思考：为什么要自己写复制构造函数？ 想通这个问题是高难度操作，作者水平有限，无法清晰地回答，仅提供参考链接。 前置知识： 深拷贝、浅拷贝 传值、传地址、传引用 参考链接： 为什么需要拷贝构造函数 c++的默认拷贝构造函数，从深度拷贝和浅拷贝说起 为什么要自己写构造函数和析构函数 使用缺省的拷贝构造函数带来的危险性 值传递 引用传递（传地址，传引用）的区别 参考并整理自《C++面向对象设计》郭炜，北京大学，感谢原作者！编辑时有删改]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C-plus-plus</tag>
        <tag>OOP</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++构造函数]]></title>
    <url>%2FG-SS-Hacker.github.io%2FC-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[C++ 构造参数 图：深圳福田CBD Guderian出品 本文整理自《北京大学公开课：C++面向对象程序设计》 构造函数的性质 构造参数是成员函数的一种 名字与类名相同，可以由参数，不能有返回值（void也不行） 作用是对对象进行初始化，如给成员变量赋初值 如果定义类的时候没写构造函数，则编译器生成一个默认的无参数的构造函数 默认构造函数无参数，不进行任何操作 如果定义了构造函数，则编译器不生成默认的无参数的构造函数 对象生成时构造函数被自动调用。对象一旦生成，就再也不能在其上执行构造函数 一个类可以有多个构造函数 注：如果只定义了带参构造函数，在定义对象时必须声明参数 为什么需要构造函数： 不用专门写初始化函数，也不用担心忘记 有时对象没有被初始化，会导致程序出错 构造函数的使用一个类可以有一个构造函数1234567891011121314151617181920class Circle&#123; private: double radius, xLoc, yLoc; public: Circle(double r ,double x = 0, y = 0)&#125;;Circle::Circle(double r, double x, double y)&#123; radius = r, xLoc = x, yLoc = y;&#125;//Wrong samplesCircle c1; //error,缺少构造函数的参数Circle *pc = new Circle; //error，没有参数//Correct samplesCircle c1(2); //OKCircle c1(2, 4, 4); //OKCircle *pc = new Circle(3, 4); //also OK 一个类可以有多个构造函数只要不同的构造函数的参数个数和参数类型不同，这些构造函数就会构成重载的关系 1234567891011121314151617181920212223242526class Circle&#123; private: double radius, xLoc, yLoc; public: Circle(double r ,double x = 0, y = 0) Circle(double r); Circle(Circle c1, Circle c2)&#125;;Circle::Circle(double r, double x, double y)&#123; radius = r, xLoc = x, yLoc = y;&#125;Circle::Circle(double r)&#123; radius = r;&#125;Circle::Circle(Circle c1, Circle c2)&#123; radius = c1.radius + c2.radius; xLoc = c1.xLOc + c2.xLoc; yLoc = c1.yLOc + c2.yLoc;&#125;//SamplesCircle c1(3), c2(1, 0), c3(c1, c2); 构造函数在数组的使用（1）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class CSample&#123; private: int x; public: CSample() &#123; cout &lt;&lt; "Constructor 1 Called" &lt;&lt; endl; &#125; CSample(int n) &#123; x = n; cout &lt;&lt; "Constructor 2 Called" &lt;&lt; endl; &#125;&#125;;int main()&#123; cout &lt;&lt; "step1" &lt;&lt; endl; CSample array1[2]; cout &lt;&lt; "step2" &lt;&lt; endl; CSample array2[2] = &#123;4, 5&#125;; cout &lt;&lt; "step3" &lt;&lt; endl; CSample array3[2] = &#123;3&#125;; cout &lt;&lt; "step4" &lt;&lt; endl; CSample *array4 = new CSample[2]; //随机生成两个元素的数组 delete []array4; //解除空间占用 return 0;&#125;//输出：step1//对两个对象初始化的参数没有作任何交代，编译器就认为这个对象就应该用无参的构造函数初始化Constructor 1 CalledConstructor 1 Calledstep2 //对两个对象初始化的参数都有交代Constructor 2 CalledConstructor 2 Calledstep3 //只对第一个对象初始化的参数作了交代Constructor 2 CalledConstructor 1 Calledstep4 //对两个对象初始化的参数没有作任何交代Constructor 1 CalledConstructor 1 Called 构造函数在数组的使用（2）1234567891011121314151617181920212223class Test&#123; public: Test(int n) &#123;&#125; //(1) Test(int n, int m) &#123;&#125; //(2) Test() &#123;&#125; //(3)&#125;;Test array1[3] = &#123;1, Test(1,2)&#125;;//三个元素分别用(1)，(2)，(3)初始化Test array2[3] = &#123;Test(2, 3), Test(1, 2), 1&#125;;//三个元素分别用(2)，(2)，(1)初始化Test *pArray1[3];//仅仅这么定义是不会导致对象生成的，不会引发Test的构造函数被调用。//*pArray1[3]仅仅是指针而已，不会产生任何对象Test *pArray2[3] = &#123;new Test(4), new Test(1, 2)&#125;;//对指针数组的前两个元素初始化，方法是new两个对象，返回值是指针，用new的两个对象的地址去初始化数组pArray2[3]的前两个元素。//注意这个语句只生成了两个对象，pArray2[2]还是一个指针，无从得知它的指针指向哪里，它的生成并不会导致任何对象的生成。//注意在使用中，指针数组与数组的区别 参考并整理自《C++面向对象程序设计》郭炜，北京大学，感谢原作者！编辑时有删改]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C-plus-plus</tag>
        <tag>OOP</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不定积分公式]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[不定积分公式 Guderian出品 $(1)\int0 \mathrm{dx} = C$ $(2)\int1\mathrm{dx}=x+C$ $(3)\int x^\mu \mathrm{dx}=\frac1{\mu+1}x^{\mu+1}+C(\mu \ne -1)$ $(4)\int\frac1{x}\mathrm{dx}=\ln|x|+C$ $(5)\int a^x \mathrm{dx}=\frac{a^x}{\ln a}+C$ $(6)\int e^x \mathrm{dx}=e^x+C$ $(7)\int \sin x \mathrm{dx}=-\cos x +C$ $(8)\int \cos x \mathrm{dx}=\sin x +C$ $(9)\int \sec^2 x \mathrm{dx}=\int \frac1{\cos^2 x}\mathrm{dx}=\tan x+C$ $(10)\int \csc^2x\mathrm{dx}=\int \frac1{\sin^2x}\mathrm{dx}=-\cot x +C$ $(11)\int\sec x\tan x\mathrm{dx}=\sec x+C$ $(12)\int \csc x\cot x\mathrm{dx}=-\csc x +C$ $(13)\int \frac{\mathrm{dx}}{\sqrt{1-x^2}}=\arcsin x+C$ $(14)\int \frac{\mathrm{dx}}{1+x^2}=\arctan x+C$ $(15)\int \tan x\mathrm{dx}=-\ln|\cos x|+C$ $(16)\int \cot x \mathrm{dx}=\ln|\sin x|+C$ $(17)\int \sec x \mathrm{dx}=\ln|\sec x+\tan x|+C$ $(18)\int \csc x\mathrm{dx}=\ln|\csc x -\cot x|+C$ $(19)\int \frac{\mathrm{dx}}{x^2+a^2}=\frac1{a}\arctan {\frac{x}{a}}+C$ $(20)\int \frac{\mathrm{dx}}{x^2-a^2}=\frac1{2a}\ln|\frac{x-a}{x+a}|+C$ $(21)\int \frac{\mathrm{dx}}{\sqrt{a^2-x^2}}=\arcsin \frac{x}{a}+C$ $(22)\int \frac{\mathrm{dx}}{\sqrt{x^2\pm a^2}}=\ln|x+\sqrt{x^2\pm a^2}|+C$ $(23)\int \sqrt{a^2-x^2}\mathrm{dx}=\frac{x}{2}\sqrt{a^2-x^2}+\frac{a^2}{2}\arcsin \frac{x}{a}+C$ $(24)\int \sqrt{x^2\pm a^2}\mathrm{dx}=\frac{x}{2}\sqrt{x^2\pm a^2}\pm \frac{a^2}{2}\ln|x+\sqrt{x^2\pm a^2}|+C$ $(25)\int \ln x\mathrm{dx}=x\ln x-x+C$ ~我们遇到什么困难也不要怕，微笑着面对它！消除恐惧的最好办法就是面对恐惧！坚持就是胜利！加油！奥利给！~ 【其他文章·微积分·线性代数】 不定积分公式 常用泰勒展开式 高阶求导公式 高等数学公式 常用等价无穷小 导数基本公式 矩阵章节总结 行列式章节总结 线性方程组章节总结]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性方程组章节总结]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E7%AB%A0%E8%8A%82%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[线性方程组章节总结 Guderian出品 线性方程组有解的充要条件 齐次线性方程组要么只有一组零解，要么有无穷多解 非齐次线性方程组有解的充要条件 $R(A)=R(A|\beta)$ 注：$R(A)$和$R(A|\beta)$要么相等，要么差$1$ 线性方程组解的结构 齐次线性方程组 (1) $AX=0$只有零解 $ \Leftrightarrow R(A)$等于未知数个数$\Leftrightarrow$A为列满秩阵 (2) $AX=0$有无穷多组解 $ \Leftrightarrow R(A)$小于未知数个数 非齐次线性方程组 (1) $AX=B$ 有唯一解 $\Leftrightarrow R(A)=R(A|\beta)=n$ (2) $AX=B$ 有无穷多组解 $\Leftrightarrow R(A)=R(A|\beta)&lt;n$ (3) $AX=B$ 无解 $\Leftrightarrow R(A) \ne R(A|\beta)$ 注：在非常严苛的条件下，以下两命题等价：$AX=B$ 有唯一解 $\Leftrightarrow $ $AX=0$只有零解（当$A$时方阵时成立） 线性方程组的解思想：利用矩阵初等行变换（高斯消元） 齐次线性方程组 记$N(A)$为齐次线性方程组的全体解向量所构成的向量空间，则$\dim N(A)=n-R(A)$，称$n(A)$的基为齐次线性方程组的基础解系： (1) 当$R(A)=n$时，齐次线性方程组只有零解，没有基础解系 (2) 当$R(A)&lt;n$时，基础解系为齐次线性方程组的$n-R(A)$个线性无关的解向量 非齐次线性方程组 $AX=B$ 和 $AX=0$的解向量满足： (1) 若$\eta_1$，$\eta_2$都是$AX=B$的解，那么$\eta_1 - \eta_2$是$AX=0$的解（几乎没用） (2) 若$\eta_1$是$AX=B$的解，$\eta_2$是$AX=0$的解，那么$\eta_1 + \eta_2$还是$AX=B$的解 ~我们遇到什么困难也不要怕，微笑着面对它！消除恐惧的最好办法就是面对恐惧！坚持就是胜利！加油！奥利给！~ 【其他文章·线性代数·微积分】 线性方程组章节总结 矩阵章节总结 行列式章节总结 常用泰勒展开式 高阶求导公式 高等数学公式 常用等价无穷小 导数基本公式 不定积分公式]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模式匹配算法：KMP算法]]></title>
    <url>%2FG-SS-Hacker.github.io%2FKMP%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[模式匹配算法：KMP算法 图：北京航空航天大学 Guderian出品 模式匹配是数据结构中字符串的一种基本运算，给定一个字符串P，要求在某个字符串T中找出与字符串P相同的所有子串，这就是模式匹配。 模式匹配算法要解决的问题 detection ：P是否出现 location ：首次在哪里出现 counting ：共有几次出现 enumeration ：各出现在哪里？ 绪论KMP算法（全称Knuth-Morris-Pratt算法）是一种高效的模式匹配算法。在模式匹配算法中，常见的算法包括BF算法（朴素算法）、KMP算法、BM算法、RK算法、有限自动机算法、Horspool算法、Sunday算法。在这些算法中，最经典的算法非KMP算法和BM算法莫属。这两种算法都有一个共同点：抽象，理解难度大。实际上，KMP算法还有一个明显特点：会者不难。本文内容默认你已经明白BF算法的原理和不足（因此这部分内容将简单略过），展开讲述KMP算法的原理、优点和c++代码实现。相信你在学会KMP算法之后将会有一种“踏遍青山人未老，这边风景独好”的快意。让我们开始吧。 BF算法BF算法的本质就是暴力搜索。既然要在串T中找出与串P相同的所有子串，那不妨找出串T中所有与串P长度相同的子串，在逐个判断这个子串是否与串P相同。具体的例子点击这里或者看下方的视频（讲得很形象了，应该不会有理解上的困难）。设strlen(T) == n, strlen(P) == m，则BF算法的预处理时间为$0$，匹配时间为$O(mn)$，总时间复杂度为$O(mn)$（简直是蜗速），在大部分应用场景中并不优秀。 KMP算法更高的效率容易看出BF算法的效率是十分蹩脚的，而它蹩脚的原因也很明显：在一次匹配尝试中，一旦失配（某一位匹配失败），就把串P整体向右移动一位。在模拟算法运行过程中，我们发现如果开始匹配时第一位就失配，那么只向右移动一位的确无可厚非，毕竟说不定移动一位之后就会匹配成功呢；但是如果已经匹配了串P的一部分了才失配，在向右移动一位之后，有时候（而且往往是经常）我们发现依然注定会匹配失败，也就是说在上次失败之后，向右移动一位再做尝试是根本不必要的，这种“只移动一位”的策略实际上造成了巨大的步骤浪费。那么有没有办法，把这些不必要的尝试舍弃，节约算法的运行时间呢？ 此处我们需要考虑以下问题，以便对BF算法做出有效的改进： 为什么有一些尝试是注定徒劳的？ 如何判断哪些尝试需要舍弃？ 如果不是向右移动一位，又应该如何确定向右移动的位数？ 在看完点击这里（还是上面那个链接）之后，前两个问题都能得到答案。在链接的视频讲解中，讲述者构造了一个前缀表数组prefix table来确定串P中每个从头开始的子串的最长公共前后缀（自身除外，以下省略此说明），一旦失配，就把串P向右移动到失配位置左侧子串的最长前缀处，使它们重叠，也就是把下图中的1号移动到2号位置，继续从当前位置匹配，如果当前位置为串T的结尾，则结束匹配。 那么问题来了：为什么要把最长公共前缀移动至最长公共后缀的位置？这个移动距离能不能更短？能不能更长？ **引理** 串的**最长公共前后缀**的**最长公共前后缀**是原串的**次长公共前后缀**。 **证明** 略~~（逃~~ 实际上，在BF算法的一次匹配过程中，一旦失配，就把串P整体向右移动一位再次尝试匹配。假设第一次匹配时在串P的第r + 1位失配，此时已经确定串P失配位置的前r项与串T相应位置元素匹配，也确定了串P失配位置的前r - 1项与串T相应位置元素匹配。那么第二次匹配成功，当且仅当在串P的前r项组成的子串中，前r - 1位字符组成的前缀和后r - 1位字符组成的后缀相同，即某一个公共前后缀长度为r - 1。也就是说，如果匹配失败向右移动s位，那么再次匹配成功的必要条件是串P在失配位置前的子串的某一个公共前后缀长度为r - s。如果串P在失配位置前的子串的最长公共前后缀长度就是r - s，匹配失败后向右移动了不足s位，这意味着移动距离过短，将会做一遍无用功。 如果移动距离过长，那就有可能会错过一个成功的匹配。如果匹配失败向右移动s位，那么再次匹配成功的必要条件是串P在失配位置前的子串的某一个公共前后缀长度为r - s。注意这里是必要条件而不是充分条件，在把串P向右移动的过程中，并不是在失配位置前随便放一个公共前后缀都能匹配成功，我们需要从最长公共前后缀开始尝试，逐步减少原失配位置前子串的长度，直到匹配成功或者串P在失配位置前子串最长公共前后缀长度变为0。 此处我们引入next[]数组来记录在失配时应该把串P的哪一位移动到当前位置。对于串P的第j + 1位的字符来说，next[j + 1]的意义是由串P的前j项的子串中最长公共前后缀的长度。next[]数组是KMP算法降低时间复杂度的关键，在预处理时就已经确定。下面介绍next[]数组求法。 next数组求法如果你直接跳过了前面看到了这里，那说明你已经看了无数多参考资料，还是搞不懂next[]数组求法的原理，几乎走投无路了。但是，正如B站鬼畜区某神所言： **我们遇到什么困难也不要怕，微笑着面对它！消除恐惧的最好办法就是面对恐惧！坚持就是胜利！加油！奥利给！** 回到正题。 先考虑求next[]数组的朴素算法：我们要求一个长度为l的串S的最长公共前后缀，因为自身除外，所以把串S复制一遍，产生一个串S&#39;，并让串S&#39;的第1位对齐串S的第2位，尝试匹配剩余l - 1位。若匹配成功，则剩余l - 1位就是串P的最长公共前后缀；若匹配失败，则把串S&#39;向右移动1位，再次尝试，知道匹配成功或串S&#39;已被移出串S的范围之内。 等一等，为什么这波操作如此熟悉？（战术后仰 是的，这就是所谓的“串P匹配自身”，有没有办法可以优化以上的朴素算法呢？ 我们的任务是求出串P每一个由前j项元素组成的子串的最长公共前后缀的长度。假设串P从字符串下标1开始存储，规定next[1] = 0，并从第2位开始匹配。设用串P&#39;匹配串P，当前匹配位置是串P&#39;的第j + 1位，串P的第i位，如果失配，那么处理方法同上面介绍的一样，把串P&#39;向右移动到失配位置左侧子串的最长前缀处，即令j = next[j]（思想：回溯），使它们重叠，即把下图中的1号移动到2号位置，继续从当前位置匹配；如果第j + 1位匹配成功，则更新串P前i位元素组成的子串的最长公共前后缀的长度为j，即令next[i] = j。 你已经明白了KMP算法的原理，那么不难推算出KMP算法的时间复杂度：预处理时间为$\Theta(m)$，匹配时间为$\Theta(n)$，总时间复杂度为$\Theta(m+n)$。与BF算法相比，KMP算法是一种优秀的模式匹配算法。 伪代码123456789101112131415161718192021222324252627282930KMP-MATCHER(T, P)n = T.lengthm = P.lengthnext = COMPUTE-PREFIX-FUNCTION(P)j = 0for i = 1 to n while j &gt; 0 and P[j + 1] != T[i] j = next[j] if P[j + 1] == T[j] j = j + 1 if j == m print "Pattern occurs with shift" i - m j = next[j] COMPUTE-PREFIX-FUNCTION(P)m = P.lengthlet next[1..m] be a new arraynext[1] = 0j = 0for i = 2 to m while j &gt; 0 and P[j + 1] != T[i] j = next[j] if P[j + 1] == T[j] j = j + 1 next[i] = jreturn next 例题：KMP算法模版题目描述输入两个字符串$s1$和$s2$（皆从下标为$1$处开始存储），$s2$为$s1$的子串，输出$s2$在$s1$中所有出现位置的下标。 输入格式第一行为$s1$，第二行为$s2$ 输出格式每行一个正整数表示s2在s1中出现的位置 输入样例12123456123123 输出样例1217 说明/提示 $s1$和$s2$的长度在$1000000$之内 运行速度不能太慢 解题方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//Presented by G-SS-Hacker//cc BY-NC-SA 4.0//Run on C++#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int MAXN = 1000000 + 100;const int MAXM = 1000000 + 100;//next,x0,x1,y0,y1,index cannot be named to variablesint nxt[MAXM]; //nxt[i]表示字串1到i最长公共前后缀的长度int len1, len2;char s1[MAXN], s2[MAXM];void pre()&#123; for(int j = 0, i = 2; i &lt;= len2; i++) &#123; while(j &amp;&amp; s2[i] != s2[j + 1]) j = nxt[j]; if(s2[i] == s2[j + 1]) j++; nxt[i] = j; &#125;&#125;void kmp()&#123; for(int j = 0, i = 1; i &lt;= len1; i++) &#123; while(j &amp;&amp; s1[i] != s2[j + 1]) j = nxt[j]; if(s1[i] == s2[j + 1]) j++; if(j == len2) cout &lt;&lt; i - len2 + 1 &lt;&lt; endl, j = nxt[j]; &#125;&#125;int main()&#123; cin &gt;&gt; s1 + 1 &gt;&gt; s2 + 1; len1 = strlen(s1 + 1); len2 = strlen(s2 + 1); pre(); kmp(); return 0;&#125; 结束语**我们遇到什么困难也不要怕，微笑着面对它！消除恐惧的最好办法就是面对恐惧！坚持就是胜利！加油！奥利给！** 【其他文章·数据结构】 拓扑排序 图的表示 数据结构绪论]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C-plus-plus</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用泰勒展开式]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E5%B8%B8%E7%94%A8%E6%B3%B0%E5%8B%92%E5%B1%95%E5%BC%80%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[常用泰勒展开 Guderian出品 $(1)e^x=1+x+\frac{x^2}{2!}+\dots +\frac{x^n}{n!}+\frac{e^{\theta x}}{(n+1)!}x^{n+1}$ $(2)\sin x=x-\frac{x^3}{3!}+\frac{x^5}{5!}-\dots+(-1)^m\frac{x^{2m+1}}{(2m+1)!}+(-1)^{m+1}\frac{\cos \theta x}{(2m+3!)}x^{2m+3}$ $(3)\cos x=1-\frac{x^2}{2!}+\frac{x^4}{4!}-\dots+(-1)^m\frac{x^{2m}}{(2m)!}+(-1)^{m+1}\frac{\cos \theta x}{(2m+2)!}x^{2m+2}$ $(4)\ln(1+x)=x-\frac{x^2}{2}+\frac{x^3}{3}-\dots+(-1)^{n-1}\frac{x^n}{n}+(-1)^n\frac{x^{n+1}}{(n+1)(1+\theta x)^{n+1}}$ $(5)(1+x)^\alpha=\sum_{k=0}^n C_\alpha^n x^n+C_\alpha^{n+1}x^{n+1}(1+\theta x)^{\alpha -n-1}$ ~我们遇到什么困难也不要怕，微笑着面对它！消除恐惧的最好办法就是面对恐惧！坚持就是胜利！加油！奥利给！~]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵章节总结]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E7%9F%A9%E9%98%B5%E7%AB%A0%E8%8A%82%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[矩阵章节总结 Guderian出品 矩阵（matrix）形式优美，应用广泛。但是笔者相当头痛矩阵问题。实际上，矩阵的计算绝对不能靠硬算（硬算的事交给Matlab就好了，实际上计算机做矩阵运算，为了避免数值不稳定问题，使用的是和人计算不同的算法），而是灵活变形后运用基本的计算公式；矩阵的证明则更离不开对公式及其推论的灵活运用。笔者从题海中抽象出矩阵计算的常用思想和性质。作者实属菜鸟，水平很菜，将就看看吧 ╮(╯_╰)╭ 运算律 $ {AB}= {BA}$时，矩阵运算满足交换律，故以下运算皆成立 $(\mathrm{i})( {A}\pm {B})^2= {A}^2 \pm 2 {AB} + {B}^2$ $(\mathrm{ii})( {A}+ {B})( {A}- {B})= {A}^2- {B}^2$ $(\mathrm{iii})( {AB})^2=( {BA})^2$ $ {A}^*， {A}’， {A}^{-1}$组合会产生十分令人头疼的问题，使用以下公式来缓解头疼 $(\mathrm{i})( {AB})’= {B}’ {A}’$ $(\mathrm{ii})( {AB})^{-1}= {B}^{-1} {A}^{-1}$ $(\mathrm{iii})( {A}^*)^{-1}=( {A}^{-1})^*$ 带系数的情况 $(\mathrm{i})|k {A}|=k^n| {A}|$ $(\mathrm{ii})(k {A})^{-1}=\frac1{k} {A}^{-1}$ $(\mathrm{iii})(k {A})’=k {A}’$ $(\mathrm{iv})\overline{k {A}}=\overline{k}\overline{ {A}}$ 共轭矩阵记住以下四个公式，以备突然考到 $(\mathrm{i})\overline{ {A}+ {B}}=\overline{ {A}}+\overline{ {B}}$ $(\mathrm{ii})\overline{k {A}}=\overline{k}\overline{ {A}}$ $(\mathrm{iii})\overline{ {AB}}=\overline{ {A}}\overline{ {B}}$ $(\mathrm{iv})|\overline{ {A}}|=\overline{| {A}|}$ 简单地记，凡是涉及共轭的题目，计算的时候看起来能取共轭的都取共轭 伴随矩阵 看到$ {A}^*$，以下公式至少用其一 $(\mathrm{i}) {A}^* {A}= {A} {A}^*=| {A}| {E}$ $(\mathrm{ii}) {A}^{-1}=\frac{ {A}^*}{| {A}|}$ $(\mathrm{iii})| {A}^*|=| {A}|^{n-1}$ $(\mathrm{iv})( {A}^*)^*=| {A}|^{n-2} {A}$ 伴随矩阵的特殊性质：极端的伴随矩阵 {R}({A}^*)=\begin{cases} n,\quad {R}({A})=n\\ 1,\quad {R}({A})=n-1\\ 0,\quad {R}({A})]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[行列式章节总结]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E8%A1%8C%E5%88%97%E5%BC%8F%E7%AB%A0%E8%8A%82%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[行列式章节总结 图：刺客伍六七 Guderian出品 行列式形式优美，应用广泛。但是笔者相当头痛行列式的计算问题和行列式等式的证明问题。为了让行列式计算与证明不那么难算，笔者从题海中抽象出行列式计算和证明的常用算法和性质。作者水平不高，将就看看吧 ╮(╯_╰)╭ 行列式计算公式1.行列式定义 \left|\begin{array}{cccc} a_{11} & a_{12} & \dots & a_{1n}\\ a_{21} & a_{22} & \dots & a_{2n}\\ \vdots & \vdots & & \vdots\\ a_{n1} & a_{n2} & \dots & a_{nn}\\ \end{array}\right| = \sum(-1)^{t(p_1p_2\dots p_n)}a_{p_11}a_{p_22}\dots a_{p_nn}特别地，对于二阶和三阶行列式，可直接用对角线法则求出结果。 2.行列式展开定理 引理 如果$n$阶行列式$D$中第$i$行（列）所有元素除$a_{ij}$外都是零，那么，$D$等于$a_{ij}$与它的代数余子式$A_{ij}$的乘积，即$D=a_{ij}A_{ij}$。 展开定理 行列式等于它的任一行（列）的各元素与其代数余子式的乘积之和，即 D=a_{i1}A_{i1}+a_{i2}A_{i2}+\dots a_{in}A_{in},\quad i=1,2,\dots,n;\\ D=a_{1j}A_{1j}+a_{2j}A_{2j}+\dots a_{nj}A_{nj},\quad j=1,2,\dots,n.推论 行列式$D$的任一行（列）元素与另一行（列）对应元素的代数余子式乘积之和等于$0$，即 a_{i1}A_{j1}+a_{i2}A_{j2}+\dots a_{in}A_{jn}=0,\quad i \ne j,\quad i,j=1,2,\dots ,n;\\ a_{1i}A_{1j}+a_{2i}A_{2j}+\dots a_{ni}A_{nj}=0,\quad i \ne j,\quad i,j=1,2,\dots ,n.行列式结果等于$0$的定理常用于填空题和判断题。 3.范德蒙定理 范德蒙定理的证明用到了第二数学归纳法，在行列式和矩阵中，任何看起来可以用数学归纳法证明的题目（甚至包括一部分计算题），都可以用数学归纳法来做。 D_n= \left|\begin{array}{cccc} 1 & 1 & \dots & 1\\ x_1 & x_2 & \dots & x_n\\ x_1^2& x_2^2& \dots & x_n^2\\ \vdots & \vdots & & \vdots\\ x_1^{n-1} & x_2^{n-1} & \dots & x_n^{n-1}\\ \end{array}\right| = \prod_{1\leq j]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高阶求导公式]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E9%AB%98%E9%98%B6%E6%B1%82%E5%AF%BC%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[高阶求导公式 Guderian出品 $ (1)(a^x)^{(n)}=a^x (\ln a)$ $ (2)(e^{ax})^{(n)} = a^n e ^{ax} $ $(3)(\sin x)^{(n)}=\sin(x+\frac {n\pi}2)$ $(4)(\cos x)^{(n)}=\cos(x+\frac{n\pi}2)$ $(5)(x^a)^{(n)}=a(a-1)\dots(a-n+1)x^{a-n},若n&gt;a，则导数等于零$ $(6)[\ln (x+a)]^{(n)}=(-1)^n \frac{(n-1)!}{(x+a)^n}，特别地，令a=0，(\ln x)^{(n)}=(-1)^n\frac{(n-1)!}{x^n}$ $(7)(\frac1{ax+b})^{(n)}=(-a)^{n} \frac{n!}{(ax+b)^{n+1}}，特别地，令a=1,(\frac1{x+b})=(-1)^n \frac{n!}{(x+b)^{n+1}}$ $(8)Leibniz公式：[f(x)g(x)]^{(n)}=\sum_{k=0}^n C_n^kf^{(k)}(x)g^{(n-k)}(x)，C_n^k=\frac{n!}{k!(n-k)!)}$ $(9)(f(x)\pm g(x))^{(n)}=f^{(n)}(x)+g^{(n)}(x)$ $(10)(af(x))^{(n)}=af^{(n)}(x)$]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拓扑排序]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[拓扑排序 图：索菲亚教堂 Guderian出品 拓扑是研究几何图形或空间在连续改变形状后还能保持不变的一些性质的一个学科。它只考虑物体间的位置关系而不考虑它们的形状和大小。 AOV网在工程领域，一个大规模工程常被拆分为多个子工程，这些子工程被称为活动（Activity），在有向图中以顶点（Vertex）表示活动，以有向边表示活动之间的先后关系，这样的有向图被称为AOV网（Activity On Vertex Network）。在AOV网中，如果出现了闭环，就意味着有若干个活动将被无限次重复，工程将永远无法完成；因此，一个具有实用价值的AOV网，必定是一个有向无环图（DAG，Directed Acyclic Graph）。 绪论对于一个有向无环图$G=(V,E)$，其拓扑排序是其上顶点的一个线性排序：对于有向边$(u,v)\in E$，顶点$u$在排序中在顶点$v$的前面（如果$G$包含环路，则不可能产生一个线性排序）。可以将$G$上各顶点在一条水平线上从左向右排开，且图的所有边的指向也都是从左向右。拓扑排序并未各顶点上的排序，而是各顶点逻辑上的排序，这种排序可能有不止一种。在工程上，常把一个大规模工程的各个子工程抽象为一个AOV网，用拓扑排序解决工程的调度问题。下面用一个示例说明拓扑排序的具体应用： 下图（a）表示的是某教授每天早上从起床后到上班前所发生的事情的AOV网。教授必须先完成某些活动，才能完成某些活动；而另一些活动则可以以任意次序完成。在图（a）中，有向边$(u,v)$表示的就是活动$u$必须在活动$v$前完成。图（b）将拓扑排序后的有向无环图在一条水平直线上展示出来。如图（b）所示，该有向无环图所有边的指向都是从左到右。 （a） （b） 拓扑排序算法1. 基于入度的拓扑排序基于入度的拓扑排序算法，又被称为Kahn算法。以下摘选维基百科上关于Kahn算法的伪代码： 12345678910111213141516//TOPOLOGICAL-SORT(G)L ← Empty list that will contain the sorted elementsS ← Set of all nodes with no incoming edgeswhile S is non-empty do remove a node u from S insert u into L for each node v with an edge e from u to v do remove edge e from the graph if v has no other incoming edges then insert v into Sif graph has edges then return error (graph has at least onecycle)else return L (a topologically sortedorder) Kahn算法的基本思想是“走一步，看一步”。从以上伪代码不难看出Kahn算法的步骤：先统计所有顶点的入度，再把入度为零的顶点从图中分离出来，先放在集合$S$中，再从集合$S$中分别取出顶点放入线性表$L$中，然后把这个顶点指向的所有顶点的入度减1，并删除该顶点及所有与其相连的边。重复上述操作，直到所有顶点都被分离出来。若当集合$S$为空集时，线性表$L$中元素个数等于原来图中顶点的个数，则返回$L$，$L$中元素的排列即为该图的一种拓扑排序；若当集合$S$为空集时，线性表$L$中元素个数不等于原来图中顶点的个数，则意味着图中有闭环，返回错误信息，对图进行修改后再进行下一次拓扑排序。 对于图（a）的例子，首先我们找到入度为零的顶点有“刷牙”和“喂猫”，则把这两个顶点放入集合$S$中，$S=\{“刷牙”, “喂猫”\}$，$L=\varnothing$。 第一步、在$S$中选取”刷牙“并把该顶点从$S$中删除并放入线性表$L$中，”刷牙“与”洗脸“相连，删除相连的边，”洗脸“的入度减1，新的入度为0，把”洗脸“也放入$S$中。此时$S=\{“洗脸”, “喂猫”\}$，$L=“刷牙”$。 第二步、在$S$中选取“洗脸”并把该顶点从$S$中删除并放入线性表$L$中，“洗脸”与“吃饭”“更衣”相连，删除相连的边，”吃饭““更衣”的入度减1，新的入度为0，把”吃饭“”更衣“也放入$S$中。此时$S=\{“吃饭”, “更衣”, “喂猫”\}$，$L=“刷牙”\to“洗脸”$。 以此类推，第三步到第五步的结果分别如图（3）（4）（5）所示（第六步时$G=\varnothing$），采用同样的步骤，直至$S=\varnothing$，算法结束。 （3） （4） （5） 2. 基于深度优先搜索的拓扑排序基于深度优先搜索的拓扑排序算法同样见以下维基百科上关于该算法的伪代码： 1234567891011121314//TOPOLOGICAL-SORT(G)L ← Empty list that will contain the sorted nodesS ← Set of all nodes with no outgoing edgesfor each node v in S do visit(v) function visit(node v) if v has not been visited yet then mark v as visited for each node u with an edge from u to v do visit(u) add v to L 这个算法的过程非常直观：先把出度为零的顶点从图中分离出来，放在集合$S$中，再从集合$S$中分别取出顶点，递归访问其父顶点，若该顶点未被访问，则标记为“已访问”；到达递归基础后，将当前顶点放入线性表$L$中，并逐步回溯。 下证基于DFS的拓扑排序算法生成的是有向无环图的拓扑排序： 在有向无环图$G=(V,E)$上运行DFS，只需证明对于任意一对顶点$(u,v)\in E$，$u$的返回在$v$之前即可。 对边$(u,v)\in E $，在调用DFS(v)时，对于即将访问的$u$，不外乎以下两种情况： DFS(u)未被调用，即$u$未被mark，在当前路搜索路径的DFS树上，$u$是$v$的子节点。 DFS(u)已被调用，即$u$已被mark，则可知DFS(u)在另一条已经完成的搜索路径上返回。 对于这两种情况，$u$的返回都在$v$之前，得证。 例题：任务排序问题题目描述假定你需完成$n$项任务，这些任务之间并非独立，一项任务的执行当且仅当其所有前置任务已经被全部完成。 输入格式输入的数据包含若干组样例，每个样例的第一行包括两个整数$n$和$m$。$n$是任务的数量，$m$是任务之间先后关系的数量。接下来有$m$行，每行有两个整数$i$和$j$，表示任务$i$的执行必须在任务$j$之前。 输入结束的标志是一组$n=m=0$的样例。 输出格式对于每一组样例，在一行内输出$n$个整数，每两个整数之间用一个空格隔开，每一行数据表示一种可行的任务排序方案。 输入样例1234565 41 22 31 31 50 0 输出样例11 4 2 5 3 说明/提示$1 \leq n \leq 100$ 解题方法解法一、Kahn算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//Run on C++#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int MAXN = 110, MAXM = 110 * 110 / 2;struct edge&#123; int v, nxt;&#125;E[MAXM];queue &lt;int&gt; q;int n, m, cnt;int head[MAXN], in[MAXN];void addedge(int u, int v)&#123; E[++cnt].v = v; E[cnt].nxt = head[u]; head[u] = cnt;&#125;void init()&#123; cnt = 0; memset(head, 0, sizeof(head)); memset(E, 0, sizeof(E));&#125; int main()&#123; cin &gt;&gt; n &gt;&gt; m; while(n || m) &#123; init(); for(int i = 1; i &lt;= m; i++) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; addedge(u, v); in[v]++; &#125; for(int i = 1; i &lt;= n; i++) if(!in[i]) q.push(i); while(!q.empty()) &#123; int cur = q.front(); q.pop(); cout &lt;&lt; cur &lt;&lt; " "; for(int i = head[cur]; i; i = E[i].nxt) if(!--in[E[i].v]) q.push(E[i].v); &#125; cout &lt;&lt; endl; cin &gt;&gt; n &gt;&gt; m; &#125; return 0;&#125; 解法二、DFS1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//Run on C++#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int MAXN = 110, MAXM = 110 * 110 / 2;struct edge&#123; int u, nxt;&#125;E[MAXM];queue &lt;int&gt; q;int n, m, cnt;int head[MAXN], out[MAXN];bool flag[MAXN];void addedge(int u, int v)&#123; E[++cnt].u = u; E[cnt].nxt = head[v]; head[v] = cnt;&#125;void init()&#123; cnt = 0; memset(head, 0, sizeof(head)); memset(E, 0, sizeof(E)); memset(out, 0, sizeof(out)); memset(flag, 0, sizeof(flag));&#125; void dfs(int V)&#123; if(!flag[V]) &#123; flag[V] = true; for(int i = head[V]; i; i = E[i].nxt) dfs(E[i].u); cout &lt;&lt; V &lt;&lt; " "; &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; while(n || m) &#123; init(); for(int i = 1; i &lt;= m; i++) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; addedge(u, v); out[u]++; &#125; for(int i = 1; i &lt;= n; i++) if(!out[i]) q.push(i); while(!q.empty()) &#123; dfs(q.front()); q.pop(); &#125; cout &lt;&lt; endl; cin &gt;&gt; n &gt;&gt; m; &#125; return 0;&#125;]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C-plus-plus</tag>
        <tag>数据结构</tag>
        <tag>排序</tag>
        <tag>算法</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高等数学公式]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[高等数学公式 Guderian出品 立方公式1.立方和公式$a^3+b^3=(a+b)(a^2-ab+b^2)$ 2.立方差公式$a^3-b^3=(a-b)(a^2+ab+b^2)$ 3.三项立方和公式$a^3+b^3+c^3-abc=(a+b+c)(a^2+b^2+c^2-ab-bc-ac)$ 4.完全立方和公式$(a+b)^3=a^3+3a^2b+3ab^2+b^3$ $(a-b)^3=a^3-3a^2b+3ab^2-b^3$ 5.立方和累加$1^3+2^3+\ldots +n^3=[\frac{n(n+1)}{2}]^2=(1+2+\ldots+n)^2$ 和差化积公式$\sin \alpha+\sin \beta=2\sin \frac{\alpha+ \beta}{2} \cos \frac{\alpha- \beta}{2}$ $\sin \alpha-\sin\beta=2\cos \frac{\alpha+ \beta}{2}\sin \frac{\alpha- \beta}{2}$ $\cos \alpha+\cos \beta=2\cos \frac{\alpha + \beta}{2}\cos \frac{\alpha- \beta}{2}$ $\cos \alpha - \cos \beta=-2\sin \frac{\alpha+ \beta}{2}\sin \frac{\alpha- \beta}{2}$ 积化和差公式$\sin \alpha \sin \beta=\frac12[\sin(\alpha + \beta)+\sin(\alpha - \beta)]$ $\sin \alpha \cos \beta=\frac12[\sin(\alpha + \beta)-\sin(\alpha - \beta)]$ $\cos \alpha \sin \beta=\frac12[\cos(\alpha + \beta)+\cos(\alpha - \beta)]$ $\cos \alpha \cos \beta=\frac12[cos(\alpha + \beta)-cos(\alpha - \beta)]$ 万能公式$\sin \theta=\frac{2\tan \frac{\theta}{2}}{1+\tan^2\frac{\theta}{2}}$ $\cos \theta=\frac{1-\tan^2\frac{\theta}{2}}{1+\tan^2\frac{\theta}{2}}$ $\tan \theta=\frac{2\tan \frac{\theta}{2}}{1-\tan^2 \frac{\theta}{2}}$ ​ 平方和拓展$1^2+2^2+\ldots+n^2=\frac1{6}n(n+1)(2n+1)$ $1\times2+2\times3+\ldots+n(n+1)=n(n+1)(n+2)$ 裂项相消$\frac1{n(n+1)(n+2)}=\frac12[\frac1{n(n+1)}-\frac1{(n+1)(n+2)}]$]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用等价无穷小]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E5%B8%B8%E7%94%A8%E7%AD%89%E4%BB%B7%E6%97%A0%E7%A9%B7%E5%B0%8F%2F</url>
    <content type="text"><![CDATA[常用等价无穷小 Guderian出品 基础版当$x\to0$时， $(1)\sin x \sim x$ $(2)\tan x \sim x$ $(3)\arcsin x \sim x$ $(4)\arctan x \sim x$ $(5)1-\cos x \sim \frac12 x^2$ $(6)a^x-1 \sim x \ln a$ $(7)e^x-1 \sim x$ $(8)(1+x)^a-1 \sim ax$ * $(9)\ln (1+x) \sim x$ $(10)\sqrt{1+x}-1 \sim \frac12x$ 进阶版当$x\to0$时， $(11)\log_a(1+x) \sim \frac{x}{\ln a}$ $(12)\sqrt[n]{1+x}-1\sim \frac{x}{n}$ $(13)x-\sin x\sim \frac16x^3$ $(14)\tan x-x\sim\frac13x^3$ $(15)\arcsin x-x\sim\frac16x^3$ $(16)x-\arctan x\sim \frac13x^3$ $(17)\tan x-\sin x\sim \frac12x^3$ *. 见Bernoulli不等式：$(1+x)^n \ge 1+nx$ &#8617;]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[导数基本公式]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E5%AF%BC%E6%95%B0%E5%9F%BA%E6%9C%AC%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[导数基本公式 Guderian出品 $(1)(C)’ = 0$ $(2)(x^a)’=ax^{a-1}$ $(3)(a^x)’=a^x\ln a (a&gt;0且a\not=1)$ $(4)(e^x)’=e^x$ $(5)(\log_ax)’=\frac{1}{x\ln a}(a&gt;0且a\not=1)$ $(6)(\ln x)’=\frac1{x}$ $(7)(\sin x)’=\cos x$ $(8)(\cos x)’=-\sin x$ $(9)(\tan x)’=\frac1{\cos^2x}=\sec^2x$ $(10)(\cot x)’=\frac1{-\sin^x}=-\csc^2x$ $(11)(\sec x)’=\sec x\tan x$ $(12)(\csc x)’=-\csc x\cot x$ $(13)(\arcsin x)’=\frac1{\sqrt{1-x^2}}$ $(14)(\arccos x)’=-\frac1{\sqrt{1-x^2}}$ $(15)(\arctan x)’=\frac1{1+x^2}$ $(16)(\mathrm{arccot} x)’=-\frac1{1+x^2}$]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图的表示]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[图的表示 Guderian出品 绪论对于图 $G=(V,E)$ 1，可以用多种表示方法来表示，其中不同的表示方法分别适用与不同特点的图和对图进行不同的操作。在此介绍三种图的表示方法：邻接表、邻接矩阵和边集数组，并将呈现三种存图方法的C和C++代码实现。 存图方法1.邻接矩阵邻接矩阵是一种简单、易用但有较大局限性的存图方式。由于图是由点集和边集两部分组成，难以找到一种线性结构来同时表示两者，那么，由于每条特定的边都可由其两端顶点唯一确定（假设无重边），我们很自然地可以想到使用一个$|V|$ $*$ $|V|$的方矩阵$A = (a_{ij})$来表示，对于无权图，该矩阵满足： a_{ij} = \left\{ \begin{array}{} 1, \ (i, j) \in E\\ 0, \ (i, j) \notin E \end{array} \right.对于带权图，该矩阵满足： a_{ij} = \left\{ \begin{array}{} w, \ (i, j) \in E\\ \infty \ or \ 0\ or-1, \ (i, j) \notin E \end{array} \right. 【例1】 无向带权图示例如下图所示： 上图对应的邻接矩阵表示如图： \mathbf{A} =\left( \begin{array}{ccc}a_{11} & a_{12} & a_{13} & a_{14} \\\\a_{21} & a_{22} & a_{23} & a_{24} \\\\a_{31} & a_{32} & a_{33} & a_{34} \\\\a_{41} & a_{42} & a_{43} & a_{44}\end{array} \right)\mathbf{} =\left( \begin{array}{ccc}\infty & 4 & 5 & 7 \\\\4 & \infty & 2 & 2 \\\\5 & 2 & \infty & 3 \\\\7 & 2 & 3 & \infty\end{array} \right) 123456789//Run on C/C++const int n = 4; //n个顶点const int inf = 0x3f3f3f3f; //正无穷int G[n][n] = &#123; &#123;inf, 4, 5, 7&#125;, &#123;4, inf, 2, 2&#125;, &#123;5, 2, inf, 3&#125;, &#123;7, 2, 3, inf&#125;&#125;; 【例2】 有向带权图示例如下图所示： 上图对应的邻接矩阵表示如图： \mathbf{A} =\left( \begin{array}{ccc}a_{11} & a_{12} & a_{13} & a_{14} \\\\a_{21} & a_{22} & a_{23} & a_{24} \\\\a_{31} & a_{32} & a_{33} & a_{34} \\\\a_{41} & a_{42} & a_{43} & a_{44}\end{array} \right)\mathbf{} =\left( \begin{array}{ccc}\infty & 4 & 5 & 7 \\\\0 & \infty & 2 & 2 \\\\0 & 0 & \infty & 3 \\\\0 & 0 & 0 & \infty\end{array} \right) 123456789//Run on C/C++const int n = 4; //n个顶点const int inf = 0x3f3f3f3f; //正无穷int G[n][n] = &#123; &#123;inf, 4, 5, 7&#125;, &#123;0, inf, 2, 2&#125;, &#123;0, 0, inf, 3&#125;, &#123;0, 0, 0, inf&#125;&#125;; 【例1】【例2】分别给出了无向无权图和有向无权图的邻接矩阵表示，不管一个图有多少条边，邻接矩阵的空间复杂度都为$O(V^2)$。 不难看出，无向图的邻接矩阵是一个对称矩阵。由于在无向图中，边$(u,v)$与边$(v,u)$表示同一条边，无向图的邻接矩阵$A$就是自己的转置，即$A = A^T$。在存储时，可以只存放主对角线及其以上的这部分邻接矩阵（即半个矩阵），从而将图存储空间需求减少几乎一半。 邻接矩阵表示简单、容易理解，对已知的边操作的效率高（插入、删除、查询的时间复杂度都是$O(1)$。但是邻接矩阵的缺陷在于其空间复杂度巨大，在稠密图上邻接矩阵可以取得较好的利用率，但是在稀疏图 2上使用邻接矩阵将会造成大量内存空间的浪费，很容易导致内存溢出。因此，在使用邻接矩阵存图时一定要格外注意内存空间的限制，不可盲目追求简单而忽略了内存空间的优化。 2.邻接表邻接表是一种具有高度鲁棒性 3、适用于大多数情况的存图方法。对于图$ G = (V,E)$，其邻接表表示由一个包含$|V|$条链表的数组Adj[] 4所构成，每个顶点有一条链表。对于每个顶点$u\in V$，邻接表Adj[u]包含所有与顶点$u$之间有边相连的顶点$v$，即Adj[u]包含图$G$中所有与$u$邻接的顶点。邻接表本质上是使用链表存边，一条链表代表着一个点发出的所有边，通过链表存储和遍历和一个顶点相连的所有边，并根据实际应用情况选择是否存储边权。在C/C++中，实现邻接表的方法主要有两种：链式向前星和vector存图。 【例3】 有向带权图示例如下图所示： 上图对应的邻接表表示如图： 链式向前星存图法是利用了一种特殊的链表，这种链表具有普通链表链式存储的特征，但其插入新元素的方式却是“向前星”，即从链表表头插入元素，每次只更新表头，因此得名链式向前星。在使用链式向前星时，应很好的理解这种数据结构与普通链表的区别。 123456789101112131415161718192021222324252627282930313233//链式向前星//Run on C/C++#include&lt;iostream&gt;using namespace std;const int n = 4, m = 6; //n个顶点，m条边struct edge&#123; int w, v, nxt; //nxt指向同一个顶点发出的另一条边&#125;E[n];int cnt = 0;int head[m]; //假设从0号顶点开始存储void add(int u, int v, int w) //改变编号为cnt的边&#123; E[++cnt].v = v; //出边指向v E[cnt].w = w; //记录边权 E[cnt].nxt = head[u]; //将其指向目前链表的表头（重要！） head[u] = cnt; //将表头更新为目前的编号（重要！）&#125;int main()&#123; add(1, 2, 4); add(1, 4, 7); add(1, 3, 5); add(3, 4, 3); add(3, 2, 2); add(2, 4, 2); return 0;&#125; vector存图实际上是利用了一个不定长的链表该存储从一个顶点出发的所有边的情况，与普通链表类似，vector也是从链表的尾端进行插入操作，因此vector存图法在理解难度上比链式向前星要简单。然而由于C/C++语言的原因，使用vector存图实际使用的内存比链式向前星的要大，因此内存溢出的风险也会更大。 123456789101112131415161718192021222324252627282930//vector存图，使用stl::pair版//Run on C/C++#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int n = 4; //n个顶点vector&lt;pair&lt;int, int&gt;&gt; E[n + 1]; //int（first）为u，int（second）为vvoid add(int u, int v, int w)&#123; E[u].push_back(&#123;v, w&#125;);&#125;int main()&#123; add(1, 2, 4); add(1, 4, 7); add(1, 3, 5); add(3, 4, 3); add(3, 2, 2); add(2, 4, 2); for(int i = 1; i &lt;= n; i++) for(int j = 0; j &lt;(int)E[i].size(); j++) cout&lt;&lt;i&lt;&lt;" "&lt;&lt;E[i][j].first&lt;&lt;" "&lt;&lt;E[i][j].second&lt;&lt;endl; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435//vector存图，使用结构体版//Run on C/C++#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int n = 4; //n个顶点struct edge&#123; int v, w;&#125;;vector&lt;edge&gt;E[n + 1];void add(int u, int v, int w)&#123; E[u].push_back(&#123;v, w&#125;);&#125;int main()&#123; add(1, 2, 4); add(1, 4, 7); add(1, 3, 5); add(3, 4, 3); add(3, 2, 2); add(2, 4, 2); for(int i = 1; i &lt;= n; i++) for(int j = 0; j &lt;(int)E[i].size(); j++) cout&lt;&lt;i&lt;&lt;" "&lt;&lt;E[i][j].v&lt;&lt;" "&lt;&lt;E[i][j].w&lt;&lt;endl; return 0;&#125; 不管是用链式向前星存图还是vector存图，邻接表的空间复杂度都为$O(E + V)$。与邻接矩阵相比，邻接表的空间复杂度更小，空间利用率更高。但是邻接表使用链式结构存储边，这导致了对边操作的时间复杂度为$O(n)$，因此邻接表并不适用于需要频繁对边操作的情况；对于稠密图，邻接表的性能也不比邻接矩阵更占上风。然而，对于不需要频繁对边进行操作的稀疏图，使用邻接表存图比使用邻接矩阵存图可以期待更高的效率。综上，邻接表不失为一种性能优秀的存图方法。 3.边集数组边集数组也是一种简单、易用但有较大局限性的存图方式。边集数组由一个一维结构体数组e[]构成，数组的每个数据元素由一条边的起点下标（u），终点下标（v）和权值（w）组成，如下图所示。不难看出，边集数组关注边的集合，而不关注点的集合。因此，使用这种存图方法在需要遍历图的边集时可以获得很高的效率，但是在遍历图的点集时效率简直是灾难。不论一个图有多少个顶点，边集数组的空间复杂度都为$O(E)$。 【例4】 有向带权图示例如下图所示： 上图对应的边集数组如下表所示： u v w e[1] 1 2 4 e[2] 1 4 7 e[3] 1 3 5 e[4] 3 4 3 e[5] 3 2 2 e[6] 2 4 2 12345678910111213141516//Run on C/C++const int m = 6; //m条边struct edge&#123; int u, v, w;&#125;;edge E[m] = &#123; &#123;1, 2, 4&#125;, &#123;1, 4, 7&#125;, &#123;1, 3, 5&#125;, &#123;3, 4, 3&#125;, &#123;3, 2, 2&#125;, &#123;2, 4, 2&#125;&#125;; 据观察，这种存图方法主要用于实现最小生成树的Krusal算法，其他情况下较少使用。 1. 图，graph，记为“G”；顶点，vertex，记为“V”；边，edge，记为“E”。 &#8617; 2. 稠密图与稀疏图的判断标准：(1)定性分析：稠密图的边数非常接近于完全图（即$n(n-1)$），而稀疏图的边数比完全图少得多。(2)定量分析：边数多于$nlogn$的图为稠密图，边数少于$nlogn$的图为稀疏图。 &#8617; 3. 鲁棒性，robust，即健壮性 &#8617; 4. 邻接表，adjlist，记为”Adj” &#8617;]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C-plus-plus</tag>
        <tag>C</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法性能比较]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[排序算法性能比较 Guderian出品 .tg {border-collapse:collapse;border-spacing:0;}.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg .tg-cly1{text-align:left;vertical-align:middle}.tg .tg-0lax{text-align:left;vertical-align:top} 类别 排序方法 时间复杂度 空间复杂度 稳定性 平均情况 最坏情况 插入排序 直接插入 O(n2) O(n2) O(1) 稳定 希尔排序 O(n1.3) O(n2) O(1） 不稳定 选择排序 直接选择 O(n2) O(n2) O(1) 不稳定 堆排序 O(nlogn) O(nlogn) O(1) 不稳定 交换排序 冒泡排序 O(n2) O(n2) O(1) 稳定 快速排序 O(nlogn) O(n2) O(logn) 不稳定 归并排序 O(nlogn) O(nlogn) O(n) 稳定 基数排序 O(d(r+n)) O(d(r+n)) O(r+n) 稳定 桶排序 O(2(m+n)) O(2(m+n)) O(max{key}) 稳定 *注：基数排序中，d表示关键字的位数长度，r表示关键字每一个数位有r中可能的取值 **注：桶排序中，m表示桶的个数]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加密算法]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[加密算法 Guderian出品 加密算法的历史加密算法是一种古老的算法，在人类几千年来的历史进程中，加密算法随着一场场战争的爆发而不断进步，从古罗马时代到第二次世界大战，从凯撒密码到恩尼格玛密码。然而，就像矛和盾的关系一样，加密技术和解密技术也在不断螺旋式发展。下面，笔者将向读者朋友们介绍一种古老的科技：凯撒密码。 在战争中，命令的传递往往需要通过传令兵。如： 后方指挥部 ———传令兵携带命令“攻打X城”———>我方部队可是，一旦传令兵被敌方抓获，重要的军事情报就会泄露给敌方。 后方指挥部—命令“攻打X城”—>敌方部队甚至，敌人可能会篡改命令，并收买传令兵把假情报传给我方部队。 后方指挥部—命令“攻打X城”—>敌方部队—命令“攻打Y城”—>我方部队这样一来，我方部队就会完全落入敌方陷阱中。为了防止这种情况发生，在没有更好的传达命令的方法的情况下，我们不妨修改命令的内容，让敌人即使截获了命令，也无法看懂命令的内容，这就是对信息的加密。 后方指挥部—命令“@#￥！！”—>敌方部队：？？？如何进行加密呢？有一种非常朴素的加密方法叫凯撒密码，它的基本思路就是偏移。 如图所示，图中第一行的字母代表明文，第二行字母代表密文。这个加密算法十分简单，选择一个偏移量，此处是3，把明文当中的所有字母按照字母表的顺序向后偏移三位，从而生成密文。比如： 1234A - &gt; DB - &gt; EC - &gt; FLOL - &gt; MPM 这样一来，就算我军的密码被敌军截获，敌军也无法看懂。一旦我方部队收到了我方的命令，只要逆转原来加密的过程，把密文以偏移量3往左偏移解密为明文，就可以正确收到我方的命令。假设敌军已知我方的加密算法，想要破解，把26个字母都试一遍，终究可以得到正确的原文，这就叫暴力破解。 现代加密算法1.对称加密算法明文--密钥-->密文--密钥-->明文这很好理解，这就好比给你需要传递的信息加上一把锁，这把锁的钥匙只有你和信息接收方拥有，这样就算信息被截获，也只能看出一堆乱码。只要传递方与接收方事先得到一致的密钥，双方就可以安全进行信息往来。 常见的对称加密算法有DES算法和3DES算法，它的基本方法是替换+移位；还有美国联邦政府采用的AES算法；还有RC-5算法和IDEA算法。office Word、Excel、Powerful、pdf、WinRAR的加密算法都属于对称加密算法。 对称加密算法的优点是简单高效，然而缺点却也很明显，那就是安全性低。比如下面这种情况： 你想要给某人通过QQ发送一个加了密的word文档，你发过去了但你的小伙伴打不开，那他当然会向你要密码。为了让他能顺利打开这个文档，你又要给他发送文档的密码。这样一来，你的文档就没有任何安全性可言了。如果你的文档被不怀好意的人截获，那他当然也能截获你的密码。 为了解决对称加密算法安全性低的问题，科学家发明了非对称加密算法。 2. 非对称加密算法明文--公钥-->密文--私钥-->明文 明文--私钥-->密文--公钥-->明文在非对称加密算法中有一对密钥，其中一个叫公钥、另一个叫私钥。如果要加密一个文档，我们既可以用公钥加密文档，用私钥解密文档；也可以用私钥加密文档，用公钥解密文档。最常见的非对称加密算法就是大名鼎鼎的RSA算法，几乎无法破解。 非对称加密算法的缺点是效率低下，然而其优点是安全性极高，解决了对称加密算法的安全性低的问题。比如下面这种情况： 在一间公司中，每一个员工都有自己的一对公钥和私钥，公钥可以交给他人，但是私钥只有自己知道。员工之一的你想要给同样为员工的某人通过QQ发送一个文档，你只需要向接受者索要他的公钥，他就会光明正大地通过QQ发给你，你再利用他的公钥给文档加密，然后光明正大地通过QQ发给他，他接收到你发送的已用他的公钥加密过的文档之后，就可以用他的私钥解密，从而顺利的查看文档了。在这个过程中，就算文档和公钥都被截获，因为没有相应的私钥，也无法正常还原。因此，这个非对称加密算法的安全性比对称加密算法提高了一个等级。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>网络与信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OSI/RM七层模型]]></title>
    <url>%2FG-SS-Hacker.github.io%2FOSIRM%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[OSI/RM = Open System Interconnection Reference Model 计算机网络：OSI/RM七层模型 Guderian出品 在计算机网络建立之初，各大计算机企业之间并没有一套通用的标准来规范计算机网络的建设，相反，各企业在自己的计算机系统上实行自己的标准，这就造成了一种局面：不同品牌计算机之间不能实现互连。要知道互联网建立之初的目的就是让把全世界的计算机连接起来，实现信息共享。这个目标在今天已经基本实现，然而在上个世纪七八十年代，苹果的计算机和IBM的计算机的网路接口都不一样，更不用说两者互连了。这种情况在不同品牌 的计算机之间比比皆是，制约了世界互联网的发展，同时也制约了互联网市场规模的增长。 此时，各计算机企业需要一套公用的标准来规范计算机网络的建设。然而，每一家企业都希望推行自己的标准，不愿意使用别人的标准。正如现在我们所说：“一流的公司定标准。”当别人制定好了标准，你再依据这个标准开发产品的时候，实际上你已经比别人落后了，也就是说标准制定者永远站在领先的位置。各计算机企业争执不下，标准的制定再次陷入僵局。 既然各计算机企业都不愿意放弃自己的标准，使用别人的标准，那么有人提议，我们全部放弃自己的标准，由国际标准化组织（nternational Organization for Standardization, ISO)来制定一套标准，我们就全部采用那套标准。这一提议得到了计算机企业的广泛认可。于是ISO就制定了开放系统互连(OSI)模型，并由全世界的计算机企业以此为标准开发和建立计算机网络。虽然从今天的角度看，这套标准有些繁琐，层次显得太多，但是因为这套标准已经被遵循多年，所以被一直延续了下来，未曾改变。 OSI/RM七层模型 .tg {border-collapse:collapse;border-spacing:0;}.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top} 层次 名称 主要功能 主要设备及协议 7 应用层 实现具体的应用功能 POP3、FTP、HTTP、Telnet、SMTPDHCP、TFTP、SNMP、DNS 6 表示层 数据的格式与表达、加密、压缩 5 会话层 建立、管理和终止对话 4 传输层 端到端的连接 TCP、UDP 3 网络层 分组传输和路由选择 三层交换机、路由器ARP、RARP、IP、ICMP、IGMP 2 数据链路层 传输以帧为单位的信息 网桥、交换机、网卡PPTP、L2TP、SLIP、PPP 1 物理层 二进制传输 中继器、集线器]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows10常用快捷键]]></title>
    <url>%2FG-SS-Hacker.github.io%2FWindows10%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[Life is short, you need shortcuts Windows 10常用快捷键 Guderian出品 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647Windows 徽标键 + I —&gt; 打开“设置”Windows 徽标键 + E —&gt; 打开“文件资源管理器”Windows 徽标键 + D —&gt; 显示和隐藏桌面Windows 徽标键 + L —&gt; 锁定电脑Windows 徽标键 + M —&gt; 最小化所有窗口Windows 徽标键 + R —&gt; 打开“运行”对话框Windows 徽标键 + 逗号 (,) —&gt; 临时快速查看桌面Windows 徽标键 + 数字 —&gt; 打开桌面，并启动固定到任务栏的位于该数字所表示位置的应用。如果该应用已在运行，则切换到该应用。Windows 徽标键 + Tab —&gt; 打开“任务视图”Windows 徽标键 + 向上键 —&gt; 最大化窗口Windows 徽标键 + 向下键 —&gt; 从屏幕中删除当前应用或最小化桌面窗口Windows 徽标键 + 向左键 —&gt; 将应用或桌面窗口最大化到屏幕左侧Windows 徽标键 + 向右键 —&gt; 将应用或桌面窗口最大化到屏幕右侧Alt + Enter —&gt; 打开选定项的“属性”对话框Backspace —&gt; 查看上一个文件夹F2 —&gt; 重命名选定项F3 —&gt; 在文件资源管理器中搜索文件或文件夹Ctrl + X —&gt; 剪切选定项Ctrl + C（或 Ctrl + Insert） —&gt; 复制选定项Ctrl + V（或 Shift + Insert） —&gt; 粘贴选定项Ctrl + Z —&gt; 撤消操作Ctrl + Y —&gt; 重做操作Alt + Tab —&gt; 在打开的应用之间切换Alt + F4 —&gt; 关闭活动项，或者退出活动应用]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Windows10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typora常用快捷键大全]]></title>
    <url>%2FG-SS-Hacker.github.io%2FTypora%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[Life is short, you need shortcuts Typora常用快捷键大全 Guderian出品 .tg {border-collapse:collapse;border-spacing:0;}.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg .tg-m9r4{background-color:#ffffc7;text-align:left;vertical-align:top}.tg .tg-ncd7{background-color:#ffffc7;border-color:inherit;text-align:left;vertical-align:top}.tg .tg-0lax{text-align:left;vertical-align:top}.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top} 操作类型 操作 快捷键 文件操作 新建 Ctrl + N 新建窗口 Ctrl + Shift + N 打开 Ctrl + O 快速打开 Ctrl + P 保存 Ctrl + S 另存为 Ctrl + Shift + S 偏好设置 Ctrl + 逗号 关闭 Ctrl + W 编辑操作 选中当前行/句 Ctrl + L 选中当前格式文本 Ctrl + E 选中当前词 Ctrl + D 查找 Ctrl + F 替换 Ctrl + H 查找下一个 F3 查找上一个 Shift + F3 段落操作 提升标题等级 Ctrl + = 降低标题等级 Ctrl + - 格式操作 加粗 Ctrl +Ｂ 斜体 Ctrl + I 下划线 Ctrl + U 代码 Ctrl + Shift + ` 删除线 Alt + Shift + 5 超链接 Ctrl + K 图像 Ctrl + Shift + I 清除样式 Ctrl + \ 【其他文章·Markdown·Windows10】 Markdown需要转义的字符及其转义方法 Typora常用快捷键大全 Windows10常用快捷键]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Think before you ask]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E5%85%88%E6%80%9D%E8%80%83%EF%BC%8C%E5%86%8D%E6%8F%90%E9%97%AE%2F</url>
    <content type="text"><![CDATA[If you want something done right, do it yourself. Think before you ask Guderian出品 自己动手，丰衣足食毛泽东曾经说过：“自己动手，丰衣足食。”关于求助这件事，其实很多时候看源代码或者帮助文档能解决很多问题，如果实在没有，一般你遇到的问题别人可能也遇到过，善用搜索引擎能解决更多问题。有一个说法:普通程序员 + google = 超级程序员。所以在平时要养成一些习惯，仔细阅读帮助文档，阅读源代码，善用搜索引擎，实在没辙了再提问。 在一些问答网站上，经常可见回答的一些缩写，很有趣也很有用，在此将其列举出来： RTFSC(Read the fucking source code) RTFM(Read the fucking manual) UTFH (Use The Fucking Help) STFW (Search The Fucking Web) STFG (Search The Fucking Google) GIYF (Google Is Your Friend) JFGI (Just Fucking Google It) UTSL (Use The Source Luke) RTFA (Read The Fucking Article) RTFE (Read The Fucking Email) RTFC (“Read The Fucking Code” or “Reboot The Fucking Computer”) RTFQ (Read The Fucking Question) LMGTFY (Let Me Google That For You) WIDGI (When In Doubt Google It) FIOTI (Find It On The Internet) 通常，给出这些答案的人已经通过这些办法找到了解决问题的关键，正在一边看一边敲键盘。这些回复意味着他认为：第一，你要的信息可以靠你自己的力量找到。第二，自已找要比别人喂到嘴里能学得更多。你不应该觉得这样就被冒犯了，按黑客的标准，他没有不理你就是在向你表示某种尊敬，你反而应该感谢他热切地想帮助你。 结束语 The tools we use have a profound influence on our thinking habits, and therefore, on our thinking abilities. ---from Edsger Dijkstra, 1972 Turing Awards receiver 我们使用的工具深刻地影响着我们的思维习惯，因此，也深刻影响着我们的思维能力。 ——艾兹格·迪科斯彻，1972年图灵奖得主]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解：约瑟夫环问题]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E9%A2%98%E8%A7%A3%EF%BC%9A%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[约瑟夫是一个无聊的人 题解：约瑟夫环问题 Guderian出品 题目背景据说著名犹太历史学家 Josephus有过以下的故事：在罗马人占领乔塔帕特后，39个犹太人与Josephus及他的朋友躲在一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。然而Josephus 和他的朋友并不想遵从。问题是，给定了总人数n和报数值m，一开始要站在什么地方才能避免被处决？Josephus要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。 题目描述n个人(n&lt;=100)围成一圈,从第一个人开始报数,数到m的人出列,再由下一个人重新从1开始报数,数到m的人再出圈,……依次类推,直到所有的人都出圈,请输出依次出圈人的编号。 输入格式n m 输出格式出圈的编号 输入输出样例输入 #1110 3 输出 #113 6 9 2 7 1 8 5 10 4 说明/提示m, n ≤ 100 解题方法解法一：模拟 + 指针模拟链表时间复杂度：$O(m * n)$ 1234567891011121314151617181920212223242526272829303132333435363738//Run on C++#include &lt;cstdio&gt;using namespace std;struct node&#123; int data; node* next;&#125;;int n, m;node *head, *p, *r; //head为头结点，p表示新节点，r表示当前节点int main()&#123; scanf("%d%d", &amp;n, &amp;m); head = new node; head-&gt;data = 1; head-&gt;next = NULL; r = head; for (int i = 2; i &lt;= n; i++) &#123; p = new node; p-&gt;data = i; p-&gt;next = NULL; r-&gt;next = p; r = p; &#125; r-&gt;next = head; r = head; //使链表首尾相连 for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m - 2; j++) r = r-&gt;next; printf("%d ",r-&gt;next-&gt;data); r-&gt;next = r-&gt;next-&gt;next; r = r-&gt;next; &#125; return 0;&#125; 解法二：模拟 + 数组模拟链表 时间复杂度：$O(m * n)$ 123456789101112131415161718192021//Run on C++#include &lt;cstdio&gt;int nxt[110];int n, m;int main()&#123; scanf("%d%d", &amp;n,&amp;m); for (int i = 1; i &lt;= n; i++) nxt[i] = i + 1; nxt[n] = 1; //使链表首尾相连 int pos = 1; //当前位置 for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m - 2; j++) pos = nxt[pos]; printf("%d ", nxt[pos]); nxt[pos] = nxt[nxt[pos]]; pos = nxt[pos]; &#125; return 0;&#125; 解法三：模拟 + 数组时间复杂度：$O(m * n)$ 12345678910111213141516171819202122232425262728//Run on C++#include &lt;cstdio&gt;int m, n;int a[110];int main()&#123; scanf("%d%d", &amp;n, &amp;m); int t = 1, i = 1, cnt = 0; //t为出去的人的数量，i为数组下标索引，cnt为计数器 while(t &lt;= n) &#123; if(i == n + 1) i = 1; //到了最后一个重新从第一个开始 if(a[i] == 0) &#123; cnt++; if(cnt == m) //到了第m个开始新一轮计数 &#123; a[i] = 1; cnt = 0; t++; printf("%d ",i); &#125; &#125; i++; &#125; return 0;&#125; 解法四：模拟 + 队列时间复杂度：$O(m * n)$ 1234567891011121314151617181920//Run on C++#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;queue &lt;int&gt; q;int n,m;int main()&#123; scanf("%d%d",&amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) q.push(i); while(!q.empty()) &#123; for(int i = 1; i &lt; m; i++) q.push(q.front()), q.pop(); //每数一个就把它放到队尾 printf("%d ",q.front()); q.pop(); //队头出圈 &#125; return 0;&#125; 注： 你也可以不用stl提供的队列，自己编写一个队列 你也可以用stl提供的双端队列deque，不过据笔者观察除了装逼效果之外并没有其他用处 解法五：递归（运用递推公式）时间复杂度：$O(n^2)$ 1234567891011121314151617//Run on C++#include &lt;cstdio&gt;int n, m;int Josephus(int x, int y, int z)&#123; if (z == 1) return (y - 1) % x; return (Josephus(x - 1, y, z - 1) + y) % x;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) printf("%d ", Josephus(n, m, i) + 1); return 0;&#125; 解法六：迭代（运用递推公式）时间复杂度：$O(n^2)$ 123456789101112131415161718//Run on C++#include &lt;cstdio&gt;int n, m;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; int ans; for (int j = 1; j &lt;= i; j++) if (j == 1) ans = (m - 1) % (n - i + j); else ans = (ans + m) % (n - i + j); printf("%d ", ans + 1); &#125; return 0;&#125; 推导递推公式*以解法五为例，在递归函数部分代码中 12345int Josephus(int x, int y, int z)&#123; if (z == 1) return (y - 1) % x; return (Josephus(x - 1, y, z - 1) + y) % x;&#125; x代表总人数，y代表每次报y的人出列，z是次数，该函数可以求第y次出圈的人的编号。 举个例子：总人数x为6人，从1开始，每报到3就出圈（z = 3） 初始情况：1 2 3 4 5 6 通过递推的方式使第一个幸运观众出圈之后：1 2 4 5 6 此时，这些编号已经不能组成一个环，但是2和4之间还是连着的，且下一次报数将从4开始。然而，之后的报数将总要考虑3处的空位问题。 如何避免空位对报数所造成的影响？ 可以将剩下的4个数重新组合成一个新的环，这样报数的时候就不必在意3的空缺了。但是新产生的环的数字并非连续的，报数时不能直接用+ y再% x的简单递推方式，这下真令人头大。 如何使新环上的编号依然能够递推？ 可以建立一种有确定规则的映射，要求映射之后的数字可以递推，且可以将在新环中继续按原规则报数得到的结果逆推出在旧环中的对应数字。 阻止我们使用老办法递推的因素就是3号出圈之后产生的新环编号不连续，那么，我们可以通过建立某种映射，使得新环的编号依然连续，方便我们继续使用递推的方法。 原始：1 2 3 4 5 6 旧环：1 2 _ 4 5 6 新环：4 5 _ 1 2 3 正如你所见，相比于旧环中2和4之间被割裂开，新环的5和1之间在对5取余的基础上是完美连续的，这就意味着我们可以继续从新环的1（即旧环的4）开始实施我们的递推方法。且只要推导出新环与旧环的映射关系，就能从在新环中报数的结果得知在旧环中的报数结果。 对于第二个幸运观众： 旧环：1 2 _ 4 5 *6 新环：4 5 _ 1 2 *3 如何从新环的3得到旧环的6呢？其实可以简单地逆推回去 : 新环是由(旧环中编号 - 报数值) % 旧环总人数得到的，所以逆推时可以由(新环编号 + 报数值) % 旧环总人数得到。 如：(3 + 3) % 6 = 0 咦？奇怪怎么是0？不是应该是6吗？这就涉及到一个进位的问题。由于旧环的编号为1~6，而我们在新环依然保留了1~5的编号并确保5和1之间在对5取余的基础上连续，这就导致了5 % 5 = 0，也就是说5与0是无法区分的。因此，虽然实际上旧环编号为6的幸运观众出圈，但是我们的计算结果依然不可避免地把它对6取余，得到一个看似奇怪却又顺理成章的0。 如何避免错误地把最大的数算成0的情况？ 把所有数减1即可，最后输出结果的时候再加上1。让我们再来一遍： 对于第二个幸运观众： 旧环：0 1 _ 3 4 *5 新环：3 4 _ 0 1 *2 从新环推出旧环的幸运观众：(2 + 3) % 6 = 5 由上得，原序列x中第二次出圈的编号可以由新序列x - 1第一次出圈的编号通过特定的逆推运算得出。即在以y为出环报数值的约瑟夫环中，x人环的第z次出环编号可以由x - 1人环中的第z - 1次出环编号通过也定的运算推出。 幸运的是，第一次出环的编号是可以直接求出的，也就是说，对于任意次出环的编号，我们可以将之一直转化为第一次出环的编号问题，再一一迭代求出；也可以把第一次出环的编号作为递归基础，通过递归求出。 因此我们可以写出Josephus函数的递推公式如下： Josephus(x,y,z) = \begin{cases} [Josephus(x-1,y,z-1) + y] \% x ,& \text{z > 1} \\ (y-1)\%x , & \text{z = 1} \end{cases}结束语以上就是关于约瑟夫环问题的六种解法，并送上调试过的C++代码，作者水平不高，将就看看吧 ╮(╯_╰)╭ *. 参考该网站，感谢作者的写作 &#8617;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>C-plus-plus</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++指针变量]]></title>
    <url>%2FG-SS-Hacker.github.io%2Fc-%E6%8C%87%E9%92%88%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[指针变量 Guderian出品 指针变量的定义、赋值对指针变量的类型说明，一般形式为： 类型说明符 *变量名; 其中，表示这是一个指针变量，变量名即为定义的指针变量名，类型说明符表示*该指针变量所指向的变量的数据类型。 1、普通变量定义int a = 3; 定义了变量a，是int型的，值为3。内存中有一块内存空间是放a的值，对a的存取操作就是直接到这个内存空间存取。内存空间的位置叫地址，存放3的地址可以用取地址操作符&amp;对a运算得到：&amp;a。 2、指针变量定义int *p = NULL; 定义了一个指针变量p，p指向一个内存空间，里面存放的是一个内存地址。现在赋值为NULL（其实就是0，表示特殊的空地址）。 3、给指针变量p赋值p = &amp;a; 即把a变量的内存空间地址（比如：XXX）给了p。显然，直接对p存取，操作的是地址。通过这个地址间接地操作，才是整数3。P的间接操作要使用指针操作符“*”，即*p的值才是3。设有指向整型变量的指针变量p，如要把整型变量a的地址赋予p可以有以下两种方式： ①指针变量初始化的方法 int a; int *p = &amp;a; ②赋值语句的方法 int a; int *p; p = &amp;a; 不允许把一个数赋予指针变量，故如下的赋值是错误的：int *p；p = 1000；。被赋值的指针变量前不能再加“*”说明符，故如下的赋值也是错误的：*p = &amp;a；。 下表为指针的几个相关操作说明表： 说明 样例 指针定义：类型说明符 *指针变量名 int *p; 取地址运算符：&amp; p = &amp;a; 间接运算符：* *p = 20; 指针变量直接存取的是内存地址 cout&lt;&lt;p;结果可能是：0x24ae9d 间接存取的才是存储类型的值 cout&lt;&lt;*p;结果是：20 指针变量同普通变量一样，使用之前不仅要定义说明，而且必须被赋值具体的值，未经赋值的指针变量不能使用。如定义了int a; int *p = &amp;a;，则*p表示p指向的整型变量，而p中存放的是变量a占用单元的起始地址，所以*p实际上访问了变量a，也就是说*p$ \Longleftrightarrow $a。 【例1】输入两个不同的数，通过指针对两个数进行相加和相乘，并输出。 123456789101112131415#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; int a, b, s, t, *pa, *pb; pa = &amp;a; pb = &amp;b; a = 10; b = 20; s = *pa + *pb; t = *pa * *pb; printf("a = %d, b = %d\n", *pa, *pb); printf("s = %d, t = %d\n", s, t); return 0;&#125; 输出： 12a = 10, b = 20s = 30, t = 200 指针的引用与运算一般的，指针(int *p)与普通变量(int a)的对应关系为： 指针变量 普通变量 p &amp;a *p a *p = 3 a = 3 以下为指针的一些运算： 1、指针变量的初始化下表为指针的几个初始化操作说明表： 方法 说明 int *p = NULL; NULL是特殊的地址0，叫零指针 int a; int *p = &amp;a; p初始化为a的地址 int *p = new(int); 申请一个空间给p，*p内容不确定 要强调的是，对于定义的局部指针变量，其内容（地址）是随机的，直接对它操作可能会破坏程序或系统内存的值，引发不可预测的错误。所有编程中指针变量要保证先初始化或赋值，给予正确的地址再使用，避免产生*野指针。 2、指针变量的+、-运算指针变量的内容是内存地址，它有两个常用的运算：加、减，这两个运算一般都是配合数组操作的。 【例2】输入N个整数，使用指针变量访问输出。 123456789101112131415161718#include &lt;cstdio&gt;using namespace std;int a[101], n;int main()&#123; scanf("%d",&amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); int p = &amp;a[1]; //定义指针变量int p，初始化为数组开始元素的地址，即a[1]; for (int i = 1; i &lt;= n; i++) &#123; printf("%d ", *p); p++; //p指向下一个数，详见说明 &#125; return 0;&#125; 输入： 1242 1 6 0 输出： 12 1 6 0 【说明】 p++的意思是“广义的加1”，不是p的值（地址）加1，而是根据类型int增加sizeof（int），即刚好“跳过”一个整数的空间，达到下一个整数。 类似的： ①p--就是向前“跳过”一个整数的空间，达到前一个整数。 ②(p + 3)就是指向后面第3个整数的地址。 3、无类型指针有时候，一个指针根据不同的情况，指向的内容是不同类型的值，我们可以先不明确定义它的类型，只是定义一个无类型的指针，以后根据需要再用强制类型转换的方法明确它的类型。 【例3】无类型指针运用举例。 123456789101112131415#include &lt;iostream&gt;using namespace std;int a = 10;double b = 3.5;void *p;int main()&#123; p = &amp;a; //p的地址赋值 cout&lt;&lt;*(int*)p&lt;&lt;endl; //必须明确p指向的空间的数据类型，详见说明 p = &amp;b; cout&lt;&lt;*(double*)p&lt;&lt;endl; return 0;&#125; 输出： 12103.5 【说明】 必须明确p指向的空间的数据类型，类型不一样的不仅空间大小不相同，储存的格式也不同。如果把cout&lt;&lt;*(double*)p&lt;&lt;endl;改成cout&lt;&lt;*(long long*)p&lt;&lt;endl;输出的结果将是：4615063718147915776。 4、多重指针既然指针是指向其他类型的，指针本身也是一种类型。因此，C++允许递归地指针指向指针的指针——多重指针。 【例4】双重指针运用举例。 1234567891011121314#include &lt;cstdio&gt;using namespace std;int a = 10;int *p;int **pp; //定义双重指针int main()&#123; p = &amp;a; //将p指向a pp = &amp;p; //将pp指向p printf("%d = %d = %d\n", a, *p, **pp); //**pp通过2次间接访问了a的变量的值10 return 0;&#125; 输出： 110 = 10 = 10 【说明】 多重指针可以多次“间接”访问数据；竞赛上主要的应用是*动态的多维数组，功能十分强大！！！]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C-plus-plus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[野指针的产生及其危害]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E9%87%8E%E6%8C%87%E9%92%88%E7%9A%84%E4%BA%A7%E7%94%9F%E5%8F%8A%E5%85%B6%E5%8D%B1%E5%AE%B3%2F</url>
    <content type="text"><![CDATA[野指针的产生及其危害 Guderian出品 野指针指向了一块随机内存空间，不受程序控制。如指针指向已经被删除的对象或者指向一块没有访问权限的内存空间，之后如果对其再进行引用的话，就会出现问题。 成因指针变量未初始化任何指针变量（无static修饰的局部变量）刚被创建时不会自动成为*NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。如果没有初始化，编译器会报错。 注：NULL指针是一个定义在标准库中的值为零的常量，其定义为： 1#define NULL ((void *)0) 指针释放之后未置空又是指针在free或delete后未赋值NULL，便会使人以为是合法的。然而free和delete只是把指针所指的内存给释放掉，并没有把指针本身干掉。此时指针指向的是随机内存空间。释放指针后应立即将指针置为NULL，防止产生野指针。 指针操作超越变量作用域返回或引用指向*栈内存的指针，因为栈内存在函数结束的时候会被释放 后果 指向不可访问地址，造成程序异常终止 指向可用空间，但是这块空间不适用，程序正常运行 指向可用空间，但是这块空间刚好在用，造成数据错误 规避初始化时置NULL指针变量一定要初始化为NULL，因为任何指针变量（无static修饰的局部变量）刚被创建时不会自动成为NULL指针，它的缺省值是随机的。 释放时置NULL当指针p指向的内存空间释放时，没有设置指针p的值为NULL。delete和free只是把内存空间释放了，但是并没有将指针p的值赋为NULL。通常判断一个指针是否合法，都是使用if语句测试该指针是否为NULL。例如（针对C++）： 123int *p = new int(6);delete p;if(p != NULL) *p = NULL; 或者使用宏定义来一次性解决问题： 1#define del(x) delete(x); x = NULL]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C-plus-plus</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python运算符优先级]]></title>
    <url>%2FG-SS-Hacker.github.io%2FPython%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[Python运算符优先级 Guderian出品 .tg {border-collapse:collapse;border-spacing:0;}.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg .tg-ncd7{background-color:#ffffc7;border-color:inherit;text-align:left;vertical-align:top}.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top} 运算符描述 Python运算符 优先级 （*不常用） 索引运算符 x[index] 或x[index:index2[:index3]] 18、19 （*不常用） 属性访问 x.attribute 17 算术运算符 乘方 ** 16 位运算符 按位取反 ~ 15 符号运算符 +（正号）或 -（负号） 14 算术运算符 乘、除 *、/、//、% 13 加、减 +、- 12 位运算符 位移 &gt;&gt;、&lt;&lt; 11 按位与 &amp; 10 按位异或 ^ 9 按位或 | 8 比较运算符 ==、!=、&gt;、&gt;=、&lt;、&lt;= 7 身份运算符 is、is not 6 成员运算符 in、not in 5 逻辑运算符 逻辑非 not 4 逻辑与 and 3 逻辑或 or 2]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C和C++中memset()函数]]></title>
    <url>%2FG-SS-Hacker.github.io%2FC%E5%92%8CC-%E4%B8%ADmemset%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[想更方便地初始化吗？Just use memset()!!! C和C++中memset()函数 Guderian出品 头文件 C： &lt;string.h&gt; C++： &lt;cstring&gt; 声明void *memset(void *str, int c, size_t n) 此处size_t变量类型等价于long unsigned int即无符号长整型，在32位机器上为32位，在64位机器为中64位。 注：32位机器指CPU通用寄存器的数据宽度为32位，也就是说CPU一次可以运行32bit数据 描述复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。 参数 str ——指向要填充的代码块 c——要被设置的值该值以 int 形式传递，但是函数在填充内存块时是使用该值的无符号字符形式。 n——要被设置为该值的字节数。 返回值返回一个指向存储区str的指针。 实例对字符串操作123456789101112131415#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main ()&#123; char str[50]; strcpy(str,"This is string.h library function"); puts(str); memset(str,'$',7); puts(str); return(0);&#125; 编译并运行以上程序，得到结果如下： 12This is string.h library function$$$$$$$ string.h library function 初始化数组注意：c接收参数的范围0-255 ，该函数只能取c的后八位赋给你所指定的范围的每个字节 初始化为0memset(arr, 0, sizeof(arr)); 初始化为-1memset(arr, -1, sizeof(arr));或memset(arr, 0x7fffffff,sizeof(arr)); 初始化为正无穷 理论上的正无穷：memset(arr, 0x7f, sizeof(arr)); 实际使用的正无穷：memset(arr, 0x3f, sizeof(arr)); 注：D（decimal）——十进制，B（binary）——二进制，O（octor）——八进制，H（hex）——十六进制 初始化为负无穷 理论上的负无穷：memset(arr, 0x80, sizeof(arr)); 实际使用的负无穷：memset(arr, 0xbf, sizeof(arr)); 注：此处要设置的值也可用二进制表示，如0xbf等价于0b10111111]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C-plus-plus</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构绪论]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[基本概念与术语、逻辑结构与物理结构、抽象数据类型 数据结构绪论 Guderian出品 基本概念与术语数据数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅包括整型、实数型等数值类型，还包括字符及声音、图像、视频等非数值类型（严格地说，布尔型也属于数据）。 综上，我们这里说的数据，其实就是符号，且必须具备两个前提： 可以输入到计算机中 能被计算机程序处理 数据元素数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。 数据项数据项：数据不可分割的最小单位。但在真正讨论问题时，数据元素才是数据结构中建立数据模型的着眼点。 数据对象数据对象：性质相同的数据元素的集合，是数据的子集。 数据结构数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。 逻辑结构与物理结构逻辑结构逻辑结构：是指数据对象中数据元素之间的相互关系。 集合结构：地位平等、同属于一个集合。 线性结构：一对一。 树形结构：一对多。 图形结构：多对多。 逻辑结构针对具体问题，是为了解决某个问题，在对问题理解的基础上，选择一个合适的数据结构表示数据元素之间的逻辑关系。 物理结构物理结构（有名存储结构）：数据的逻辑结构在计算机中的存储形式。 顺序存储结构：地址连续的存储单元。 链式存储结构：任意的存储单元。 抽象数据类型数据类型数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。 数据类型可分两类： 原子类型：不可分解，如整形、实型、字符型。 结构类型：可分解，如整型数组、字符串。 抽象数据类型抽象数据类型（Abstract Data Type）：是指一个数学模型及定义在该模型1及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性。而与其在计算机内部如何表达和实现无关。 抽象：抽取出事物具有的普遍性的本质。”抽象“的意义在于数据类型的数学抽象特性。 抽象数据类型不仅指那些已经定义并实现的数据类型（如整型），还可以是计算机编程者在设计软件程序时自己定义的数据类型（如三维坐标(x, y, z)）。 描述抽象数据类型的标准格式： 12345678910ADT 抽象数据类型Data 数据类型之间逻辑关系的定义Operation 操作1 初始条件 操作结果描述 操作2 ……endADT]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算思维导论]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E8%AE%A1%E7%AE%97%E6%80%9D%E7%BB%B4%E5%AF%BC%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[计算思维的本质是抽象与自动化 计算思维导论 Guderian出品 计算思维的发展 计算机的思维：计算机室如何工作的？计算机的功能是如何越来越强大的? 利用计算机的思维：现实世界的各种食物如何利用计算机进行控制和处理？ 计算思维：利用计算机科学的基础概念去求解问题、设计系统和理解人类行为，其本质是抽象与自动化。 学习步骤 概念与知识 联想与贯通 练习与实践 人计算与机器计算的差别人计算： 规则可能很复杂，但计算量却可能很小 人需要知道具体的计算规则 只能使用特定规则 机器计算（自动计算）： 规则可能很简单，但计算量却可能很大 机器也可以使用人的计算规则 使用一般性的规则 自动计算要解决的几个问题：表示-存储-执行 数据的表示 计算规则的表示 数据与计算规则的自动存储 计算规则的自动执行 自动计算的发展历程 如算盘（计算辅助工具）：可以表示数据，不能自动计算 帕斯卡机械计算机：自动计算，固定的计算规则 巴贝奇机械计算机：特定程序，可有限变化的计算规则 现代电子计算机：一般程序，任意可变的计算规则 电子计算机元器件的发展 电子管 晶体管 集成电路 超大规模集成电路（VLSI） 计算机系统的组成 运算器 控制器 存储器 输入设备 输出设备 计算机系统的发展趋势 微型化：可嵌入，可携带 大型化：可进行大规模复杂计算 智能化：理解自然语言，具有自适应性，自主完成复杂功能 网络化：机-机相连，物-物相连，物-人相连，人-人相连，如：IoT，IBM提出”智慧地球”]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>计算思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown需要转义的字符及其转义方法]]></title>
    <url>%2FG-SS-Hacker.github.io%2FMarkdown%E9%9C%80%E8%A6%81%E8%BD%AC%E4%B9%89%E7%9A%84%E5%AD%97%E7%AC%A6%E5%8F%8A%E5%85%B6%E8%BD%AC%E4%B9%89%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Markdown需要转义的字符及其转义方法 Guderian出品 123456789101112\\ 反斜杠\` 反引号\* 星号\_ 下划线\&#123;\&#125; 大括号\[\] 中括号\(\) 小括号\# 井号\+ 加号\- 减号\. 英文句号\! 感叹号]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Python的坑]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E5%85%B3%E4%BA%8EPython%2F</url>
    <content type="text"><![CDATA[关于Python Guderian出品 学习步骤： [ ] 配置环境，安装Python IDLE [ ] Variale（变量）：int（整形），float（浮点型），str（字符串），bool（布尔型） [ ] Data Type（数据类型）：Number（数字），String（字符串），List（列表），Tuple（元组），Set（集合），Dictionary（字典） [ ] 运算符及其优先级 [ ] 分支和循环 换行符号：\n BIF == Built-in function（__builtins__），即内置函数 Python是动态类型语言、脚本语言（编写速度很快） 变量不能以数字开头且区分大小写 字符串可用单引号或双引号表示 转义字符：\甚至可以转义自身 原始字符串：r&#39;...&#39; 小数达到16位及以上时使用E计数法 配合random模块，random.choice()可从一个非空序列中随机获取一个元素 isinstance(a,b)验证变量a的类型是否是b 保留小数数位round(a,b)：对小数a保留b位（b == 0则为x.0) 格式化输出：输出a，保留x位小数 print(‘%.xf’ %a)，中间无逗号 三元操作符：（非常容易出错）： a = x if 条件 else y assert（断言），当关键字右面条件为真时没有反应，为假时程序自动崩溃并抛出AssertionError异常 Int / int会得到float，哪怕不带小数点，千万注意 print得到的东西会自带换行，要避免的话：print(输出, end = ‘’) 短路逻辑：A and B，如果A == False，那么不判断B直接返回False 可迭代对象：列表、元组、字典、文件、集合、生成器 使用max()和min()要保证序列的数据类型统一 sorted()返回一个排好序的列表 reverse()返回一个翻转的迭代器对象 enumerate()生成由二元组构成的一个迭代对象，每个二元组由迭代参数索引号及对应元素组成 zip(iter1,iter2,...)返回各个可迭代参数共同构成的元组，取最短，分先后 在定义函数的时候，位置参数必须在默认参数的前面，否则就会出错 星号（）在形参中的作用是“打包”，在实参中的作用是“*解包” and和or操作符的用法说明：3 and 4返回后一个4，3 or 4返回前一个3 `print`的参数：`print(*object, sep=' ', end='\n', file=sys.stdout, flush=False)` 函数内部只能访问全局变量，不能修改，非要修改可以使用global关键字声明，但不可用于嵌套函数 Python 模块(Module)，是一个 Python 文件，以 .py 结尾，包含了 Python 对象定义和Python语句 dir(模块)返回的列表容纳了在一个模块里定义的所有模块，变量和函数 Python中的整数区间均为左闭右开，负数区间均为左闭右闭 要完成列表的拷贝必须用分片，即了lis1 = lis2[:]，绝不可以直接lis1 = lis2，因为变量名是“贴”在变量上的，变量名与变量之间并非一一对应关系 列表解析式（或列表推导式）：[有关A的解析式 for A in B]]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2FG-SS-Hacker.github.io%2Fhello-world%2F</url>
    <content type="text"><![CDATA[多种语言实现Hello World Starter Guderian出品 Python1print("hello world") C123456#include&lt;stdio.h&gt;int main()&#123; printf("hello world"); return 0;&#125; C++12345678#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; cout&lt;&lt;"hello world"; return 0;&#125; C#123456789using System; class TestApp &#123; public static void Main() &#123; Console.WriteLine("hello world"); Console.ReadKey(); &#125; &#125; Pascal1234Program HelloWorld(output); begin writeln('hello world') end. Java1234567public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println("hello world"); &#125; &#125;]]></content>
  </entry>
</search>
