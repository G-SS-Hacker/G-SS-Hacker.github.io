<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++友元]]></title>
    <url>%2FG-SS-Hacker.github.io%2FC-%E5%8F%8B%E5%85%83%2F</url>
    <content type="text"><![CDATA[C++友元 Guderian出品 友元很简单，在某种程度上算作是C++设计者对C使用者的妥协。友元分为友元函数和友元类两种。 友元函数一个类的友元函数可以访问该类的私有成员，友元函数不是这个类的成员函数，可以是一个普通的全局函数或其他类的成员函数 123456789101112131415161718192021222324252627class CCar; //提前声明CCar是一个类，以便后面的CDriver类使用class CDriver&#123; public: void ModifyCar(CCar *pCar);&#125;;class CCar&#123; private: int price; friend int MostExpensiveCar(CCar cars[], int total); //声明友元 friend void CDriver::ModifyCar(CCar *pCar) //声明友元&#125;;void CDriver::ModifyCar(CCar *pCar)&#123; pCar-&gt;price += 1000; //汽车改装后价值增加&#125;int MostExpensiveCar(CCar cars[], int total)&#123; int tmpMax = -1; for(int i = 0; i &lt; total; ++i) if(cars[i].price &gt; tmpMax) tmpMax = cars[i].price; return tmpMax; &#125; 可以将一个类的成员函数（包括构造、析构函数）说明为另一个类的友元 123456789class B&#123; public: void function();&#125;;class A&#123; friend void B::function();&#125;; 友元类如果A是B的友元类，那么A的所有成员函数可以访问B的所有私有成员 12345678910111213141516class CCar&#123; private: int price; friend class CDriver; //声明CDriver为友元类&#125;;class CDriver&#123; public: CCar myCar; void ModifyCar() //改装汽车 &#123; myCar.price += 1000; //因CDriver是CCar的友元类故可以访问其私有成员 &#125;&#125;; 友元类之间的关系不能传递：类A是类B的友元，类C是类B的友元，但类A不是类C的友元 友元类之间的关系不能继承 参考并整理自《C++面向对象设计》郭炜，北京大学，感谢原作者！编辑时有删改]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>OOP</tag>
        <tag>C-plus-plus</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++常量对象、常量成员函数和常引用]]></title>
    <url>%2FG-SS-Hacker.github.io%2FC-%E5%B8%B8%E9%87%8F%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B8%B8%E9%87%8F%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%92%8C%E5%B8%B8%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[C++常量对象、常量成员函数和常引用 图：广州塔 Guderian出品 常量对象如果不希望某个对象的值被改变，则定义该对象的时候可在前面加const关键字。 123456789class CDemo&#123; private: int vale; public: void SetValue() &#123;&#125;&#125;;const Demo obj; //常量对象 常量成员函数在类的成员函数说明后面可以加const关键字，则该成员函数成为常量成员函数。 常量成员函数执行期间不应该修改其所作用的对象。因此，在常量成员函数中不能修改成员变量的值（静态成员变量除外），也不能调用同类的非常量成员函数（静态成员函数除外）。 非常亮成员函数在执行的过程中是有可能修改掉常量成员函数中的值的。 12345678910111213141516171819202122232425class Sample&#123; public: int value; void GetValue() const; void func() &#123;&#125;; Sample() &#123;&#125;&#125;;void Sample::GetValue() const&#123; value = 0; //wrong,不能修改成员变量的值 func(); //wrong,不能调用同类的非常量成员函数&#125;int main()&#123; const Sample o; o.value = 100; //err,不能修改成员变量的值 o.func(); //err,不能调用同类的非常量成员函数 o.GetValue(); //ok,可以执行常量成员函数 return 0;&#125; 常量成员函数的重载两个成员函数，名字和参数表都一样，但是一个是const，一个不是，算重载，而不是重复定义。 12345678910111213141516171819202122class CTest&#123; private: int n; public: CTest() &#123; n = 1 ;&#125; int GetValue() const &#123; return n; &#125; int GetValue() &#123; return 2 * n; &#125; //这两个GetValue()函数是重载关系，而不是重复定义&#125;;int main()&#123; const CTest objTest1; CTest objTest2; cout &lt;&lt; objTest1.GetValue() &lt;&lt; ", " &lt;&lt; objTest2.GetValue(); //objTest1是常量对象，调用的是GetValue() const //objTest2是非常量对象，调用的是GetValue() return 0;&#125; 常引用引用前面可以加const关键字，成为常引用。不能通过常引用，修改其引用的变量。 123const int &amp;r = n;r = 5; //errorn = 4; //OK 对象作为函数的参数时，生成该参数需要调用复制构造函数，效率比较低。用指针作参数，代码又不好看，如何解决？可以用对象的引用作为参数。 12345678class Sample&#123; //... &#125;;void PrintfObj(Sample &amp;o)&#123; //...&#125; 但对象引用作为函数参数有一定风险性，若函数中不小心修改了形参o，则实参也跟着变，这不是我想要的。如何避免？使用常引用！ 12345678class Sample&#123; //... &#125;;void PrintfObj(const Sample &amp;o)&#123; //...&#125; 这样函数中就能确保不会出现无意中更改o值的语句了。 参考并整理自《C++面向对象设计》郭炜，北京大学，感谢原作者！编辑时有删改]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>OOP</tag>
        <tag>C-plus-plus</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++复制构造函数]]></title>
    <url>%2FG-SS-Hacker.github.io%2FC-%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[C++复制构造函数 图：广州天河CBD Guderian出品 基本概念 只有一个参数，即对同类对象的引用 形如X::X(X &amp;)或X::X(const X &amp;)，二者选一，后者能以常量对象作为参数 如果没有定义复制构造函数，那么编译器生成默认的复制构造函数。默认的复制构造函数完成复制功能 构造函数与复制构造函数的异同 构造函数（或称无参构造函数）不一定存在，你不写构造函数，编译器就只会帮你生成一个什么也不做的无参构造函数 复制构造函数一定存在，你不写复制构造函数，编译器也会帮你写好一个具有复制功能的复制构造函数 12345678class Complex&#123; private: douebl real, imag;&#125;;Complex c1; //调用缺省的构造函数Complex c2(c1); //调用缺省的复制构造函数，将c2初始化成和c1一样 如果定义了自己的复制构造函数，则默认的复制构造函数不存在 12345678910111213141516class Complex&#123; public: double real, imag; Complex() &#123;&#125; Complex(const Complex &amp;c) &#123; real = c.real; imag = c.imag; cout &lt;&lt; "Copy constructor called"; &#125;&#125;;Complex c1;Complex c2(c1);//调用自己定义过的复制构造函数，输出Copy constructor called 特别强调1注意：不允许有形如X::X(X)的复制构造函数，参数一定是引用，不能是对象 12345678class CSample&#123; CSample(CSample c) &#123; //错，不允许出现这样的复制构造函数 //这样写的话，下面的内容要么变成了构造函数，要么语法是错误的 &#125;&#125;; 复制构造函数起作用的三种情况（1）当用一个对象去初始化同类的另一个对象时12Complex c2(c1);Complex c2 = c1; //初始化语句，非赋值语句，与上面写法是等价的 （2）当某函数有一个参数是类A的对象时那么该函数被调用时，类A的复制构造函数将被调用。C++规则：形参是实参的拷贝 123456789101112131415161718192021class A&#123; public: A() &#123;&#125;; A(A &amp;a) &#123; cout &lt;&lt; "Copy constructor called" &lt;&lt; endl; &#125;&#125;;void Func(A a1) &#123;&#125;int main()&#123; A a2; Func(a2); retrun 0;&#125;//输出：Copy constructor called （3）当函数的返回值是类A的对象时那么在函数返回时，A的复制构造函数被调用，作用是初始化作为返回值的类A对象 1234567891011121314151617181920212223242526272829class A&#123; public: int v; A(int n) &#123;v = n&#125;; A(const A &amp;a) &#123; v = a.v; cout &lt;&lt; "Copy constructor called" &lt;&lt; endl; &#125;&#125;;A.Func()&#123; A b(4); return b;&#125;int main()&#123; cout &lt;&lt; Func().v &lt;&lt; endl; //此处Func()的返回值没有名字，是一个复制构造函数初始化的对象 return 0;&#125;//输出：Copy constructor called4 特别强调2注意：对象间赋值并不导致复制构造函数被调用 123456789101112131415161718192021222324class CMyClass&#123; public: int n; CMyClass() &#123;&#125;; CMyClass(CMyClass &amp;c) &#123; n = 2 * c.n; &#125; //不推荐复制构造函数这样写，此处仅用于凸显调用复制构造函数与对象间赋值的区别&#125;;int main()&#123; CMyClass c1, c2; c1.n = 5; c2 = c1; //这是赋值语句 CMyClass c3(c1); //调用复制构造函数，c3并没有变得跟c1一样 cout &lt;&lt; c2.n &lt;&lt; ", "; cout &lt;&lt; c3.n &lt;&lt; endl; return 0;&#125;//输出：5, 10 定义函数时常量引用参数的使用1234void fun(CMyClass obj)&#123; cout &lt;&lt; "fun" &lt;&lt; endl;&#125; 这样的函数，调用时生成形参会引发复制构造函数调用，复制一遍时间开销比较大 所以可以考虑使用CMyClass &amp; 引用类型作为参数，本质上与实参是一样的 如果希望确保实参的值在函数中不应被改变，那么可以加上const关键字，这样的话如果你定义的函数中出现了改变实参的值得语句。编译器就会报错 我自己写的程序难道我自己不记得我没有改过参数吗？的确，你现在记得，明天也记得，但以后再改你的程序，就未必记得了。从代码规范的角度来讲，加上const关键字是必要的 1234void fun(const CMyClass &amp;obj)&#123; //如此一来，函数中任何试图改变obj值得语句都将是非法&#125; 思考：为什么要自己写复制构造函数？ 想通这个问题是高难度操作，作者水平有限，无法清晰地回答，仅提供参考链接。 前置知识： 深拷贝、浅拷贝 传值、传地址、传引用 参考链接： 为什么需要拷贝构造函数 c++的默认拷贝构造函数，从深度拷贝和浅拷贝说起 为什么要自己写构造函数和析构函数 使用缺省的拷贝构造函数带来的危险性 值传递 引用传递（传地址，传引用）的区别 参考并整理自《C++面向对象设计》郭炜，北京大学，感谢原作者！编辑时有删改]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>OOP</tag>
        <tag>C-plus-plus</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++构造函数]]></title>
    <url>%2FG-SS-Hacker.github.io%2FC-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[C++ 构造参数 图：深圳福田CBD Guderian出品 构造函数的性质 构造参数是成员函数的一种 名字与类名相同，可以由参数，不能有返回值（void也不行） 作用是对对象进行初始化，如给成员变量赋初值 如果定义类的时候没写构造函数，则编译器生成一个默认的无参数的构造函数 默认构造函数无参数，不进行任何操作 如果定义了构造函数，则编译器不生成默认的无参数的构造函数 对象生成时构造函数被自动调用。对象一旦生成，就再也不能在其上执行构造函数 一个类可以有多个构造函数 注：如果只定义了带参构造函数，在定义对象时必须声明参数 为什么需要构造函数： 不用专门写初始化函数，也不用担心忘记 有时对象没有被初始化，会导致程序出错 构造函数的使用一个类可以有一个构造函数1234567891011121314151617181920class Circle&#123; private: double radius, xLoc, yLoc; public: Circle(double r ,double x = 0, y = 0)&#125;;Circle::Circle(double r, double x, double y)&#123; radius = r, xLoc = x, yLoc = y;&#125;//Wrong samplesCircle c1; //error,缺少构造函数的参数Circle *pc = new Circle; //error，没有参数//Correct samplesCircle c1(2); //OKCircle c1(2, 4, 4); //OKCircle *pc = new Circle(3, 4); //also OK 一个类可以有多个构造函数只要不同的构造函数的参数个数和参数类型不同，这些构造函数就会构成重载的关系 1234567891011121314151617181920212223242526class Circle&#123; private: double radius, xLoc, yLoc; public: Circle(double r ,double x = 0, y = 0) Circle(double r); Circle(Circle c1, Circle c2)&#125;;Circle::Circle(double r, double x, double y)&#123; radius = r, xLoc = x, yLoc = y;&#125;Circle::Circle(double r)&#123; radius = r;&#125;Circle::Circle(Circle c1, Circle c2)&#123; radius = c1.radius + c2.radius; xLoc = c1.xLOc + c2.xLoc; yLoc = c1.yLOc + c2.yLoc;&#125;//SamplesCircle c1(3), c2(1, 0), c3(c1, c2); 构造函数在数组的使用（1）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class CSample&#123; private: int x; public: CSample() &#123; cout &lt;&lt; "Constructor 1 Called" &lt;&lt; endl; &#125; CSample(int n) &#123; x = n; cout &lt;&lt; "Constructor 2 Called" &lt;&lt; endl; &#125;&#125;;int main()&#123; cout &lt;&lt; "step1" &lt;&lt; endl; CSample array1[2]; cout &lt;&lt; "step2" &lt;&lt; endl; CSample array2[2] = &#123;4, 5&#125;; cout &lt;&lt; "step3" &lt;&lt; endl; CSample array3[2] = &#123;3&#125;; cout &lt;&lt; "step4" &lt;&lt; endl; CSample *array4 = new CSample[2]; //随机生成两个元素的数组 delete []array4; //解除空间占用 return 0;&#125;//输出：step1//对两个对象初始化的参数没有作任何交代，编译器就认为这个对象就应该用无参的构造函数初始化Constructor 1 CalledConstructor 1 Calledstep2 //对两个对象初始化的参数都有交代Constructor 2 CalledConstructor 2 Calledstep3 //只对第一个对象初始化的参数作了交代Constructor 2 CalledConstructor 1 Calledstep4 //对两个对象初始化的参数没有作任何交代Constructor 1 CalledConstructor 1 Called 构造函数在数组的使用（2）1234567891011121314151617181920212223class Test&#123; public: Test(int n) &#123;&#125; //(1) Test(int n, int m) &#123;&#125; //(2) Test() &#123;&#125; //(3)&#125;;Test array1[3] = &#123;1, Test(1,2)&#125;;//三个元素分别用(1)，(2)，(3)初始化Test array2[3] = &#123;Test(2, 3), Test(1, 2), 1&#125;;//三个元素分别用(2)，(2)，(1)初始化Test *pArray1[3];//仅仅这么定义是不会导致对象生成的，不会引发Test的构造函数被调用。//*pArray1[3]仅仅是指针而已，不会产生任何对象Test *pArray2[3] = &#123;new Test(4), new Test(1, 2)&#125;;//对指针数组的前两个元素初始化，方法是new两个对象，返回值是指针，用new的两个对象的地址去初始化数组pArray2[3]的前两个元素。//注意这个语句只生成了两个对象，pArray2[2]还是一个指针，无从得知它的指针指向哪里，它的生成并不会导致任何对象的生成。//注意在使用中，指针数组与数组的区别 参考并整理自《C++面向对象设计》郭炜，北京大学，感谢原作者！编辑时有删改]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>OOP</tag>
        <tag>C-plus-plus</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不定积分公式]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[不定积分公式 Guderian出品 $(1)\int0 \mathrm{dx} = C$ $(2)\int1\mathrm{dx}=x+C$ $(3)\int x^\mu \mathrm{dx}=\frac1{\mu+1}x^{\mu+1}+C(\mu \ne -1)$ $(4)\int\frac1{x}\mathrm{dx}=\ln|x|+C$ $(5)\int a^x \mathrm{dx}=\frac{a^x}{\ln a}+C$ $(6)\int e^x \mathrm{dx}=e^x+C$ $(7)\int \sin x \mathrm{dx}=-\cos x +C$ $(8)\int \cos x \mathrm{dx}=\sin x +C$ $(9)\int \sec^2 x \mathrm{dx}=\int \frac1{\cos^2 x}\mathrm{dx}=\tan x+C$ $(10)\int \csc^2x\mathrm{dx}=\int \frac1{\sin^2x}\mathrm{dx}=-\cot x +C$ $(11)\int\sec x\tan x\mathrm{dx}=\sec x+C$ $(12)\int \csc x\cot x\mathrm{dx}=-\csc x +C$ $(13)\int \frac{\mathrm{dx}}{\sqrt{1-x^2}}=\arcsin x+C$ $(14)\int \frac{\mathrm{dx}}{1+x^2}=\arctan x+C$ $(15)\int \tan x\mathrm{dx}=-\ln|\cos x|+C$ $(16)\int \cot x \mathrm{dx}=\ln|\sin x|+C$ $(17)\int \sec x \mathrm{dx}=\ln|\sec x+\tan x|+C$ $(18)\int \csc x\mathrm{dx}=\ln|\csc x -\cot x|+C$ $(19)\int \frac{\mathrm{dx}}{x^2+a^2}=\frac1{a}\arctan {\frac{x}{a}}+C$ $(20)\int \frac{\mathrm{dx}}{x^2-a^2}=\frac1{2a}\ln|\frac{x-a}{x+a}|+C$ $(21)\int \frac{\mathrm{dx}}{\sqrt{a^2-x^2}}=\arcsin \frac{x}{a}+C$ $(22)\int \frac{\mathrm{dx}}{\sqrt{x^2\pm a^2}}=\ln|x+\sqrt{x^2\pm a^2}|+C$ $(23)\int \sqrt{a^2-x^2}\mathrm{dx}=\frac{x}{2}\sqrt{a^2-x^2}+\frac{a^2}{2}\arcsin \frac{x}{a}+C$ $(24)\int \sqrt{x^2\pm a^2}\mathrm{dx}=\frac{x}{2}\sqrt{x^2\pm a^2}\pm \frac{a^2}{2}\ln|x+\sqrt{x^2\pm a^2}|+C$ $(25)\int \ln x\mathrm{dx}=x\ln x-x+C$ ~我们遇到什么困难也不要怕，微笑着面对它！消除恐惧的最好办法就是面对恐惧！坚持就是胜利！加油！奥利给！~ 【其他文章·微积分·线性代数】 不定积分公式 常用泰勒展开式 高阶求导公式 高等数学公式 常用等价无穷小 导数基本公式 矩阵章节总结 行列式章节总结 线性方程组章节总结]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性方程组章节总结]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E7%AB%A0%E8%8A%82%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[线性方程组章节总结 Guderian出品 线性方程组有解的充要条件 齐次线性方程组要么只有一组零解，要么有无穷多解 非齐次线性方程组有解的充要条件 $R(A)=R(A|\beta)$ 注：$R(A)$和$R(A|\beta)$要么相等，要么差$1$ 线性方程组解的结构 齐次线性方程组 (1) $AX=0$只有零解 $ \Leftrightarrow R(A)$等于未知数个数$\Leftrightarrow$A为列满秩阵 (2) $AX=0$有无穷多组解 $ \Leftrightarrow R(A)$小于未知数个数 非齐次线性方程组 (1) $AX=B$ 有唯一解 $\Leftrightarrow R(A)=R(A|\beta)=n$ (2) $AX=B$ 有无穷多组解 $\Leftrightarrow R(A)=R(A|\beta)&lt;n$ (3) $AX=B$ 无解 $\Leftrightarrow R(A) \ne R(A|\beta)$ 注：在非常严苛的条件下，以下两命题等价：$AX=B$ 有唯一解 $\Leftrightarrow $ $AX=0$只有零解（当$A$时方阵时成立） 线性方程组的解思想：利用矩阵初等行变换（高斯消元） 齐次线性方程组 记$N(A)$为齐次线性方程组的全体解向量所构成的向量空间，则$\dim N(A)=n-R(A)$，称$n(A)$的基为齐次线性方程组的基础解系： (1) 当$R(A)=n$时，齐次线性方程组只有零解，没有基础解系 (2) 当$R(A)&lt;n$时，基础解系为齐次线性方程组的$n-R(A)$个线性无关的解向量 非齐次线性方程组 $AX=B$ 和 $AX=0$的解向量满足： (1) 若$\eta_1$，$\eta_2$都是$AX=B$的解，那么$\eta_1 - \eta_2$是$AX=0$的解（几乎没用） (2) 若$\eta_1$是$AX=B$的解，$\eta_2$是$AX=0$的解，那么$\eta_1 + \eta_2$还是$AX=B$的解 ~我们遇到什么困难也不要怕，微笑着面对它！消除恐惧的最好办法就是面对恐惧！坚持就是胜利！加油！奥利给！~ 【其他文章·线性代数·微积分】 线性方程组章节总结 矩阵章节总结 行列式章节总结 常用泰勒展开式 高阶求导公式 高等数学公式 常用等价无穷小 导数基本公式 不定积分公式]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模式匹配算法：KMP算法]]></title>
    <url>%2FG-SS-Hacker.github.io%2FKMP%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[模式匹配算法：KMP算法 图：北京航空航天大学 Guderian出品 模式匹配是数据结构中字符串的一种基本运算，给定一个字符串P，要求在某个字符串T中找出与字符串P相同的所有子串，这就是模式匹配。 模式匹配算法要解决的问题 detection ：P是否出现 location ：首次在哪里出现 counting ：共有几次出现 enumeration ：各出现在哪里？ 绪论KMP算法（全称Knuth-Morris-Pratt算法）是一种高效的模式匹配算法。在模式匹配算法中，常见的算法包括BF算法（朴素算法）、KMP算法、BM算法、RK算法、有限自动机算法、Horspool算法、Sunday算法。在这些算法中，最经典的算法非KMP算法和BM算法莫属。这两种算法都有一个共同点：抽象，理解难度大。实际上，KMP算法还有一个明显特点：会者不难。本文内容默认你已经明白BF算法的原理和不足（因此这部分内容将简单略过），展开讲述KMP算法的原理、优点和c++代码实现。相信你在学会KMP算法之后将会有一种“踏遍青山人未老，这边风景独好”的快意。让我们开始吧。 BF算法BF算法的本质就是暴力搜索。既然要在串T中找出与串P相同的所有子串，那不妨找出串T中所有与串P长度相同的子串，在逐个判断这个子串是否与串P相同。具体的例子点击这里（讲得很形象了，应该不会有理解上的困难）。设strlen(T) == n, strlen(P) == m，则BF算法的预处理时间为$0$，匹配时间为$O(mn)$，总时间复杂度为$O(mn)$（简直是蜗速），在大部分应用场景中并不优秀。 KMP算法更高的效率容易看出BF算法的效率是十分蹩脚的，而它蹩脚的原因也很明显：在一次匹配尝试中，一旦失配（某一位匹配失败），就把串P整体向右移动一位。在模拟算法运行过程中，我们发现如果开始匹配时第一位就失配，那么只向右移动一位的确无可厚非，毕竟说不定移动一位之后就会匹配成功呢；但是如果已经匹配了串P的一部分了才失配，在向右移动一位之后，有时候（而且往往是经常）我们发现依然注定会匹配失败，也就是说在上次失败之后，向右移动一位再做尝试是根本不必要的，这种“只移动一位”的策略实际上造成了巨大的步骤浪费。那么有没有办法，把这些不必要的尝试舍弃，节约算法的运行时间呢？ 此处我们需要考虑以下问题，以便对BF算法做出有效的改进： 为什么有一些尝试是注定徒劳的？ 如何判断哪些尝试需要舍弃？ 如果不是向右移动一位，又应该如何确定向右移动的位数？ 在看完点击这里（还是上面那个链接）之后，前两个问题都能得到答案。在链接的视频讲解中，讲述者构造了一个前缀表数组prefix table来确定串P中每个从头开始的子串的最长公共前后缀（自身除外，以下省略此说明），一旦失配，就把串P向右移动到失配位置左侧子串的最长前缀处，使它们重叠，也就是把下图中的1号移动到2号位置，继续从当前位置匹配，如果当前位置为串T的结尾，则结束匹配。 那么问题来了：为什么要把最长公共前缀移动至最长公共后缀的位置？这个移动距离能不能更短？能不能更长？ **引理** 串的**最长公共前后缀**的**最长公共前后缀**是原串的**次长公共前后缀**。 **证明** 略~~（逃~~ 实际上，在BF算法的一次匹配过程中，一旦失配，就把串P整体向右移动一位再次尝试匹配。假设第一次匹配时在串P的第r + 1位失配，此时已经确定串P失配位置的前r项与串T相应位置元素匹配，也确定了串P失配位置的前r - 1项与串T相应位置元素匹配。那么第二次匹配成功，当且仅当在串P的前r项组成的子串中，前r - 1位字符组成的前缀和后r - 1位字符组成的后缀相同，即某一个公共前后缀长度为r - 1。也就是说，如果匹配失败向右移动s位，那么再次匹配成功的必要条件是串P在失配位置前的子串的某一个公共前后缀长度为r - s。如果串P在失配位置前的子串的最长公共前后缀长度就是r - s，匹配失败后向右移动了不足s位，这意味着移动距离过短，将会做一遍无用功。 如果移动距离过长，那就有可能会错过一个成功的匹配。如果匹配失败向右移动s位，那么再次匹配成功的必要条件是串P在失配位置前的子串的某一个公共前后缀长度为r - s。注意这里是必要条件而不是充分条件，在把串P向右移动的过程中，并不是在失配位置前随便放一个公共前后缀都能匹配成功，我们需要从最长公共前后缀开始尝试，逐步减少原失配位置前子串的长度，直到匹配成功或者串P在失配位置前子串最长公共前后缀长度变为0。 此处我们引入next[]数组来记录在失配时应该把串P的哪一位移动到当前位置。对于串P的第j + 1位的字符来说，next[j + 1]的意义是由串P的前j项的子串中最长公共前后缀的长度。next[]数组是KMP算法降低时间复杂度的关键，在预处理时就已经确定。下面介绍next[]数组求法。 next数组求法如果你直接跳过了前面看到了这里，那说明你已经看了无数多参考资料，还是搞不懂next[]数组求法的原理，几乎走投无路了。但是，正如B站鬼畜区某神所言： ~我们遇到什么困难也不要怕，微笑着面对它！消除恐惧的最好办法就是面对恐惧！坚持就是胜利！加油！奥利给！~ 回到正题。 先考虑求next[]数组的朴素算法：我们要求一个长度为l的串S的最长公共前后缀，因为自身除外，所以把串S复制一遍，产生一个串S&#39;，并让串S&#39;的第1位对齐串S的第2位，尝试匹配剩余l - 1位。若匹配成功，则剩余l - 1位就是串P的最长公共前后缀；若匹配失败，则把串S&#39;向右移动1位，再次尝试，知道匹配成功或串S&#39;已被移出串S的范围之内。 等一等，为什么这波操作如此熟悉？（战术后仰 是的，这就是所谓的“串P匹配自身”，有没有办法可以优化以上的朴素算法呢？ 我们的任务是求出串P每一个由前j项元素组成的子串的最长公共前后缀的长度。假设串P从字符串下标1开始存储，规定next[1] = 0，并从第2位开始匹配。设用串P&#39;匹配串P，当前匹配位置是串P&#39;的第j + 1位，串P的第i位，如果失配，那么处理方法同上面介绍的一样，把串P&#39;向右移动到失配位置左侧子串的最长前缀处，即令j = next[j]（思想：回溯），使它们重叠，即把下图中的1号移动到2号位置，继续从当前位置匹配；如果第j + 1位匹配成功，则更新串P前i位元素组成的子串的最长公共前后缀的长度为j，即令next[i] = j。 你已经明白了KMP算法的原理，那么不难推算出KMP算法的时间复杂度：预处理时间为$\Theta(m)$，匹配时间为$\Theta(n)$，总时间复杂度为$\Theta(m+n)$。与BF算法相比，KMP算法是一种优秀的模式匹配算法。 伪代码123456789101112131415161718192021222324252627282930KMP-MATCHER(T, P)n = T.lengthm = P.lengthnext = COMPUTE-PREFIX-FUNCTION(P)j = 0for i = 1 to n while j &gt; 0 and P[j + 1] != T[i] j = next[j] if P[j + 1] == T[j] j = j + 1 if j == m print "Pattern occurs with shift" i - m j = next[j] COMPUTE-PREFIX-FUNCTION(P)m = P.lengthlet next[1..m] be a new arraynext[1] = 0j = 0for i = 2 to m while j &gt; 0 and P[j + 1] != T[i] j = next[j] if P[j + 1] == T[j] j = j + 1 next[i] = jreturn next 例题：KMP算法模版题目描述输入两个字符串$s1$和$s2$（皆从下标为$1$处开始存储），$s2$为$s1$的子串，输出$s2$在$s1$中所有出现位置的下标。 输入格式第一行为$s1$，第二行为$s2$ 输出格式每行一个正整数表示s2在s1中出现的位置 输入样例12123456123123 输出样例1217 说明/提示 $s1$和$s2$的长度在$1000000$之内 运行速度不能太慢 解题方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//Presented by G-SS-Hacker//cc BY-NC-SA 4.0//Run on C++#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int MAXN = 1000000 + 100;const int MAXM = 1000000 + 100;//next,x0,x1,y0,y1,index cannot be named to variablesint nxt[MAXM]; //nxt[i]表示字串1到i最长公共前后缀的长度int len1, len2;char s1[MAXN], s2[MAXM];void pre()&#123; for(int j = 0, i = 2; i &lt;= len2; i++) &#123; while(j &amp;&amp; s2[i] != s2[j + 1]) j = nxt[j]; if(s2[i] == s2[j + 1]) j++; nxt[i] = j; &#125;&#125;void kmp()&#123; for(int j = 0, i = 1; i &lt;= len1; i++) &#123; while(j &amp;&amp; s1[i] != s2[j + 1]) j = nxt[j]; if(s1[i] == s2[j + 1]) j++; if(j == len2) cout &lt;&lt; i - len2 + 1 &lt;&lt; endl, j = nxt[j]; &#125;&#125;int main()&#123; cin &gt;&gt; s1 + 1 &gt;&gt; s2 + 1; len1 = strlen(s1 + 1); len2 = strlen(s2 + 1); pre(); kmp(); return 0;&#125; 结束语~我们遇到什么困难也不要怕，微笑着面对它！消除恐惧的最好办法就是面对恐惧！坚持就是胜利！加油！奥利给！~ 【其他文章·数据结构】 拓扑排序 图的表示 数据结构绪论]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C-plus-plus</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用泰勒展开式]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E5%B8%B8%E7%94%A8%E6%B3%B0%E5%8B%92%E5%B1%95%E5%BC%80%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[常用泰勒展开 Guderian出品 $(1)e^x=1+e+\frac{e^2}{2!}+\dots +\frac{e^n}{n!}+\frac{e^\theta x}{(n+1)!}x^{n+1}$ $(2)\sin x=x-\frac{x^3}{3!}+\frac{x^5}{5!}-\dots+(-1)^m\frac{x^{2m+1}}{(2m+1)!}+(-1)^{m+1}\frac{\cos \theta x}{(2m+3!)}x^{2m+3}$ $(3)\cos x=1-\frac{x^2}{2!}+\frac{x^4}{4!}-\dots+(-1)^m\frac{x^{2m}}{(2m)!}+(-1)^{m+1}\frac{\cos \theta x}{(2m+2)!}x^{2m+2}$ $(4)\ln(1+x)=x-\frac{x^2}{2}+\frac{x^3}{3}-\dots+(-1)^{n-1}\frac{x^n}{n}+(-1)^n\frac{x^{n+1}}{(n+1)(1+\theta x)^{n+1}}$ $(5)(1+x)^\alpha=\sum_{k=0}^n C_\alpha^n x^n+C_\alpha^{n+1}x^{n+1}(1+\theta x)^{\alpha -n-1}$ ~我们遇到什么困难也不要怕，微笑着面对它！消除恐惧的最好办法就是面对恐惧！坚持就是胜利！加油！奥利给！~]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵章节总结]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E7%9F%A9%E9%98%B5%E7%AB%A0%E8%8A%82%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[矩阵章节总结 Guderian出品 矩阵（matrix）形式优美，应用广泛。但是笔者相当头痛矩阵问题。实际上，矩阵的计算绝对不能靠硬算（硬算的事交给Matlab就好了，实际上计算机做矩阵运算，为了避免数值不稳定问题，使用的是和人计算不同的算法），而是灵活变形后运用基本的计算公式；矩阵的证明则更离不开对公式及其推论的灵活运用。笔者从题海中抽象出矩阵计算的常用思想和性质。作者实属菜鸟，水平很菜，将就看看吧 ╮(╯_╰)╭ 运算律 $ {AB}= {BA}$时，矩阵运算满足交换律，故以下运算皆成立 $(\mathrm{i})( {A}\pm {B})^2= {A}^2 \pm 2 {AB} + {B}^2$ $(\mathrm{ii})( {A}+ {B})( {A}- {B})= {A}^2- {B}^2$ $(\mathrm{iii})( {AB})^2=( {BA})^2$ $ {A}^*， {A}’， {A}^{-1}$组合会产生十分令人头疼的问题，使用以下公式来缓解头疼 $(\mathrm{i})( {AB})’= {B}’ {A}’$ $(\mathrm{ii})( {AB})^{-1}= {B}^{-1} {A}^{-1}$ $(\mathrm{iii})( {A}^*)^{-1}=( {A}^{-1})^*$ 带系数的情况 $(\mathrm{i})|k {A}|=k^n| {A}|$ $(\mathrm{ii})(k {A})^{-1}=\frac1{k} {A}^{-1}$ $(\mathrm{iii})(k {A})’=k {A}’$ $(\mathrm{iv})\overline{k {A}}=\overline{k}\overline{ {A}}$ 共轭矩阵记住以下四个公式，以备突然考到 $(\mathrm{i})\overline{ {A}+ {B}}=\overline{ {A}}+\overline{ {B}}$ $(\mathrm{ii})\overline{k {A}}=\overline{k}\overline{ {A}}$ $(\mathrm{iii})\overline{ {AB}}=\overline{ {A}}\overline{ {B}}$ $(\mathrm{iv})|\overline{ {A}}|=\overline{| {A}|}$ 简单地记，凡是涉及共轭的题目，计算的时候看起来能取共轭的都取共轭 伴随矩阵 看到$ {A}^*$，以下公式至少用其一 $(\mathrm{i}) {A}^* {A}= {A} {A}^*=| {A}| {E}$ $(\mathrm{ii}) {A}^{-1}=\frac{ {A}^*}{| {A}|}$ $(\mathrm{iii})| {A}^*|=| {A}|^{n-1}$ $(\mathrm{iv})( {A}^*)^*=| {A}|^{n-2} {A}$ 伴随矩阵的特殊性质：极端的伴随矩阵 {R}({A}^*)=\begin{cases} n,\quad {R}({A})=n\\ 1,\quad {R}({A})=n-1\\ 0,\quad {R}({A})]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[行列式章节总结]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E8%A1%8C%E5%88%97%E5%BC%8F%E7%AB%A0%E8%8A%82%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[行列式章节总结 图：刺客伍六七 Guderian出品 行列式形式优美，应用广泛。但是笔者相当头痛行列式的计算问题和行列式等式的证明问题。为了让行列式计算与证明不那么难算，笔者从题海中抽象出行列式计算和证明的常用算法和性质。作者水平不高，将就看看吧 ╮(╯_╰)╭ 行列式计算公式1.行列式定义 \left|\begin{array}{cccc} a_{11} & a_{12} & \dots & a_{1n}\\ a_{21} & a_{22} & \dots & a_{2n}\\ \vdots & \vdots & & \vdots\\ a_{n1} & a_{n2} & \dots & a_{nn}\\ \end{array}\right| = \sum(-1)^{t(p_1p_2\dots p_n)}a_{p_11}a_{p_22}\dots a_{p_nn}特别地，对于二阶和三阶行列式，可直接用对角线法则求出结果。 2.行列式展开定理 引理 如果$n$阶行列式$D$中第$i$行（列）所有元素除$a_{ij}$外都是零，那么，$D$等于$a_{ij}$与它的代数余子式$A_{ij}$的乘积，即$D=a_{ij}A_{ij}$。 展开定理 行列式等于它的任一行（列）的各元素与其代数余子式的乘积之和，即 D=a_{i1}A_{i1}+a_{i2}A_{i2}+\dots a_{in}A_{in},\quad i=1,2,\dots,n;\\ D=a_{1j}A_{1j}+a_{2j}A_{2j}+\dots a_{nj}A_{nj},\quad j=1,2,\dots,n.推论 行列式$D$的任一行（列）元素与另一行（列）对应元素的代数余子式乘积之和等于$0$，即 a_{i1}A_{j1}+a_{i2}A_{j2}+\dots a_{in}A_{jn}=0,\quad i \ne j,\quad i,j=1,2,\dots ,n;\\ a_{1i}A_{1j}+a_{2i}A_{2j}+\dots a_{ni}A_{nj}=0,\quad i \ne j,\quad i,j=1,2,\dots ,n.行列式结果等于$0$的定理常用于填空题和判断题。 3.范德蒙定理 范德蒙定理的证明用到了第二数学归纳法，在行列式和矩阵中，任何看起来可以用数学归纳法证明的题目（甚至包括一部分计算题），都可以用数学归纳法来做。 D_n= \left|\begin{array}{cccc} 1 & 1 & \dots & 1\\ x_1 & x_2 & \dots & x_n\\ x_1^2& x_2^2& \dots & x_n^2\\ \vdots & \vdots & & \vdots\\ x_1^{n-1} & x_2^{n-1} & \dots & x_n^{n-1}\\ \end{array}\right| = \prod_{1\leq j]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高阶求导公式]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E9%AB%98%E9%98%B6%E6%B1%82%E5%AF%BC%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[高阶求导公式 Guderian出品 $ (1)(a^x)^{(n)}=a^x (\ln a)$ $ (2)(e^{ax})^{(n)} = a^n e ^{ax} $ $(3)(\sin x)^{(n)}=\sin(x+\frac {n\pi}2)$ $(4)(\cos x)^{(n)}=\cos(x+\frac{n\pi}2)$ $(5)(x^a)^{(n)}=a(a-1)\dots(a-n+1)x^{a-n},若n&gt;a，则导数等于零$ $(6)[\ln (x+a)]^{(n)}=(-1)^n \frac{(n-1)!}{(x+a)^n}，特别地，令a=0，(\ln x)^{(n)}=(-1)^n\frac{(n-1)!}{x^n}$ $(7)(\frac1{ax+b})^{(n)}=(-a)^{n} \frac{n!}{(ax+b)^{n+1}}，特别地，令a=1,(\frac1{x+b})=(-1)^n \frac{n!}{(x+b)^{n+1}}$ $(8)Leibniz公式：[f(x)g(x)]^{(n)}=\sum_{k=0}^n C_n^kf^{(k)}(x)g^{(n-k)}(x)，C_n^k=\frac{n!}{k!(n-k)!)}$ $(9)(f(x)\pm g(x))^{(n)}=f^{(n)}(x)+g^{(n)}(x)$ $(10)(af(x))^{(n)}=af^{(n)}(x)$]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拓扑排序]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[拓扑排序 图：索菲亚教堂 Guderian出品 拓扑是研究几何图形或空间在连续改变形状后还能保持不变的一些性质的一个学科。它只考虑物体间的位置关系而不考虑它们的形状和大小。 AOV网在工程领域，一个大规模工程常被拆分为多个子工程，这些子工程被称为活动（Activity），在有向图中以顶点（Vertex）表示活动，以有向边表示活动之间的先后关系，这样的有向图被称为AOV网（Activity On Vertex Network）。在AOV网中，如果出现了闭环，就意味着有若干个活动将被无限次重复，工程将永远无法完成；因此，一个具有实用价值的AOV网，必定是一个有向无环图（DAG，Directed Acyclic Graph）。 绪论对于一个有向无环图$G=(V,E)$，其拓扑排序是其上顶点的一个线性排序：对于有向边$(u,v)\in E$，顶点$u$在排序中在顶点$v$的前面（如果$G$包含环路，则不可能产生一个线性排序）。可以将$G$上各顶点在一条水平线上从左向右排开，且图的所有边的指向也都是从左向右。拓扑排序并未各顶点上的排序，而是各顶点逻辑上的排序，这种排序可能有不止一种。在工程上，常把一个大规模工程的各个子工程抽象为一个AOV网，用拓扑排序解决工程的调度问题。下面用一个示例说明拓扑排序的具体应用： 下图（a）表示的是某教授每天早上从起床后到上班前所发生的事情的AOV网。教授必须先完成某些活动，才能完成某些活动；而另一些活动则可以以任意次序完成。在图（a）中，有向边$(u,v)$表示的就是活动$u$必须在活动$v$前完成。图（b）将拓扑排序后的有向无环图在一条水平直线上展示出来。如图（b）所示，该有向无环图所有边的指向都是从左到右。 （a） （b） 拓扑排序算法1. 基于入度的拓扑排序基于入度的拓扑排序算法，又被称为Kahn算法。以下摘选维基百科上关于Kahn算法的伪代码： 12345678910111213141516//TOPOLOGICAL-SORT(G)L ← Empty list that will contain the sorted elementsS ← Set of all nodes with no incoming edgeswhile S is non-empty do remove a node u from S insert u into L for each node v with an edge e from u to v do remove edge e from the graph if v has no other incoming edges then insert v into Sif graph has edges then return error (graph has at least onecycle)else return L (a topologically sortedorder) Kahn算法的基本思想是“走一步，看一步”。从以上伪代码不难看出Kahn算法的步骤：先统计所有顶点的入度，再把入度为零的顶点从图中分离出来，先放在集合$S$中，再从集合$S$中分别取出顶点放入线性表$L$中，然后把这个顶点指向的所有顶点的入度减1，并删除该顶点及所有与其相连的边。重复上述操作，直到所有顶点都被分离出来。若当集合$S$为空集时，线性表$L$中元素个数等于原来图中顶点的个数，则返回$L$，$L$中元素的排列即为该图的一种拓扑排序；若当集合$S$为空集时，线性表$L$中元素个数不等于原来图中顶点的个数，则意味着图中有闭环，返回错误信息，对图进行修改后再进行下一次拓扑排序。 对于图（a）的例子，首先我们找到入度为零的顶点有“刷牙”和“喂猫”，则把这两个顶点放入集合$S$中，$S=\{“刷牙”, “喂猫”\}$，$L=\varnothing$。 第一步、在$S$中选取”刷牙“并把该顶点从$S$中删除并放入线性表$L$中，”刷牙“与”洗脸“相连，删除相连的边，”洗脸“的入度减1，新的入度为0，把”洗脸“也放入$S$中。此时$S=\{“洗脸”, “喂猫”\}$，$L=“刷牙”$。 第二步、在$S$中选取“洗脸”并把该顶点从$S$中删除并放入线性表$L$中，“洗脸”与“吃饭”“更衣”相连，删除相连的边，”吃饭““更衣”的入度减1，新的入度为0，把”吃饭“”更衣“也放入$S$中。此时$S=\{“吃饭”, “更衣”, “喂猫”\}$，$L=“刷牙”\to“洗脸”$。 以此类推，第三步到第五步的结果分别如图（3）（4）（5）所示（第六步时$G=\varnothing$），采用同样的步骤，直至$S=\varnothing$，算法结束。 （3） （4） （5） 2. 基于深度优先搜索的拓扑排序基于深度优先搜索的拓扑排序算法同样见以下维基百科上关于该算法的伪代码： 1234567891011121314//TOPOLOGICAL-SORT(G)L ← Empty list that will contain the sorted nodesS ← Set of all nodes with no outgoing edgesfor each node v in S do visit(v) function visit(node v) if v has not been visited yet then mark v as visited for each node u with an edge from u to v do visit(u) add v to L 这个算法的过程非常直观：先把出度为零的顶点从图中分离出来，放在集合$S$中，再从集合$S$中分别取出顶点，递归访问其父顶点，若该顶点未被访问，则标记为“已访问”；到达递归基础后，将当前顶点放入线性表$L$中，并逐步回溯。 下证基于DFS的拓扑排序算法生成的是有向无环图的拓扑排序： 在有向无环图$G=(V,E)$上运行DFS，只需证明对于任意一对顶点$(u,v)\in E$，$u$的返回在$v$之前即可。 对边$(u,v)\in E $，在调用DFS(v)时，对于即将访问的$u$，不外乎以下两种情况： DFS(u)未被调用，即$u$未被mark，在当前路搜索路径的DFS树上，$u$是$v$的子节点。 DFS(u)已被调用，即$u$已被mark，则可知DFS(u)在另一条已经完成的搜索路径上返回。 对于这两种情况，$u$的返回都在$v$之前，得证。 例题：任务排序问题题目描述假定你需完成$n$项任务，这些任务之间并非独立，一项任务的执行当且仅当其所有前置任务已经被全部完成。 输入格式输入的数据包含若干组样例，每个样例的第一行包括两个整数$n$和$m$。$n$是任务的数量，$m$是任务之间先后关系的数量。接下来有$m$行，每行有两个整数$i$和$j$，表示任务$i$的执行必须在任务$j$之前。 输入结束的标志是一组$n=m=0$的样例。 输出格式对于每一组样例，在一行内输出$n$个整数，每两个整数之间用一个空格隔开，每一行数据表示一种可行的任务排序方案。 输入样例1234565 41 22 31 31 50 0 输出样例11 4 2 5 3 说明/提示$1 \leq n \leq 100$ 解题方法解法一、Kahn算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//Run on C++#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int MAXN = 110, MAXM = 110 * 110 / 2;struct edge&#123; int v, nxt;&#125;E[MAXM];queue &lt;int&gt; q;int n, m, cnt;int head[MAXN], in[MAXN];void addedge(int u, int v)&#123; E[++cnt].v = v; E[cnt].nxt = head[u]; head[u] = cnt;&#125;void init()&#123; cnt = 0; memset(head, 0, sizeof(head)); memset(E, 0, sizeof(E));&#125; int main()&#123; cin &gt;&gt; n &gt;&gt; m; while(n || m) &#123; init(); for(int i = 1; i &lt;= m; i++) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; addedge(u, v); in[v]++; &#125; for(int i = 1; i &lt;= n; i++) if(!in[i]) q.push(i); while(!q.empty()) &#123; int cur = q.front(); q.pop(); cout &lt;&lt; cur &lt;&lt; " "; for(int i = head[cur]; i; i = E[i].nxt) if(!--in[E[i].v]) q.push(E[i].v); &#125; cout &lt;&lt; endl; cin &gt;&gt; n &gt;&gt; m; &#125; return 0;&#125; 解法二、DFS1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//Run on C++#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int MAXN = 110, MAXM = 110 * 110 / 2;struct edge&#123; int u, nxt;&#125;E[MAXM];queue &lt;int&gt; q;int n, m, cnt;int head[MAXN], out[MAXN];bool flag[MAXN];void addedge(int u, int v)&#123; E[++cnt].u = u; E[cnt].nxt = head[v]; head[v] = cnt;&#125;void init()&#123; cnt = 0; memset(head, 0, sizeof(head)); memset(E, 0, sizeof(E)); memset(out, 0, sizeof(out)); memset(flag, 0, sizeof(flag));&#125; void dfs(int V)&#123; if(!flag[V]) &#123; flag[V] = true; for(int i = head[V]; i; i = E[i].nxt) dfs(E[i].u); cout &lt;&lt; V &lt;&lt; " "; &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; while(n || m) &#123; init(); for(int i = 1; i &lt;= m; i++) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; addedge(u, v); out[u]++; &#125; for(int i = 1; i &lt;= n; i++) if(!out[i]) q.push(i); while(!q.empty()) &#123; dfs(q.front()); q.pop(); &#125; cout &lt;&lt; endl; cin &gt;&gt; n &gt;&gt; m; &#125; return 0;&#125;]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C-plus-plus</tag>
        <tag>算法</tag>
        <tag>排序</tag>
        <tag>数据结构</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高等数学公式]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[高等数学公式 Guderian出品 立方公式1.立方和公式$a^3+b^3=(a+b)(a^2-ab+b^2)$ 2.立方差公式$a^3-b^3=(a-b)(a^2+ab+b^2)$ 3.三项立方和公式$a^3+b^3+c^3-abc=(a+b+c)(a^2+b^2+c^2-ab-bc-ac)$ 4.完全立方和公式$(a+b)^3=a^3+3a^2b+3ab^2+b^3$ $(a-b)^3=a^3-3a^2b+3ab^2-b^3$ 5.立方和累加$1^3+2^3+\ldots +n^3=[\frac{n(n+1)}{2}]^2=(1+2+\ldots+n)^2$ 和差化积公式$\sin \alpha+\sin \beta=2\sin \frac{\alpha+ \beta}{2} \cos \frac{\alpha- \beta}{2}$ $\sin \alpha-\sin\beta=2\cos \frac{\alpha+ \beta}{2}\sin \frac{\alpha- \beta}{2}$ $\cos \alpha+\cos \beta=2\cos \frac{\alpha + \beta}{2}\cos \frac{\alpha- \beta}{2}$ $\cos \alpha - \cos \beta=-2\sin \frac{\alpha+ \beta}{2}\sin \frac{\alpha- \beta}{2}$ 积化和差公式$\sin \alpha \sin \beta=\frac12[\sin(\alpha + \beta)+\sin(\alpha - \beta)]$ $\sin \alpha \cos \beta=\frac12[\sin(\alpha + \beta)-\sin(\alpha - \beta)]$ $\cos \alpha \sin \beta=\frac12[\cos(\alpha + \beta)+\cos(\alpha - \beta)]$ $\cos \alpha \cos \beta=\frac12[cos(\alpha + \beta)-cos(\alpha - \beta)]$ 万能公式$\sin \theta=\frac{2\tan \frac{\theta}{2}}{1+\tan^2\frac{\theta}{2}}$ $\cos \theta=\frac{1-\tan^2\frac{\theta}{2}}{1+\tan^2\frac{\theta}{2}}$ $\tan \theta=\frac{2\tan \frac{\theta}{2}}{1-\tan^2 \frac{\theta}{2}}$ ​ 平方和拓展$1^2+2^2+\ldots+n^2=\frac1{6}n(n+1)(2n+1)$ $1\times2+2\times3+\ldots+n(n+1)=n(n+1)(n+2)$ 裂项相消$\frac1{n(n+1)(n+2)}=\frac12[\frac1{n(n+1)}-\frac1{(n+1)(n+2)}]$]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用等价无穷小]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E5%B8%B8%E7%94%A8%E7%AD%89%E4%BB%B7%E6%97%A0%E7%A9%B7%E5%B0%8F%2F</url>
    <content type="text"><![CDATA[常用等价无穷小 Guderian出品 基础版当$x\to0$时， $(1)\sin x \sim x$ $(2)\tan x \sim x$ $(3)\arcsin x \sim x$ $(4)\arctan x \sim x$ $(5)1-\cos x \sim \frac12 x^2$ $(6)a^x-1 \sim x \ln a$ $(7)e^x-1 \sim x$ $(8)(1+x)^a-1 \sim ax$ * $(9)\ln (1+x) \sim x$ $(10)\sqrt{1+x}-1 \sim \frac12x$ 进阶版当$x\to0$时， $(11)\log_a(1+x) \sim \frac{x}{\ln a}$ $(12)\sqrt[n]{1+x}-1\sim \frac{x}{n}$ $(13)x-\sin x\sim \frac16x^3$ $(14)\tan x-x\sim\frac13x^3$ $(15)\arcsin x-x\sim\frac16x^3$ $(16)x-\arctan x\sim \frac13x^3$ $(17)\tan x-\sin x\sim \frac12x^3$ *. 见Bernoulli不等式：$(1+x)^n \ge 1+nx$ &#8617;]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[导数基本公式]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E5%AF%BC%E6%95%B0%E5%9F%BA%E6%9C%AC%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[导数基本公式 Guderian出品 $(1)(C)’ = 0$ $(2)(x^a)’=ax^{a-1}$ $(3)(a^x)’=a^x\ln a (a&gt;0且a\not=1)$ $(4)(e^x)’=e^x$ $(5)(\log_ax)’=\frac{1}{x\ln a}(a&gt;0且a\not=1)$ $(6)(\ln x)’=\frac1{x}$ $(7)(\sin x)’=\cos x$ $(8)(\cos x)’=-\sin x$ $(9)(\tan x)’=\frac1{\cos^2x}=\sec^2x$ $(10)(\cot x)’=\frac1{-\sin^x}=-\csc^2x$ $(11)(\sec x)’=\sec x\tan x$ $(12)(\csc x)’=-\csc x\cot x$ $(13)(\arcsin x)’=\frac1{\sqrt{1-x^2}}$ $(14)(\arccos x)’=-\frac1{\sqrt{1-x^2}}$ $(15)(\arctan x)’=\frac1{1+x^2}$ $(16)(\mathrm{arccot} x)’=-\frac1{1+x^2}$]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图的表示]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[图的表示 Guderian出品 绪论对于图 $G=(V,E)$ 1，可以用多种表示方法来表示，其中不同的表示方法分别适用与不同特点的图和对图进行不同的操作。在此介绍三种图的表示方法：邻接表、邻接矩阵和边集数组，并将呈现三种存图方法的C和C++代码实现。 存图方法1.邻接矩阵邻接矩阵是一种简单、易用但有较大局限性的存图方式。由于图是由点集和边集两部分组成，难以找到一种线性结构来同时表示两者，那么，由于每条特定的边都可由其两端顶点唯一确定（假设无重边），我们很自然地可以想到使用一个$|V|$ $*$ $|V|$的方矩阵$A = (a_{ij})$来表示，对于无权图，该矩阵满足： a_{ij} = \left\{ \begin{array}{} 1, \ (i, j) \in E\\ 0, \ (i, j) \notin E \end{array} \right.对于带权图，该矩阵满足： a_{ij} = \left\{ \begin{array}{} w, \ (i, j) \in E\\ \infty \ or \ 0\ or-1, \ (i, j) \notin E \end{array} \right. 【例1】 无向带权图示例如下图所示： 上图对应的邻接矩阵表示如图： \mathbf{A} =\left( \begin{array}{ccc}a_{11} & a_{12} & a_{13} & a_{14} \\\\a_{21} & a_{22} & a_{23} & a_{24} \\\\a_{31} & a_{32} & a_{33} & a_{34} \\\\a_{41} & a_{42} & a_{43} & a_{44}\end{array} \right)\mathbf{} =\left( \begin{array}{ccc}\infty & 4 & 5 & 7 \\\\4 & \infty & 2 & 2 \\\\5 & 2 & \infty & 3 \\\\7 & 2 & 3 & \infty\end{array} \right) 123456789//Run on C/C++const int n = 4; //n个顶点const int inf = 0x3f3f3f3f; //正无穷int G[n][n] = &#123; &#123;inf, 4, 5, 7&#125;, &#123;4, inf, 2, 2&#125;, &#123;5, 2, inf, 3&#125;, &#123;7, 2, 3, inf&#125;&#125;; 【例2】 有向带权图示例如下图所示： 上图对应的邻接矩阵表示如图： \mathbf{A} =\left( \begin{array}{ccc}a_{11} & a_{12} & a_{13} & a_{14} \\\\a_{21} & a_{22} & a_{23} & a_{24} \\\\a_{31} & a_{32} & a_{33} & a_{34} \\\\a_{41} & a_{42} & a_{43} & a_{44}\end{array} \right)\mathbf{} =\left( \begin{array}{ccc}\infty & 4 & 5 & 7 \\\\0 & \infty & 2 & 2 \\\\0 & 0 & \infty & 3 \\\\0 & 0 & 0 & \infty\end{array} \right) 123456789//Run on C/C++const int n = 4; //n个顶点const int inf = 0x3f3f3f3f; //正无穷int G[n][n] = &#123; &#123;inf, 4, 5, 7&#125;, &#123;0, inf, 2, 2&#125;, &#123;0, 0, inf, 3&#125;, &#123;0, 0, 0, inf&#125;&#125;; 【例1】【例2】分别给出了无向无权图和有向无权图的邻接矩阵表示，不管一个图有多少条边，邻接矩阵的空间复杂度都为$O(V^2)$。 不难看出，无向图的邻接矩阵是一个对称矩阵。由于在无向图中，边$(u,v)$与边$(v,u)$表示同一条边，无向图的邻接矩阵$A$就是自己的转置，即$A = A^T$。在存储时，可以只存放主对角线及其以上的这部分邻接矩阵（即半个矩阵），从而将图存储空间需求减少几乎一半。 邻接矩阵表示简单、容易理解，对已知的边操作的效率高（插入、删除、查询的时间复杂度都是$O(1)$。但是邻接矩阵的缺陷在于其空间复杂度巨大，在稠密图上邻接矩阵可以取得较好的利用率，但是在稀疏图 2上使用邻接矩阵将会造成大量内存空间的浪费，很容易导致内存溢出。因此，在使用邻接矩阵存图时一定要格外注意内存空间的限制，不可盲目追求简单而忽略了内存空间的优化。 2.邻接表邻接表是一种具有高度鲁棒性 3、适用于大多数情况的存图方法。对于图$ G = (V,E)$，其邻接表表示由一个包含$|V|$条链表的数组Adj[] 4所构成，每个顶点有一条链表。对于每个顶点$u\in V$，邻接表Adj[u]包含所有与顶点$u$之间有边相连的顶点$v$，即Adj[u]包含图$G$中所有与$u$邻接的顶点。邻接表本质上是使用链表存边，一条链表代表着一个点发出的所有边，通过链表存储和遍历和一个顶点相连的所有边，并根据实际应用情况选择是否存储边权。在C/C++中，实现邻接表的方法主要有两种：链式向前星和vector存图。 【例3】 有向带权图示例如下图所示： 上图对应的邻接表表示如图： 链式向前星存图法是利用了一种特殊的链表，这种链表具有普通链表链式存储的特征，但其插入新元素的方式却是“向前星”，即从链表表头插入元素，每次只更新表头，因此得名链式向前星。在使用链式向前星时，应很好的理解这种数据结构与普通链表的区别。 123456789101112131415161718192021222324252627282930313233//链式向前星//Run on C/C++#include&lt;iostream&gt;using namespace std;const int n = 4, m = 6; //n个顶点，m条边struct edge&#123; int w, v, nxt; //nxt指向同一个顶点发出的另一条边&#125;E[n];int cnt = 0;int head[m]; //假设从0号顶点开始存储void add(int u, int v, int w) //改变编号为cnt的边&#123; E[++cnt].v = v; //出边指向v E[cnt].w = w; //记录边权 E[cnt].nxt = head[u]; //将其指向目前链表的表头（重要！） head[u] = cnt; //将表头更新为目前的编号（重要！）&#125;int main()&#123; add(1, 2, 4); add(1, 4, 7); add(1, 3, 5); add(3, 4, 3); add(3, 2, 2); add(2, 4, 2); return 0;&#125; vector存图实际上是利用了一个不定长的链表该存储从一个顶点出发的所有边的情况，与普通链表类似，vector也是从链表的尾端进行插入操作，因此vector存图法在理解难度上比链式向前星要简单。然而由于C/C++语言的原因，使用vector存图实际使用的内存比链式向前星的要大，因此内存溢出的风险也会更大。 123456789101112131415161718192021222324252627282930//vector存图，使用stl::pair版//Run on C/C++#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int n = 4; //n个顶点vector&lt;pair&lt;int, int&gt;&gt; E[n + 1]; //int（first）为u，int（second）为vvoid add(int u, int v, int w)&#123; E[u].push_back(&#123;v, w&#125;);&#125;int main()&#123; add(1, 2, 4); add(1, 4, 7); add(1, 3, 5); add(3, 4, 3); add(3, 2, 2); add(2, 4, 2); for(int i = 1; i &lt;= n; i++) for(int j = 0; j &lt;(int)E[i].size(); j++) cout&lt;&lt;i&lt;&lt;" "&lt;&lt;E[i][j].first&lt;&lt;" "&lt;&lt;E[i][j].second&lt;&lt;endl; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435//vector存图，使用结构体版//Run on C/C++#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int n = 4; //n个顶点struct edge&#123; int v, w;&#125;;vector&lt;edge&gt;E[n + 1];void add(int u, int v, int w)&#123; E[u].push_back(&#123;v, w&#125;);&#125;int main()&#123; add(1, 2, 4); add(1, 4, 7); add(1, 3, 5); add(3, 4, 3); add(3, 2, 2); add(2, 4, 2); for(int i = 1; i &lt;= n; i++) for(int j = 0; j &lt;(int)E[i].size(); j++) cout&lt;&lt;i&lt;&lt;" "&lt;&lt;E[i][j].v&lt;&lt;" "&lt;&lt;E[i][j].w&lt;&lt;endl; return 0;&#125; 不管是用链式向前星存图还是vector存图，邻接表的空间复杂度都为$O(E + V)$。与邻接矩阵相比，邻接表的空间复杂度更小，空间利用率更高。但是邻接表使用链式结构存储边，这导致了对边操作的时间复杂度为$O(n)$，因此邻接表并不适用于需要频繁对边操作的情况；对于稠密图，邻接表的性能也不比邻接矩阵更占上风。然而，对于不需要频繁对边进行操作的稀疏图，使用邻接表存图比使用邻接矩阵存图可以期待更高的效率。综上，邻接表不失为一种性能优秀的存图方法。 3.边集数组边集数组也是一种简单、易用但有较大局限性的存图方式。边集数组由一个一维结构体数组e[]构成，数组的每个数据元素由一条边的起点下标（u），终点下标（v）和权值（w）组成，如下图所示。不难看出，边集数组关注边的集合，而不关注点的集合。因此，使用这种存图方法在需要遍历图的边集时可以获得很高的效率，但是在遍历图的点集时效率简直是灾难。不论一个图有多少个顶点，边集数组的空间复杂度都为$O(E)$。 【例4】 有向带权图示例如下图所示： 上图对应的边集数组如下表所示： u v w e[1] 1 2 4 e[2] 1 4 7 e[3] 1 3 5 e[4] 3 4 3 e[5] 3 2 2 e[6] 2 4 2 12345678910111213141516//Run on C/C++const int m = 6; //m条边struct edge&#123; int u, v, w;&#125;;edge E[m] = &#123; &#123;1, 2, 4&#125;, &#123;1, 4, 7&#125;, &#123;1, 3, 5&#125;, &#123;3, 4, 3&#125;, &#123;3, 2, 2&#125;, &#123;2, 4, 2&#125;&#125;; 据观察，这种存图方法主要用于实现最小生成树的Krusal算法，其他情况下较少使用。 1. 图，graph，记为“G”；顶点，vertex，记为“V”；边，edge，记为“E”。 &#8617; 2. 稠密图与稀疏图的判断标准：(1)定性分析：稠密图的边数非常接近于完全图（即$n(n-1)$），而稀疏图的边数比完全图少得多。(2)定量分析：边数多于$nlogn$的图为稠密图，边数少于$nlogn$的图为稀疏图。 &#8617; 3. 鲁棒性，robust，即健壮性 &#8617; 4. 邻接表，adjlist，记为”Adj” &#8617;]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C-plus-plus</tag>
        <tag>C</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法性能比较]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[排序算法性能比较 Guderian出品 .tg {border-collapse:collapse;border-spacing:0;}.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg .tg-cly1{text-align:left;vertical-align:middle}.tg .tg-0lax{text-align:left;vertical-align:top} 类别 排序方法 时间复杂度 空间复杂度 稳定性 平均情况 最坏情况 插入排序 直接插入 O(n2) O(n2) O(1) 稳定 希尔排序 O(n1.3) O(n2) O(1） 不稳定 选择排序 直接选择 O(n2) O(n2) O(1) 不稳定 堆排序 O(nlogn) O(nlogn) O(1) 不稳定 交换排序 冒泡排序 O(n2) O(n2) O(1) 稳定 快速排序 O(nlogn) O(n2) O(logn) 不稳定 归并排序 O(nlogn) O(nlogn) O(n) 稳定 基数排序 O(d(r+n)) O(d(r+n)) O(r+n) 稳定 桶排序 O(2(m+n)) O(2(m+n)) O(max{key}) 稳定 *注：基数排序中，d表示关键字的位数长度，r表示关键字每一个数位有r中可能的取值 **注：桶排序中，m表示桶的个数]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加密算法]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[加密算法 Guderian出品 加密算法的历史加密算法是一种古老的算法，在人类几千年来的历史进程中，加密算法随着一场场战争的爆发而不断进步，从古罗马时代到第二次世界大战，从凯撒密码到恩尼格玛密码。然而，就像矛和盾的关系一样，加密技术和解密技术也在不断螺旋式发展。下面，笔者将向读者朋友们介绍一种古老的科技：凯撒密码。 在战争中，命令的传递往往需要通过传令兵。如： 后方指挥部 ———传令兵携带命令“攻打X城”———>我方部队可是，一旦传令兵被敌方抓获，重要的军事情报就会泄露给敌方。 后方指挥部—命令“攻打X城”—>敌方部队甚至，敌人可能会篡改命令，并收买传令兵把假情报传给我方部队。 后方指挥部—命令“攻打X城”—>敌方部队—命令“攻打Y城”—>我方部队这样一来，我方部队就会完全落入敌方陷阱中。为了防止这种情况发生，在没有更好的传达命令的方法的情况下，我们不妨修改命令的内容，让敌人即使截获了命令，也无法看懂命令的内容，这就是对信息的加密。 后方指挥部—命令“@#￥！！”—>敌方部队：？？？如何进行加密呢？有一种非常朴素的加密方法叫凯撒密码，它的基本思路就是偏移。 如图所示，图中第一行的字母代表明文，第二行字母代表密文。这个加密算法十分简单，选择一个偏移量，此处是3，把明文当中的所有字母按照字母表的顺序向后偏移三位，从而生成密文。比如： 1234A - &gt; DB - &gt; EC - &gt; FLOL - &gt; MPM 这样一来，就算我军的密码被敌军截获，敌军也无法看懂。一旦我方部队收到了我方的命令，只要逆转原来加密的过程，把密文以偏移量3往左偏移解密为明文，就可以正确收到我方的命令。假设敌军已知我方的加密算法，想要破解，把26个字母都试一遍，终究可以得到正确的原文，这就叫暴力破解。 现代加密算法1.对称加密算法明文--密钥-->密文--密钥-->明文这很好理解，这就好比给你需要传递的信息加上一把锁，这把锁的钥匙只有你和信息接收方拥有，这样就算信息被截获，也只能看出一堆乱码。只要传递方与接收方事先得到一致的密钥，双方就可以安全进行信息往来。 常见的对称加密算法有DES算法和3DES算法，它的基本方法是替换+移位；还有美国联邦政府采用的AES算法；还有RC-5算法和IDEA算法。office Word、Excel、Powerful、pdf、WinRAR的加密算法都属于对称加密算法。 对称加密算法的优点是简单高效，然而缺点却也很明显，那就是安全性低。比如下面这种情况： 你想要给某人通过QQ发送一个加了密的word文档，你发过去了但你的小伙伴打不开，那他当然会向你要密码。为了让他能顺利打开这个文档，你又要给他发送文档的密码。这样一来，你的文档就没有任何安全性可言了。如果你的文档被不怀好意的人截获，那他当然也能截获你的密码。 为了解决对称加密算法安全性低的问题，科学家发明了非对称加密算法。 2. 非对称加密算法明文--公钥-->密文--私钥-->明文 明文--私钥-->密文--公钥-->明文在非对称加密算法中有一对密钥，其中一个叫公钥、另一个叫私钥。如果要加密一个文档，我们既可以用公钥加密文档，用私钥解密文档；也可以用私钥加密文档，用公钥解密文档。最常见的非对称加密算法就是大名鼎鼎的RSA算法，几乎无法破解。 非对称加密算法的缺点是效率低下，然而其优点是安全性极高，解决了对称加密算法的安全性低的问题。比如下面这种情况： 在一间公司中，每一个员工都有自己的一对公钥和私钥，公钥可以交给他人，但是私钥只有自己知道。员工之一的你想要给同样为员工的某人通过QQ发送一个文档，你只需要向接受者索要他的公钥，他就会光明正大地通过QQ发给你，你再利用他的公钥给文档加密，然后光明正大地通过QQ发给他，他接收到你发送的已用他的公钥加密过的文档之后，就可以用他的私钥解密，从而顺利的查看文档了。在这个过程中，就算文档和公钥都被截获，因为没有相应的私钥，也无法正常还原。因此，这个非对称加密算法的安全性比对称加密算法提高了一个等级。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>网络与信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OSI/RM七层模型]]></title>
    <url>%2FG-SS-Hacker.github.io%2FOSIRM%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[OSI/RM = Open System Interconnection Reference Model 计算机网络：OSI/RM七层模型 Guderian出品 在计算机网络建立之初，各大计算机企业之间并没有一套通用的标准来规范计算机网络的建设，相反，各企业在自己的计算机系统上实行自己的标准，这就造成了一种局面：不同品牌计算机之间不能实现互连。要知道互联网建立之初的目的就是让把全世界的计算机连接起来，实现信息共享。这个目标在今天已经基本实现，然而在上个世纪七八十年代，苹果的计算机和IBM的计算机的网路接口都不一样，更不用说两者互连了。这种情况在不同品牌 的计算机之间比比皆是，制约了世界互联网的发展，同时也制约了互联网市场规模的增长。 此时，各计算机企业需要一套公用的标准来规范计算机网络的建设。然而，每一家企业都希望推行自己的标准，不愿意使用别人的标准。正如现在我们所说：“一流的公司定标准。”当别人制定好了标准，你再依据这个标准开发产品的时候，实际上你已经比别人落后了，也就是说标准制定者永远站在领先的位置。各计算机企业争执不下，标准的制定再次陷入僵局。 既然各计算机企业都不愿意放弃自己的标准，使用别人的标准，那么有人提议，我们全部放弃自己的标准，由国际标准化组织（nternational Organization for Standardization, ISO)来制定一套标准，我们就全部采用那套标准。这一提议得到了计算机企业的广泛认可。于是ISO就制定了开放系统互连(OSI)模型，并由全世界的计算机企业以此为标准开发和建立计算机网络。虽然从今天的角度看，这套标准有些繁琐，层次显得太多，但是因为这套标准已经被遵循多年，所以被一直延续了下来，未曾改变。 OSI/RM七层模型 .tg {border-collapse:collapse;border-spacing:0;}.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top} 层次 名称 主要功能 主要设备及协议 7 应用层 实现具体的应用功能 POP3、FTP、HTTP、Telnet、SMTPDHCP、TFTP、SNMP、DNS 6 表示层 数据的格式与表达、加密、压缩 5 会话层 建立、管理和终止对话 4 传输层 端到端的连接 TCP、UDP 3 网络层 分组传输和路由选择 三层交换机、路由器ARP、RARP、IP、ICMP、IGMP 2 数据链路层 传输以帧为单位的信息 网桥、交换机、网卡PPTP、L2TP、SLIP、PPP 1 物理层 二进制传输 中继器、集线器]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows10常用快捷键]]></title>
    <url>%2FG-SS-Hacker.github.io%2FWindows10%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[Life is short, you need shortcuts Windows 10常用快捷键 Guderian出品 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647Windows 徽标键 + I —&gt; 打开“设置”Windows 徽标键 + E —&gt; 打开“文件资源管理器”Windows 徽标键 + D —&gt; 显示和隐藏桌面Windows 徽标键 + L —&gt; 锁定电脑Windows 徽标键 + M —&gt; 最小化所有窗口Windows 徽标键 + R —&gt; 打开“运行”对话框Windows 徽标键 + 逗号 (,) —&gt; 临时快速查看桌面Windows 徽标键 + 数字 —&gt; 打开桌面，并启动固定到任务栏的位于该数字所表示位置的应用。如果该应用已在运行，则切换到该应用。Windows 徽标键 + Tab —&gt; 打开“任务视图”Windows 徽标键 + 向上键 —&gt; 最大化窗口Windows 徽标键 + 向下键 —&gt; 从屏幕中删除当前应用或最小化桌面窗口Windows 徽标键 + 向左键 —&gt; 将应用或桌面窗口最大化到屏幕左侧Windows 徽标键 + 向右键 —&gt; 将应用或桌面窗口最大化到屏幕右侧Alt + Enter —&gt; 打开选定项的“属性”对话框Backspace —&gt; 查看上一个文件夹F2 —&gt; 重命名选定项F3 —&gt; 在文件资源管理器中搜索文件或文件夹Ctrl + X —&gt; 剪切选定项Ctrl + C（或 Ctrl + Insert） —&gt; 复制选定项Ctrl + V（或 Shift + Insert） —&gt; 粘贴选定项Ctrl + Z —&gt; 撤消操作Ctrl + Y —&gt; 重做操作Alt + Tab —&gt; 在打开的应用之间切换Alt + F4 —&gt; 关闭活动项，或者退出活动应用]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Windows10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typora常用快捷键大全]]></title>
    <url>%2FG-SS-Hacker.github.io%2FTypora%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[Life is short, you need shortcuts Typora常用快捷键大全 Guderian出品 .tg {border-collapse:collapse;border-spacing:0;}.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg .tg-m9r4{background-color:#ffffc7;text-align:left;vertical-align:top}.tg .tg-ncd7{background-color:#ffffc7;border-color:inherit;text-align:left;vertical-align:top}.tg .tg-0lax{text-align:left;vertical-align:top}.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top} 操作类型 操作 快捷键 文件操作 新建 Ctrl + N 新建窗口 Ctrl + Shift + N 打开 Ctrl + O 快速打开 Ctrl + P 保存 Ctrl + S 另存为 Ctrl + Shift + S 偏好设置 Ctrl + 逗号 关闭 Ctrl + W 编辑操作 选中当前行/句 Ctrl + L 选中当前格式文本 Ctrl + E 选中当前词 Ctrl + D 查找 Ctrl + F 替换 Ctrl + H 查找下一个 F3 查找上一个 Shift + F3 段落操作 提升标题等级 Ctrl + = 降低标题等级 Ctrl + - 格式操作 加粗 Ctrl +Ｂ 斜体 Ctrl + I 下划线 Ctrl + U 代码 Ctrl + Shift + ` 删除线 Alt + Shift + 5 超链接 Ctrl + K 图像 Ctrl + Shift + I 清除样式 Ctrl + \ 【其他文章·Markdown·Windows10】 Markdown需要转义的字符及其转义方法 Typora常用快捷键大全 Windows10常用快捷键]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Think before you ask]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E5%85%88%E6%80%9D%E8%80%83%EF%BC%8C%E5%86%8D%E6%8F%90%E9%97%AE%2F</url>
    <content type="text"><![CDATA[If you want something done right, do it yourself. Think before you ask Guderian出品 自己动手，丰衣足食毛泽东曾经说过：“自己动手，丰衣足食。”关于求助这件事，其实很多时候看源代码或者帮助文档能解决很多问题，如果实在没有，一般你遇到的问题别人可能也遇到过，善用搜索引擎能解决更多问题。有一个说法:普通程序员 + google = 超级程序员。所以在平时要养成一些习惯，仔细阅读帮助文档，阅读源代码，善用搜索引擎，实在没辙了再提问。 在一些问答网站上，经常可见回答的一些缩写，很有趣也很有用，在此将其列举出来： RTFSC(Read the fucking source code) RTFM(Read the fucking manual) UTFH (Use The Fucking Help) STFW (Search The Fucking Web) STFG (Search The Fucking Google) GIYF (Google Is Your Friend) JFGI (Just Fucking Google It) UTSL (Use The Source Luke) RTFA (Read The Fucking Article) RTFE (Read The Fucking Email) RTFC (“Read The Fucking Code” or “Reboot The Fucking Computer”) RTFQ (Read The Fucking Question) LMGTFY (Let Me Google That For You) WIDGI (When In Doubt Google It) FIOTI (Find It On The Internet) 通常，给出这些答案的人已经通过这些办法找到了解决问题的关键，正在一边看一边敲键盘。这些回复意味着他认为：第一，你要的信息可以靠你自己的力量找到。第二，自已找要比别人喂到嘴里能学得更多。你不应该觉得这样就被冒犯了，按黑客的标准，他没有不理你就是在向你表示某种尊敬，你反而应该感谢他热切地想帮助你。 结束语 The tools we use have a profound influence on our thinking habits, and therefore, on our thinking abilities. ---from Edsger Dijkstra, 1972 Turing Awards receiver 我们使用的工具深刻地影响着我们的思维习惯，因此，也深刻影响着我们的思维能力。 ——艾兹格·迪科斯彻，1972年图灵奖得主]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解：约瑟夫环问题]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E9%A2%98%E8%A7%A3%EF%BC%9A%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[约瑟夫是一个无聊的人 题解：约瑟夫环问题 Guderian出品 题目背景据说著名犹太历史学家 Josephus有过以下的故事：在罗马人占领乔塔帕特后，39个犹太人与Josephus及他的朋友躲在一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。然而Josephus 和他的朋友并不想遵从。问题是，给定了总人数n和报数值m，一开始要站在什么地方才能避免被处决？Josephus要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。 题目描述n个人(n&lt;=100)围成一圈,从第一个人开始报数,数到m的人出列,再由下一个人重新从1开始报数,数到m的人再出圈,……依次类推,直到所有的人都出圈,请输出依次出圈人的编号。 输入格式n m 输出格式出圈的编号 输入输出样例输入 #1110 3 输出 #113 6 9 2 7 1 8 5 10 4 说明/提示m, n ≤ 100 解题方法解法一：模拟 + 指针模拟链表时间复杂度：$O(m * n)$ 1234567891011121314151617181920212223242526272829303132333435363738//Run on C++#include &lt;cstdio&gt;using namespace std;struct node&#123; int data; node* next;&#125;;int n, m;node *head, *p, *r; //head为头结点，p表示新节点，r表示当前节点int main()&#123; scanf("%d%d", &amp;n, &amp;m); head = new node; head-&gt;data = 1; head-&gt;next = NULL; r = head; for (int i = 2; i &lt;= n; i++) &#123; p = new node; p-&gt;data = i; p-&gt;next = NULL; r-&gt;next = p; r = p; &#125; r-&gt;next = head; r = head; //使链表首尾相连 for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m - 2; j++) r = r-&gt;next; printf("%d ",r-&gt;next-&gt;data); r-&gt;next = r-&gt;next-&gt;next; r = r-&gt;next; &#125; return 0;&#125; 解法二：模拟 + 数组模拟链表 时间复杂度：$O(m * n)$ 123456789101112131415161718192021//Run on C++#include &lt;cstdio&gt;int nxt[110];int n, m;int main()&#123; scanf("%d%d", &amp;n,&amp;m); for (int i = 1; i &lt;= n; i++) nxt[i] = i + 1; nxt[n] = 1; //使链表首尾相连 int pos = 1; //当前位置 for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m - 2; j++) pos = nxt[pos]; printf("%d ", nxt[pos]); nxt[pos] = nxt[nxt[pos]]; pos = nxt[pos]; &#125; return 0;&#125; 解法三：模拟 + 数组时间复杂度：$O(m * n)$ 12345678910111213141516171819202122232425262728//Run on C++#include &lt;cstdio&gt;int m, n;int a[110];int main()&#123; scanf("%d%d", &amp;n, &amp;m); int t = 1, i = 1, cnt = 0; //t为出去的人的数量，i为数组下标索引，cnt为计数器 while(t &lt;= n) &#123; if(i == n + 1) i = 1; //到了最后一个重新从第一个开始 if(a[i] == 0) &#123; cnt++; if(cnt == m) //到了第m个开始新一轮计数 &#123; a[i] = 1; cnt = 0; t++; printf("%d ",i); &#125; &#125; i++; &#125; return 0;&#125; 解法四：模拟 + 队列时间复杂度：$O(m * n)$ 1234567891011121314151617181920//Run on C++#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;queue &lt;int&gt; q;int n,m;int main()&#123; scanf("%d%d",&amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) q.push(i); while(!q.empty()) &#123; for(int i = 1; i &lt; m; i++) q.push(q.front()), q.pop(); //每数一个就把它放到队尾 printf("%d ",q.front()); q.pop(); //队头出圈 &#125; return 0;&#125; 注： 你也可以不用stl提供的队列，自己编写一个队列 你也可以用stl提供的双端队列deque，不过据笔者观察除了装逼效果之外并没有其他用处 解法五：递归（运用递推公式）时间复杂度：$O(n^2)$ 1234567891011121314151617//Run on C++#include &lt;cstdio&gt;int n, m;int Josephus(int x, int y, int z)&#123; if (z == 1) return (y - 1) % x; return (Josephus(x - 1, y, z - 1) + y) % x;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) printf("%d ", Josephus(n, m, i) + 1); return 0;&#125; 解法六：迭代（运用递推公式）时间复杂度：$O(n^2)$ 123456789101112131415161718//Run on C++#include &lt;cstdio&gt;int n, m;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; int ans; for (int j = 1; j &lt;= i; j++) if (j == 1) ans = (m - 1) % (n - i + j); else ans = (ans + m) % (n - i + j); printf("%d ", ans + 1); &#125; return 0;&#125; 推导递推公式*以解法五为例，在递归函数部分代码中 12345int Josephus(int x, int y, int z)&#123; if (z == 1) return (y - 1) % x; return (Josephus(x - 1, y, z - 1) + y) % x;&#125; x代表总人数，y代表每次报y的人出列，z是次数，该函数可以求第y次出圈的人的编号。 举个例子：总人数x为6人，从1开始，每报到3就出圈（z = 3） 初始情况：1 2 3 4 5 6 通过递推的方式使第一个幸运观众出圈之后：1 2 4 5 6 此时，这些编号已经不能组成一个环，但是2和4之间还是连着的，且下一次报数将从4开始。然而，之后的报数将总要考虑3处的空位问题。 如何避免空位对报数所造成的影响？ 可以将剩下的4个数重新组合成一个新的环，这样报数的时候就不必在意3的空缺了。但是新产生的环的数字并非连续的，报数时不能直接用+ y再% x的简单递推方式，这下真令人头大。 如何使新环上的编号依然能够递推？ 可以建立一种有确定规则的映射，要求映射之后的数字可以递推，且可以将在新环中继续按原规则报数得到的结果逆推出在旧环中的对应数字。 阻止我们使用老办法递推的因素就是3号出圈之后产生的新环编号不连续，那么，我们可以通过建立某种映射，使得新环的编号依然连续，方便我们继续使用递推的方法。 原始：1 2 3 4 5 6 旧环：1 2 _ 4 5 6 新环：4 5 _ 1 2 3 正如你所见，相比于旧环中2和4之间被割裂开，新环的5和1之间在对5取余的基础上是完美连续的，这就意味着我们可以继续从新环的1（即旧环的4）开始实施我们的递推方法。且只要推导出新环与旧环的映射关系，就能从在新环中报数的结果得知在旧环中的报数结果。 对于第二个幸运观众： 旧环：1 2 _ 4 5 *6 新环：4 5 _ 1 2 *3 如何从新环的3得到旧环的6呢？其实可以简单地逆推回去 : 新环是由(旧环中编号 - 报数值) % 旧环总人数得到的，所以逆推时可以由(新环编号 + 报数值) % 旧环总人数得到。 如：(3 + 3) % 6 = 0 咦？奇怪怎么是0？不是应该是6吗？这就涉及到一个进位的问题。由于旧环的编号为1~6，而我们在新环依然保留了1~5的编号并确保5和1之间在对5取余的基础上连续，这就导致了5 % 5 = 0，也就是说5与0是无法区分的。因此，虽然实际上旧环编号为6的幸运观众出圈，但是我们的计算结果依然不可避免地把它对6取余，得到一个看似奇怪却又顺理成章的0。 如何避免错误地把最大的数算成0的情况？ 把所有数减1即可，最后输出结果的时候再加上1。让我们再来一遍： 对于第二个幸运观众： 旧环：0 1 _ 3 4 *5 新环：3 4 _ 0 1 *2 从新环推出旧环的幸运观众：(2 + 3) % 6 = 5 由上得，原序列x中第二次出圈的编号可以由新序列x - 1第一次出圈的编号通过特定的逆推运算得出。即在以y为出环报数值的约瑟夫环中，x人环的第z次出环编号可以由x - 1人环中的第z - 1次出环编号通过也定的运算推出。 幸运的是，第一次出环的编号是可以直接求出的，也就是说，对于任意次出环的编号，我们可以将之一直转化为第一次出环的编号问题，再一一迭代求出；也可以把第一次出环的编号作为递归基础，通过递归求出。 因此我们可以写出Josephus函数的递推公式如下： Josephus(x,y,z) = \begin{cases} [Josephus(x-1,y,z-1) + y] \% x ,& \text{z > 1} \\ (y-1)\%x , & \text{z = 1} \end{cases}结束语以上就是关于约瑟夫环问题的六种解法，并送上调试过的C++代码，作者水平不高，将就看看吧 ╮(╯_╰)╭ *. 参考该网站，感谢作者的写作 &#8617;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>C-plus-plus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++指针变量]]></title>
    <url>%2FG-SS-Hacker.github.io%2Fc-%E6%8C%87%E9%92%88%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[指针变量 Guderian出品 指针变量的定义、赋值对指针变量的类型说明，一般形式为： 类型说明符 *变量名; 其中，表示这是一个指针变量，变量名即为定义的指针变量名，类型说明符表示*该指针变量所指向的变量的数据类型。 1、普通变量定义int a = 3; 定义了变量a，是int型的，值为3。内存中有一块内存空间是放a的值，对a的存取操作就是直接到这个内存空间存取。内存空间的位置叫地址，存放3的地址可以用取地址操作符&amp;对a运算得到：&amp;a。 2、指针变量定义int *p = NULL; 定义了一个指针变量p，p指向一个内存空间，里面存放的是一个内存地址。现在赋值为NULL（其实就是0，表示特殊的空地址）。 3、给指针变量p赋值p = &amp;a; 即把a变量的内存空间地址（比如：XXX）给了p。显然，直接对p存取，操作的是地址。通过这个地址间接地操作，才是整数3。P的间接操作要使用指针操作符“*”，即*p的值才是3。设有指向整型变量的指针变量p，如要把整型变量a的地址赋予p可以有以下两种方式： ①指针变量初始化的方法 int a; int *p = &amp;a; ②赋值语句的方法 int a; int *p; p = &amp;a; 不允许把一个数赋予指针变量，故如下的赋值是错误的：int *p；p = 1000；。被赋值的指针变量前不能再加“*”说明符，故如下的赋值也是错误的：*p = &amp;a；。 指针的几个相关操作说明表| 说明 | 样例 || ————————————————— | ————————————————|| 指针定义：类型说明符 *指针变量名 | int *p; || 取地址运算符：&amp; | p = &amp;a; || 间接运算符：* | *p = 20; || 指针变量直接存取的是内存地址 | cout&lt;&lt;p;结果可能是：0x24ae9d || 间接存取的才是存储类型的值 | cout&lt;&lt;*p;结果是：20 | 指针变量同普通变量一样，使用之前不仅要定义说明，而且必须被赋值具体的值，未经赋值的指针变量不能使用。如定义了int a; int *p = &amp;a;，则*p表示p指向的整型变量，而p中存放的是变量a占用单元的起始地址，所以*p实际上访问了变量a，也就是说*p$ \Longleftrightarrow $a。 【例1】输入两个不同的数，通过指针对两个数进行相加和相乘，并输出。 123456789101112131415#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; int a, b, s, t, *pa, *pb; pa = &amp;a; pb = &amp;b; a = 10; b = 20; s = *pa + *pb; t = *pa * *pb; printf("a = %d, b = %d\n", *pa, *pb); printf("s = %d, t = %d\n", s, t); return 0;&#125; 输出： 12a = 10, b = 20s = 30, t = 200 指针的引用与运算一般的，指针(int *p)与普通变量(int a)的对应关系为： 指针变量 普通变量 p &amp;a *p a *p = 3 a = 3 以下为指针的一些运算： 1、指针变量的初始化指针的几个初始化操作说明表| 方法 | 说明 || ——————————- | ————————————————- || int *p = NULL; | NULL是特殊的地址0，叫零指针 || int a; int *p = &amp;a; | p初始化为a的地址 || int *p = new(int); | 申请一个空间给p，*p内容不确定 | 要强调的是，对于定义的局部指针变量，其内容（地址）是随机的，直接对它操作可能会破坏程序或系统内存的值，引发不可预测的错误。所有编程中指针变量要保证先初始化或赋值，给予正确的地址再使用，避免产生*野指针。 2、指针变量的+、-运算指针变量的内容是内存地址，它有两个常用的运算：加、减，这两个运算一般都是配合数组操作的。 【例2】输入N个整数，使用指针变量访问输出。 123456789101112131415161718#include &lt;cstdio&gt;using namespace std;int a[101], n;int main()&#123; scanf("%d",&amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); int p = &amp;a[1]; //定义指针变量int p，初始化为数组开始元素的地址，即a[1]; for (int i = 1; i &lt;= n; i++) &#123; printf("%d ", *p); p++; //p指向下一个数，详见说明 &#125; return 0;&#125; 输入： 1242 1 6 0 输出： 12 1 6 0 【说明】 p++的意思是“广义的加1”，不是p的值（地址）加1，而是根据类型int增加sizeof（int），即刚好“跳过”一个整数的空间，达到下一个整数。 类似的： ①p--就是向前“跳过”一个整数的空间，达到前一个整数。 ②(p + 3)就是指向后面第3个整数的地址。 3、无类型指针有时候，一个指针根据不同的情况，指向的内容是不同类型的值，我们可以先不明确定义它的类型，只是定义一个无类型的指针，以后根据需要再用强制类型转换的方法明确它的类型。 【例3】无类型指针运用举例。 123456789101112131415#include &lt;iostream&gt;using namespace std;int a = 10;double b = 3.5;void *p;int main()&#123; p = &amp;a; //p的地址赋值 cout&lt;&lt;*(int*)p&lt;&lt;endl; //必须明确p指向的空间的数据类型，详见说明 p = &amp;b; cout&lt;&lt;*(double*)p&lt;&lt;endl; return 0;&#125; 输出： 12103.5 【说明】 必须明确p指向的空间的数据类型，类型不一样的不仅空间大小不相同，储存的格式也不同。如果把cout&lt;&lt;*(double*)p&lt;&lt;endl;改成cout&lt;&lt;*(long long*)p&lt;&lt;endl;输出的结果将是：4615063718147915776。 4、多重指针既然指针是指向其他类型的，指针本身也是一种类型。因此，C++允许递归地指针指向指针的指针——多重指针。 【例4】双重指针运用举例。 1234567891011121314#include &lt;cstdio&gt;using namespace std;int a = 10;int *p;int **pp; //定义双重指针int main()&#123; p = &amp;a; //将p指向a pp = &amp;p; //将pp指向p printf("%d = %d = %d\n", a, *p, **pp); //**pp通过2次间接访问了a的变量的值10 return 0;&#125; 输出： 110 = 10 = 10 【说明】 多重指针可以多次“间接”访问数据；竞赛上主要的应用是*动态的多维数组，功能十分强大！！！]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C-plus-plus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[野指针的产生及其危害]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E9%87%8E%E6%8C%87%E9%92%88%E7%9A%84%E4%BA%A7%E7%94%9F%E5%8F%8A%E5%85%B6%E5%8D%B1%E5%AE%B3%2F</url>
    <content type="text"><![CDATA[野指针的产生及其危害 Guderian出品 野指针指向了一块随机内存空间，不受程序控制。如指针指向已经被删除的对象或者指向一块没有访问权限的内存空间，之后如果对其再进行引用的话，就会出现问题。 成因指针变量未初始化任何指针变量（无static修饰的局部变量）刚被创建时不会自动成为*NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。如果没有初始化，编译器会报错。 注：NULL指针是一个定义在标准库中的值为零的常量，其定义为： 1#define NULL ((void *)0) 指针释放之后未置空又是指针在free或delete后未赋值NULL，便会使人以为是合法的。然而free和delete只是把指针所指的内存给释放掉，并没有把指针本身干掉。此时指针指向的是随机内存空间。释放指针后应立即将指针置为NULL，防止产生野指针。 指针操作超越变量作用域返回或引用指向*栈内存的指针，因为栈内存在函数结束的时候会被释放 后果 指向不可访问地址，造成程序异常终止 指向可用空间，但是这块空间不适用，程序正常运行 指向可用空间，但是这块空间刚好在用，造成数据错误 规避初始化时置NULL指针变量一定要初始化为NULL，因为任何指针变量（无static修饰的局部变量）刚被创建时不会自动成为NULL指针，它的缺省值是随机的。 释放时置NULL当指针p指向的内存空间释放时，没有设置指针p的值为NULL。delete和free只是把内存空间释放了，但是并没有将指针p的值赋为NULL。通常判断一个指针是否合法，都是使用if语句测试该指针是否为NULL。例如（针对C++）： 123int *p = new int(6);delete p;if(p != NULL) *p = NULL; 或者使用宏定义来一次性解决问题： 1#define del(x) delete(x); x = NULL]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C-plus-plus</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python运算符优先级]]></title>
    <url>%2FG-SS-Hacker.github.io%2FPython%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[Python运算符优先级 Guderian出品 .tg {border-collapse:collapse;border-spacing:0;}.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg .tg-ncd7{background-color:#ffffc7;border-color:inherit;text-align:left;vertical-align:top}.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top} 运算符描述 Python运算符 优先级 （*不常用） 索引运算符 x[index] 或x[index:index2[:index3]] 18、19 （*不常用） 属性访问 x.attribute 17 算术运算符 乘方 ** 16 位运算符 按位取反 ~ 15 符号运算符 +（正号）或 -（负号） 14 算术运算符 乘、除 *、/、//、% 13 加、减 +、- 12 位运算符 位移 &gt;&gt;、&lt;&lt; 11 按位与 &amp; 10 按位异或 ^ 9 按位或 | 8 比较运算符 ==、!=、&gt;、&gt;=、&lt;、&lt;= 7 身份运算符 is、is not 6 成员运算符 in、not in 5 逻辑运算符 逻辑非 not 4 逻辑与 and 3 逻辑或 or 2]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C & C++ memset]]></title>
    <url>%2FG-SS-Hacker.github.io%2FC%E5%92%8CC-%E4%B8%ADmemset%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[想更方便地初始化吗？Just use memset()!!! C/C++ memset() Guderian出品 头文件 C： &lt;string.h&gt; C++： &lt;cstring&gt; 声明void *memset(void *str, int c, size_t n) 此处size_t变量类型等价于long unsigned int即无符号长整型，在32位机器上为32位，在64位机器为中64位。 注：32位机器指CPU通用寄存器的数据宽度为32位，也就是说CPU一次可以运行32bit数据 描述复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。 参数 str ——指向要填充的代码块 c——要被设置的值该值以 int 形式传递，但是函数在填充内存块时是使用该值的无符号字符形式。 n——要被设置为该值的字节数。 返回值返回一个指向存储区 str 的指针。 实例对字符串操作123456789101112131415#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main ()&#123; char str[50]; strcpy(str,"This is string.h library function"); puts(str); memset(str,'$',7); puts(str); return(0);&#125; 编译并运行以上程序，得到结果如下： 12This is string.h library function$$$$$$$ string.h library function 初始化数组注意：c接收参数的范围0-255 ，该函数只能取c的后八位赋给你所指定的范围的每个字节 初始化为0memset(arr, 0, sizeof(arr)); 初始化为-1memset(arr, -1, sizeof(arr));或memset(arr, 0x7fffffff,sizeof(arr)); 初始化为正无穷 理论上的正无穷：memset(arr, 0x7f, sizeof(arr)); 实际使用的正无穷：memset(arr, 0x3f, sizeof(arr)); 注：D（decimal）——十进制，B（binary）——二进制，O（octor）——八进制，H（hex）——十六进制 初始化为负无穷 理论上的负无穷：memset(arr, 0x80, sizeof(arr)); 实际使用的负无穷：memset(arr, 0xbf, sizeof(arr)); 注：此处要设置的值也可用二进制表示，如0xbf等价于0b10111111]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C-plus-plus</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构绪论]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[基本概念与术语、逻辑结构与物理结构、抽象数据类型 数据结构绪论 Guderian出品 基本概念与术语数据数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅包括整型、实数型等数值类型，还包括字符及声音、图像、视频等非数值类型（严格地说，布尔型也属于数据）。 综上，我们这里说的数据，其实就是符号，且必须具备两个前提： 可以输入到计算机中 能被计算机程序处理 数据元素数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。 数据项数据项：数据不可分割的最小单位。但在真正讨论问题时，数据元素才是数据结构中建立数据模型的着眼点。 数据对象数据对象：性质相同的数据元素的集合，是数据的子集。 数据结构数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。 逻辑结构与物理结构逻辑结构逻辑结构：是指数据对象中数据元素之间的相互关系。 集合结构：地位平等、同属于一个集合。 线性结构：一对一。 树形结构：一对多。 图形结构：多对多。 逻辑结构针对具体问题，是为了解决某个问题，在对问题理解的基础上，选择一个合适的数据结构表示数据元素之间的逻辑关系。 物理结构物理结构（有名存储结构）：数据的逻辑结构在计算机中的存储形式。 顺序存储结构：地址连续的存储单元。 链式存储结构：任意的存储单元。 抽象数据类型数据类型数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。 数据类型可分两类： 原子类型：不可分解，如整形、实型、字符型。 结构类型：可分解，如整型数组、字符串。 抽象数据类型抽象数据类型（Abstract Data Type）：是指一个数学模型及定义在该模型1及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性。而与其在计算机内部如何表达和实现无关。 抽象：抽取出事物具有的普遍性的本质。”抽象“的意义在于数据类型的数学抽象特性。 抽象数据类型不仅指那些已经定义并实现的数据类型（如整型），还可以是计算机编程者在设计软件程序时自己定义的数据类型（如三维坐标(x, y, z)）。 描述抽象数据类型的标准格式： 12345678910ADT 抽象数据类型Data 数据类型之间逻辑关系的定义Operation 操作1 初始条件 操作结果描述 操作2 ……endADT]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算思维导论]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E8%AE%A1%E7%AE%97%E6%80%9D%E7%BB%B4%E5%AF%BC%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[计算思维的本质是抽象与自动化 计算思维导论 Guderian出品 计算思维的发展 计算机的思维：计算机室如何工作的？计算机的功能是如何越来越强大的? 利用计算机的思维：现实世界的各种食物如何利用计算机进行控制和处理？ 计算思维：利用计算机科学的基础概念去求解问题、设计系统和理解人类行为，其本质是抽象与自动化。 学习步骤 概念与知识 联想与贯通 练习与实践 人计算与机器计算的差别人计算： 规则可能很复杂，但计算量却可能很小 人需要知道具体的计算规则 只能使用特定规则 机器计算（自动计算）： 规则可能很简单，但计算量却可能很大 机器也可以使用人的计算规则 使用一般性的规则 自动计算要解决的几个问题：表示-存储-执行 数据的表示 计算规则的表示 数据与计算规则的自动存储 计算规则的自动执行 自动计算的发展历程 如算盘（计算辅助工具）：可以表示数据，不能自动计算 帕斯卡机械计算机：自动计算，固定的计算规则 巴贝奇机械计算机：特定程序，可有限变化的计算规则 现代电子计算机：一般程序，任意可变的计算规则 电子计算机元器件的发展 电子管 晶体管 集成电路 超大规模集成电路（VLSI） 计算机系统的组成 运算器 控制器 存储器 输入设备 输出设备 计算机系统的发展趋势 微型化：可嵌入，可携带 大型化：可进行大规模复杂计算 智能化：理解自然语言，具有自适应性，自主完成复杂功能 网络化：机-机相连，物-物相连，物-人相连，人-人相连，如：IoT，IBM提出”智慧地球”]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>计算思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown需要转义的字符及其转义方法]]></title>
    <url>%2FG-SS-Hacker.github.io%2FMarkdown%E9%9C%80%E8%A6%81%E8%BD%AC%E4%B9%89%E7%9A%84%E5%AD%97%E7%AC%A6%E5%8F%8A%E5%85%B6%E8%BD%AC%E4%B9%89%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Markdown需要转义的字符及其转义方法 Guderian出品 123456789101112\\ 反斜杠\` 反引号\* 星号\_ 下划线\&#123;\&#125; 大括号\[\] 中括号\(\) 小括号\# 井号\+ 加号\- 减号\. 英文句号\! 感叹号]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Python的坑]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E5%85%B3%E4%BA%8EPython%2F</url>
    <content type="text"><![CDATA[关于Python Guderian出品 学习步骤： [ ] 配置环境，安装Python IDLE [ ] Variale（变量）：int（整形），float（浮点型），str（字符串），bool（布尔型） [ ] Data Type（数据类型）：Number（数字），String（字符串），List（列表），Tuple（元组），Set（集合），Dictionary（字典） [ ] 运算符及其优先级 [ ] 分支和循环 换行符号：\n BIF == Built-in function（__builtins__），即内置函数 Python是动态类型语言、脚本语言（编写速度很快） 变量不能以数字开头且区分大小写 字符串可用单引号或双引号表示 转义字符：\甚至可以转义自身 原始字符串：r&#39;...&#39; 小数达到16位及以上时使用E计数法 配合random模块，random.choice()可从一个非空序列中随机获取一个元素 isinstance(a,b)验证变量a的类型是否是b 保留小数数位round(a,b)：对小数a保留b位（b == 0则为x.0) 格式化输出：输出a，保留x位小数 print(‘%.xf’ %a)，中间无逗号 三元操作符：（非常容易出错）： a = x if 条件 else y assert（断言），当关键字右面条件为真时没有反应，为假时程序自动崩溃并抛出AssertionError异常 Int / int会得到float，哪怕不带小数点，千万注意 print得到的东西会自带换行，要避免的话：print(输出, end = ‘’) 短路逻辑：A and B，如果A == False，那么不判断B直接返回False 可迭代对象：列表、元组、字典、文件、集合、生成器 使用max()和min()要保证序列的数据类型统一 sorted()返回一个排好序的列表 reverse()返回一个翻转的迭代器对象 enumerate()生成由二元组构成的一个迭代对象，每个二元组由迭代参数索引号及对应元素组成 zip(iter1,iter2,...)返回各个可迭代参数共同构成的元组，取最短，分先后 在定义函数的时候，位置参数必须在默认参数的前面，否则就会出错 星号（）在形参中的作用是“打包”，在实参中的作用是“*解包” and和or操作符的用法说明：3 and 4返回后一个4，3 or 4返回前一个3 `print`的参数：`print(*object, sep=' ', end='\n', file=sys.stdout, flush=False)` 函数内部只能访问全局变量，不能修改，非要修改可以使用global关键字声明，但不可用于嵌套函数 Python 模块(Module)，是一个 Python 文件，以 .py 结尾，包含了 Python 对象定义和Python语句 dir(模块)返回的列表容纳了在一个模块里定义的所有模块，变量和函数 Python中的整数区间均为左闭右开，负数区间均为左闭右闭 要完成列表的拷贝必须用分片，即了lis1 = lis2[:]，绝不可以直接lis1 = lis2，因为变量名是“贴”在变量上的，变量名与变量之间并非一一对应关系 列表解析式（或列表推导式）：[有关A的解析式 for A in B]]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2FG-SS-Hacker.github.io%2Fhello-world%2F</url>
    <content type="text"><![CDATA[多种语言实现Hello World Starter Guderian出品 Python1print("hello world") C123456#include&lt;stdio.h&gt;int main()&#123; printf("hello world"); return 0;&#125; C++12345678#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; cout&lt;&lt;"hello world"; return 0;&#125; C#123456789using System; class TestApp &#123; public static void Main() &#123; Console.WriteLine("hello world"); Console.ReadKey(); &#125; &#125; Pascal1234Program HelloWorld(output); begin writeln('hello world') end. Java1234567public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println("hello world"); &#125; &#125;]]></content>
      <tags>
        <tag>C-plus-plus</tag>
        <tag>C</tag>
        <tag>Python</tag>
        <tag>C-sharp</tag>
        <tag>Pascal</tag>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
