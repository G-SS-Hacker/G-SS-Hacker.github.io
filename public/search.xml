<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Flavius Josephus Legend]]></title>
    <url>%2F2019%2F08%2F07%2F%E9%A2%98%E8%A7%A3%EF%BC%9A%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Josephus is a boring person!!! 题解：约瑟夫环问题 Guderian出品 题目背景据说著名犹太历史学家 Josephus有过以下的故事：在罗马人占领乔塔帕特后，39个犹太人与Josephus及他的朋友躲在一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。然而Josephus 和他的朋友并不想遵从。问题是，给定了总人数n和报数值m，一开始要站在什么地方才能避免被处决？Josephus要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。 题目描述n个人(n&lt;=100)围成一圈,从第一个人开始报数,数到m的人出列,再由下一个人重新从1开始报数,数到m的人再出圈,……依次类推,直到所有的人都出圈,请输出依次出圈人的编号。 输入格式n m 输出格式出圈的编号 输入输出样例输入 #1110 3 输出 #113 6 9 2 7 1 8 5 10 4 说明/提示m, n ≤ 100 解题方法解法一：模拟 + 指针模拟链表时间复杂度：$O(m * n)$ 1234567891011121314151617181920212223242526272829303132333435363738//Run on C++#include &lt;cstdio&gt;using namespace std;struct node&#123; int data; node* next;&#125;;int n, m;node *head, *p, *r; //head为头结点，p表示新节点，r表示当前节点int main()&#123; scanf("%d%d", &amp;n, &amp;m); head = new node; head-&gt;data = 1; head-&gt;next = NULL; r = head; for (int i = 2; i &lt;= n; i++) &#123; p = new node; p-&gt;data = i; p-&gt;next = NULL; r-&gt;next = p; r = p; &#125; r-&gt;next = head; r = head; //使链表首尾相连 for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m - 2; j++) r = r-&gt;next; printf("%d ",r-&gt;next-&gt;data); r-&gt;next = r-&gt;next-&gt;next; r = r-&gt;next; &#125; return 0;&#125; 解法二：模拟 + 数组模拟链表时间复杂度：$O(m * n)$ 123456789101112131415161718192021//Run on C++#include &lt;cstdio&gt;int nxt[110];int n, m;int main()&#123; scanf("%d%d", &amp;n,&amp;m); for (int i = 1; i &lt;= n; i++) nxt[i] = i + 1; nxt[n] = 1; //使链表首尾相连 int pos = 1; //当前位置 for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m - 2; j++) pos = nxt[pos]; printf("%d ", nxt[pos]); nxt[pos] = nxt[nxt[pos]]; pos = nxt[pos]; &#125; return 0;&#125; 解法三：模拟 + 数组时间复杂度：$O(m * n)$ 12345678910111213141516171819202122232425262728//Run on C++#include &lt;cstdio&gt;int m, n;int a[110];int main()&#123; scanf("%d%d", &amp;n, &amp;m); int t = 1, i = 1, cnt = 0; //t为出去的人的数量，i为数组下标索引，cnt为计数器 while(t &lt;= n) &#123; if(i == n + 1) i = 1; //到了最后一个重新从第一个开始 if(a[i] == 0) &#123; cnt++; if(cnt == m) //到了第m个开始新一轮计数 &#123; a[i] = 1; cnt = 0; t++; printf("%d ",i); &#125; &#125; i++; &#125; return 0;&#125; 解法四：模拟 + 队列时间复杂度：$O(m * n)$ 1234567891011121314151617181920//Run on C++#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;queue &lt;int&gt; q;int n,m;int main()&#123; scanf("%d%d",&amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) q.push(i); while(!q.empty()) &#123; for(int i = 1; i &lt; m; i++) q.push(q.front()), q.pop(); //每数一个就把它放到队尾 printf("%d ",q.front()); q.pop(); //队头出圈 &#125; return 0;&#125; 注： 你也可以不用stl提供的队列，自己编写一个队列 你也可以用stl提供的双端队列deque，不过据笔者观察除了装逼效果之外并没有其他用处 解法五：递归（运用递推公式）时间复杂度：$O(n^2)$ 1234567891011121314151617//Run on C++#include &lt;cstdio&gt;int n, m;int Josephus(int x, int y, int z)&#123; if (z == 1) return (y - 1) % x; return (Josephus(x - 1, y, z - 1) + y) % x;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) printf("%d ", Josephus(n, m, i) + 1); return 0;&#125; 解法六：迭代（运用递推公式）时间复杂度：$O(n^2)$ 123456789101112131415161718//Run on C++#include &lt;cstdio&gt;int n, m;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; int ans; for (int j = 1; j &lt;= i; j++) if (j == 1) ans = (m - 1) % (n - i + j); else ans = (ans + m) % (n - i + j); printf("%d ", ans + 1); &#125; return 0;&#125; 推导递推公式*以解法五为例，在递归函数部分代码中 12345int Josephus(int x, int y, int z)&#123; if (z == 1) return (y - 1) % x; return (Josephus(x - 1, y, z - 1) + y) % x;&#125; x代表总人数，y代表每次报y的人出列，z是次数，该函数可以求第y次出圈的人的编号。 举个例子：总人数x为6人，从1开始，每报到3就出圈（z = 3） 初始情况：1 2 3 4 5 6 通过递推的方式使第一个幸运观众出圈之后：1 2 4 5 6 此时，这些编号已经不能组成一个环，但是2和4之间还是连着的，且下一次报数将从4开始。然而，之后的报数将总要考虑3处的空位问题。 如何避免空位对报数所造成的影响？ 可以将剩下的4个数重新组合成一个新的环，这样报数的时候就不必在意3的空缺了。但是新产生的环的数字并非连续的，报数时不能直接用+ y再% x的简单递推方式，这下真令人头大。 如何使新环上的编号依然能够递推？ 可以建立一种有确定规则的映射，要求映射之后的数字可以递推，且可以将在新环中继续按原规则报数得到的结果逆推出在旧环中的对应数字。 阻止我们使用老办法递推的因素就是3号出圈之后产生的新环编号不连续，那么，我们可以通过建立某种映射，使得新环的编号依然连续，方便我们继续使用递推的方法。 原始：1 2 3 4 5 6 旧环：1 2 _ 4 5 6 新环：4 5 _ 1 2 3 正如你所见，相比于旧环中2和4之间被割裂开，新环的5和1之间在对5取余的基础上是完美连续的，这就意味着我们可以继续从新环的1（即旧环的4）开始实施我们的递推方法。且只要推导出新环与旧环的映射关系，就能从在新环中报数的结果得知在旧环中的报数结果。 对于第二个幸运观众： 旧环：1 2 _ 4 5 *6 新环：4 5 _ 1 2 *3 如何从新环的3得到旧环的6呢？其实可以简单地逆推回去 : 新环是由(旧环中编号 - 报数值) % 旧环总人数得到的，所以逆推时可以由(新环编号 + 报数值) % 旧环总人数得到。 如：(3 + 3) % 6 = 0 咦？奇怪怎么是0？不是应该是6吗？这就涉及到一个进位的问题。由于旧环的编号为1~6，而我们在新环依然保留了1~5的编号并确保5和1之间在对5取余的基础上连续，这就导致了5 % 5 = 0，也就是说5与0是无法区分的。因此，虽然实际上旧环编号为6的幸运观众出圈，但是我们的计算结果依然不可避免地把它对6取余，得到一个看似奇怪却又顺理成章的0。 如何避免错误地把最大的数算成0的情况？ 把所有数减1即可，最后输出结果的时候再加上1。让我们再来一遍： 对于第二个幸运观众： 旧环：0 1 _ 3 4 *5 新环：3 4 _ 0 1 *2 从新环推出旧环的幸运观众：(2 + 3) % 6 = 5 由上得，原序列x中第二次出圈的编号可以由新序列x - 1第一次出圈的编号通过特定的逆推运算得出。即在以y为出环报数值的约瑟夫环中，x人环的第z次出环编号可以由x - 1人环中的第z - 1次出环编号通过也定的运算推出。 幸运的是，第一次出环的编号是可以直接求出的，也就是说，对于任意次出环的编号，我们可以将之一直转化为第一次出环的编号问题，再一一迭代求出；也可以把第一次出环的编号作为递归基础，通过递归求出。 因此我们可以写出Josephus函数的递推公式如下： Josephus(x,y,z) = \begin{cases} [Josephus(x-1,y,z-1) + y] \% x ,& \text{z > 1} \\ (y-1)\%x , & \text{z = 1} \end{cases}结束语以上就是关于约瑟夫环问题的六种解法，并送上调试过的C++代码，作者水平不高，将就看看吧 ╮(╯_╰)╭ *. 参考该网站，感谢作者的写作 &#8617;]]></content>
      <categories>
        <category>Solutions</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Pointer Variale]]></title>
    <url>%2F2019%2F08%2F05%2Fc-%E6%8C%87%E9%92%88%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[A detailed introduction to C++ pointer variable, maybe helpful!!! ;-) 指针变量 Guderian出品 指针变量的定义、赋值对指针变量的类型说明，一般形式为： 类型说明符 *变量名; 其中，表示这是一个指针变量，变量名即为定义的指针变量名，类型说明符表示*该指针变量所指向的变量的数据类型。 1、普通变量定义int a = 3; 定义了变量a，是int型的，值为3。内存中有一块内存空间是放a的值，对a的存取操作就是直接到这个内存空间存取。内存空间的位置叫地址，存放3的地址可以用取地址操作符&amp;对a运算得到：&amp;a。 2、指针变量定义int *p = NULL; 定义了一个指针变量p，p指向一个内存空间，里面存放的是一个内存地址。现在赋值为NULL（其实就是0，表示特殊的空地址）。 3、给指针变量p赋值p = &amp;a; 即把a变量的内存空间地址（比如：XXX）给了p。显然，直接对p存取，操作的是地址。通过这个地址间接地操作，才是整数3。P的间接操作要使用指针操作符“*”，即*p的值才是3。设有指向整型变量的指针变量p，如要把整型变量a的地址赋予p可以有以下两种方式： ①指针变量初始化的方法 int a; int *p = &amp;a; ②赋值语句的方法 int a; int *p; p = &amp;a; 不允许把一个数赋予指针变量，故如下的赋值是错误的：int *p；p = 1000；。被赋值的指针变量前不能再加“*”说明符，故如下的赋值也是错误的：*p = &amp;a；。 指针的几个相关操作说明表 说明 样例 指针定义：类型说明符 *指针变量名 int *p; 取地址运算符：&amp; p = &amp;a; 间接运算符：* *p = 20; 指针变量直接存取的是内存地址 cout&lt;&lt;p;结果可能是：0x24ae9d 间接存取的才是存储类型的值 cout&lt;&lt;*p;结果是：20 指针变量同普通变量一样，使用之前不仅要定义说明，而且必须被赋值具体的值，未经赋值的指针变量不能使用。如定义了int a; int *p = &amp;a;，则*p表示p指向的整型变量，而p中存放的是变量a占用单元的起始地址，所以*p实际上访问了变量a，也就是说*p$ \Longleftrightarrow $a。 【例1】输入两个不同的数，通过指针对两个数进行相加和相乘，并输出。 123456789101112131415#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; int a, b, s, t, *pa, *pb; pa = &amp;a; pb = &amp;b; a = 10; b = 20; s = *pa + *pb; t = *pa * *pb; printf("a = %d, b = %d\n", *pa, *pb); printf("s = %d, t = %d\n", s, t); return 0;&#125; 输出： 12a = 10, b = 20s = 30, t = 200 指针的引用与运算一般的，指针(int *p)与普通变量(int a)的对应关系为： 指针变量 普通变量 p &amp;a *p a *p = 3 a = 3 以下为指针的一些运算： 1、指针变量的初始化指针的几个初始化操作说明表 方法 说明 int *p = NULL; NULL是特殊的地址0，叫零指针 int a; int *p = &amp;a; p初始化为a的地址 int *p = new(int); 申请一个空间给p，*p内容不确定 要强调的是，对于定义的局部指针变量，其内容（地址）是随机的，直接对它操作可能会破坏程序或系统内存的值，引发不可预测的错误。所有编程中指针变量要保证先初始化或赋值，给予正确的地址再使用，避免产生*野指针。 2、指针变量的+、-运算指针变量的内容是内存地址，它有两个常用的运算：加、减，这两个运算一般都是配合数组操作的。 【例2】输入N个整数，使用指针变量访问输出。 123456789101112131415161718#include &lt;cstdio&gt;using namespace std;int a[101], n;int main()&#123; scanf("%d",&amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); int p = &amp;a[1]; //定义指针变量int p，初始化为数组开始元素的地址，即a[1]; for (int i = 1; i &lt;= n; i++) &#123; printf("%d ", *p); p++; //p指向下一个数，详见说明 &#125; return 0;&#125; 输入： 1242 1 6 0 输出： 12 1 6 0 【说明】 p++的意思是“广义的加1”，不是p的值（地址）加1，而是根据类型int增加sizeof（int），即刚好“跳过”一个整数的空间，达到下一个整数。 类似的： ①p--就是向前“跳过”一个整数的空间，达到前一个整数。 ②(p + 3)就是指向后面第3个整数的地址。 3、无类型指针有时候，一个指针根据不同的情况，指向的内容是不同类型的值，我们可以先不明确定义它的类型，只是定义一个无类型的指针，以后根据需要再用强制类型转换的方法明确它的类型。 【例3】无类型指针运用举例。 123456789101112131415#include &lt;iostream&gt;using namespace std;int a = 10;double b = 3.5;void *p;int main()&#123; p = &amp;a; //p的地址赋值 cout&lt;&lt;*(int*)p&lt;&lt;endl; //必须明确p指向的空间的数据类型，详见说明 p = &amp;b; cout&lt;&lt;*(double*)p&lt;&lt;endl; return 0;&#125; 输出： 12103.5 【说明】 必须明确p指向的空间的数据类型，类型不一样的不仅空间大小不相同，储存的格式也不同。如果把cout&lt;&lt;*(double*)p&lt;&lt;endl;改成cout&lt;&lt;*(long long*)p&lt;&lt;endl;输出的结果将是：4615063718147915776。 4、多重指针既然指针是指向其他类型的，指针本身也是一种类型。因此，C++允许递归地指针指向指针的指针——多重指针。 【例4】双重指针运用举例。 1234567891011121314#include &lt;cstdio&gt;using namespace std;int a = 10;int *p;int **pp; //定义双重指针int main()&#123; p = &amp;a; //将p指向a pp = &amp;p; //将pp指向p printf("%d = %d = %d\n", a, *p, **pp); //**pp通过2次间接访问了a的变量的值10 return 0;&#125; 输出： 110 = 10 = 10 【说明】 多重指针可以多次“间接”访问数据；竞赛上主要的应用是*动态的多维数组，功能十分强大！！！]]></content>
      <categories>
        <category>Summaries</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Emergence and Dangers of Wild Pointer]]></title>
    <url>%2F2019%2F08%2F05%2F%E9%87%8E%E6%8C%87%E9%92%88%E7%9A%84%E4%BA%A7%E7%94%9F%E5%8F%8A%E5%85%B6%E5%8D%B1%E5%AE%B3%2F</url>
    <content type="text"><![CDATA[To avoid unexpected errors, you REALLY should learn to avoid wild pointers. 野指针的产生及其危害 Guderian出品 野指针指向了一块随机内存空间，不受程序控制。如指针指向已经被删除的对象或者指向一块没有访问权限的内存空间，之后如果对其再进行引用的话，就会出现问题。 成因指针变量未初始化任何指针变量（无static修饰的局部变量）刚被创建时不会自动成为*NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。如果没有初始化，编译器会报错。 注：NULL指针是一个定义在标准库中的值为零的常量，其定义为： 1#define NULL ((void *)0) 指针释放之后未置空又是指针在free或delete后未赋值NULL，便会使人以为是合法的。然而free和delete只是把指针所指的内存给释放掉，并没有把指针本身干掉。此时指针指向的是随机内存空间。释放指针后应立即将指针置为NULL，防止产生野指针。 指针操作超越变量作用域返回或引用指向*栈内存的指针，因为栈内存在函数结束的时候会被释放 后果 指向不可访问地址，造成程序异常终止 指向可用空间，但是这块空间不适用，程序正常运行 指向可用空间，但是这块空间刚好在用，造成数据错误 规避初始化时置NULL指针变量一定要初始化为NULL，因为任何指针变量（无static修饰的局部变量）刚被创建时不会自动成为NULL指针，它的缺省值是随机的。 释放时置NULL当指针p指向的内存空间释放时，没有设置指针p的值为NULL。delete和free只是把内存空间释放了，但是并没有将指针p的值赋为NULL。通常判断一个指针是否合法，都是使用if语句测试该指针是否为NULL。例如（针对C++）： 123int *p = new int(6);delete p;if(p != NULL) *p = NULL; 或者使用宏定义来一次性解决问题： 1#define del(x) delete(x); x = NULL]]></content>
      <categories>
        <category>Summaries</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python Operator Precedence]]></title>
    <url>%2F2019%2F08%2F02%2FPython%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[What happened to the separation of classes?!! Python运算符优先级 Guderian出品 .tg {border-collapse:collapse;border-spacing:0;}.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg .tg-ncd7{background-color:#ffffc7;border-color:inherit;text-align:left;vertical-align:top}.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top} 运算符描述 Python运算符 优先级 （*不常用） 索引运算符 x[index] 或x[index:index2[:index3]] 18、19 （*不常用） 属性访问 x.attribute 17 算术运算符 乘方 ** 16 位运算符 按位取反 ~ 15 符号运算符 +（正号）或 -（负号） 14 算术运算符 乘、除 *、/、//、% 13 加、减 +、- 12 位运算符 位移 &gt;&gt;、&lt;&lt; 11 按位与 &amp; 10 按位异或 ^ 9 按位或 | 8 比较运算符 ==、!=、&gt;、&gt;=、&lt;、&lt;= 7 身份运算符 is、is not 6 成员运算符 in、not in 5 逻辑运算符 逻辑非 not 4 逻辑与 and 3 逻辑或 or 2]]></content>
      <categories>
        <category>Summaries</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Usage of memset() in c/c++]]></title>
    <url>%2F2019%2F08%2F01%2FC%E5%92%8CC-%E4%B8%ADmemset%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[You wanna make your cycle easier? Just use memset()!!! C/C++中memset()的用法 Guderian出品 头文件 C： &lt;string.h&gt; C++： &lt;cstring&gt; 声明void *memset(void *str, int c, size_t n) 此处size_t变量类型等价于long unsigned int即无符号长整型，在32位机器上为32位，在64位机器为中64位。 注：32位机器指CPU通用寄存器的数据宽度为32位，也就是说CPU一次可以运行32bit数据 描述复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。 参数 str ——指向要填充的代码块 c——要被设置的值该值以 int 形式传递，但是函数在填充内存块时是使用该值的无符号字符形式。 n——要被设置为该值的字节数。 返回值返回一个指向存储区 str 的指针。 实例对字符串操作123456789101112131415#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main ()&#123; char str[50]; strcpy(str,"This is string.h library function"); puts(str); memset(str,'$',7); puts(str); return(0);&#125; 编译并运行以上程序，得到结果如下： 12This is string.h library function$$$$$$$ string.h library function 初始化数组注意：c接收参数的范围0-255 ，该函数只能取c的后八位赋给你所指定的范围的每个字节 初始化为0memset(arr, 0, sizeof(arr)); 初始化为-1memset(arr, -1, sizeof(arr));或memset(arr, 0x7fffffff,sizeof(arr)); 初始化为正无穷 理论上的正无穷：memset(arr, 0x7f, sizeof(arr)); 实际使用的正无穷：memset(arr, 0x3f, sizeof(arr)); 注：D（decimal）——十进制，B（binary）——二进制，O（octor）——八进制，H（hex）——十六进制 初始化为负无穷 理论上的负无穷：memset(arr, 0x80, sizeof(arr)); 实际使用的负无穷：memset(arr, 0xbf, sizeof(arr)); 注：此处要设置的值也可用二进制表示，如0xbf等价于0b10111111]]></content>
      <categories>
        <category>Summaries</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Introducion to Data Structure]]></title>
    <url>%2F2019%2F08%2F01%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[Welcome to a brand new world - Data Structure 数据结构绪论 Guderian出品 基本概念与术语数据数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅包括整型、实数型等数值类型，还包括字符及声音、图像、视频等非数值类型（严格地说，布尔型也属于数据）。 综上，我们这里说的数据，其实就是符号，且必须具备两个前提： 可以输入到计算机中 能被计算机程序处理 数据元素数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。 数据项数据项：数据不可分割的最小单位。但在真正讨论问题时，数据元素才是数据结构中建立数据模型的着眼点。 数据对象数据对象：性质相同的数据元素的集合，是数据的子集。 数据结构数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。 逻辑结构与物理结构逻辑结构逻辑结构：是指数据对象中数据元素之间的相互关系。 集合结构：地位平等、同属于一个集合。 线性结构：一对一。 树形结构：一对多。 图形结构：多对多。 逻辑结构针对具体问题，是为了解决某个问题，在对问题理解的基础上，选择一个合适的数据结构表示数据元素之间的逻辑关系。 物理结构物理结构（有名存储结构）：数据的逻辑结构在计算机中的存储形式。 顺序存储结构：地址连续的存储单元。 链式存储结构：任意的存储单元。 抽象数据类型数据类型数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。 数据类型可分两类： 原子类型：不可分解，如整形、实型、字符型。 结构类型：可分解，如整型数组、字符串。 抽象数据类型抽象数据类型（Abstract Data Type）：是指一个数学模型及定义在该模型1及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性。而与其在计算机内部如何表达和实现无关。 抽象：抽取出事物具有的普遍性的本质。”抽象“的意义在于数据类型的数学抽象特性。 抽象数据类型不仅指那些已经定义并实现的数据类型（如整型），还可以是计算机编程者在设计软件程序时自己定义的数据类型（如三维坐标(x, y, z)）。 描述抽象数据类型的标准格式： 12345678910ADT 抽象数据类型Data 数据类型之间逻辑关系的定义Operation 操作1 初始条件 操作结果描述 操作2 ……endADT]]></content>
      <categories>
        <category>Summaries</category>
      </categories>
      <tags>
        <tag>Data Structure</tag>
        <tag>Computer Science</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Introduction to Computational Thinking]]></title>
    <url>%2F2019%2F07%2F30%2F%E8%AE%A1%E7%AE%97%E6%80%9D%E7%BB%B4%E5%AF%BC%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[Welcome to a brand new world - Computational Thinking 计算思维导论 Guderian出品 计算思维的发展 计算机的思维：计算机室如何工作的？计算机的功能是如何越来越强大的? 利用计算机的思维：现实世界的各种食物如何利用计算机进行控制和处理？ 计算思维：利用计算机科学的基础概念去求解问题、设计系统和理解人类行为，其本质是抽象与自动化。 学习步骤 概念与知识 联想与贯通 练习与实践 人计算与机器计算的差别人计算： 规则可能很复杂，但计算量却可能很小 人需要知道具体的计算规则 只能使用特定规则 机器计算（自动计算）： 规则可能很简单，但计算量却可能很大 机器也可以使用人的计算规则 使用一般性的规则 自动计算要解决的几个问题：表示-存储-执行 数据的表示 计算规则的表示 数据与计算规则的自动存储 计算规则的自动执行 自动计算的发展历程 如算盘（计算辅助工具）：可以表示数据，不能自动计算 帕斯卡机械计算机：自动计算，固定的计算规则 巴贝奇机械计算机：特定程序，可有限变化的计算规则 现代电子计算机：一般程序，任意可变的计算规则 电子计算机元器件的发展 电子管 晶体管 集成电路 超大规模集成电路（VLSI） 计算机系统的组成 运算器 控制器 存储器 输入设备 输出设备 计算机系统的发展趋势 微型化：可嵌入，可携带 大型化：可进行大规模复杂计算 智能化：理解自然语言，具有自适应性，自主完成复杂功能 网络化：机-机相连，物-物相连，物-人相连，人-人相连，如：IoT，IBM提出”智慧地球”]]></content>
      <categories>
        <category>Summaries</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>Computational Thinking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Characters Needing Escaping in Markdown]]></title>
    <url>%2F2019%2F07%2F29%2FMarkdown%E9%9C%80%E8%A6%81%E8%BD%AC%E4%B9%89%E7%9A%84%E5%AD%97%E7%AC%A6%E5%8F%8A%E5%85%B6%E8%BD%AC%E4%B9%89%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[It feels awesome to return my true self!!! Markdown需要转义的字符及其转义方法 Guderian出品 123456789101112\\ 反斜杠\` 反引号\* 星号\_ 下划线\&#123;\&#125; 大括号\[\] 中括号\(\) 小括号\# 井号\+ 加号\- 减号\. 英文句号\! 感叹号]]></content>
      <categories>
        <category>Summaries</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[About Python]]></title>
    <url>%2F2019%2F07%2F28%2F%E5%85%B3%E4%BA%8EPython%2F</url>
    <content type="text"><![CDATA[The things that you should know about Python, maybe helpful!!! ;-) 关于Python Guderian出品 学习步骤： [ ] 配置环境，安装Python IDLE [ ] Variale（变量）：int（整形），float（浮点型），str（字符串），bool（布尔型） [ ] Data Type（数据类型）：Number（数字），String（字符串），List（列表），Tuple（元组），Set（集合），Dictionary（字典） [ ] 运算符及其优先级 [ ] 分支和循环 换行符号：\n BIF == Built-in function（__builtins__），即内置函数 Python是动态类型语言、脚本语言（编写速度很快） 变量不能以数字开头且区分大小写 字符串可用单引号或双引号表示 转义字符：\甚至可以转义自身 原始字符串：r&#39;...&#39; 小数达到16位及以上时使用E计数法 配合random模块，random.choice()可从一个非空序列中随机获取一个元素 isinstance(a,b)验证变量a的类型是否是b 保留小数数位round(a,b)：对小数a保留b位（b == 0则为x.0) 格式化输出：输出a，保留x位小数 print(‘%.xf’ %a)，中间无逗号 三元操作符：（非常容易出错）： a = x if 条件 else y assert（断言），当关键字右面条件为真时没有反应，为假时程序自动崩溃并抛出AssertionError异常 Int / int会得到float，哪怕不带小数点，千万注意 print得到的东西会自带换行，要避免的话：print(输出, end = ‘’) 短路逻辑：A and B，如果A == False，那么不判断B直接返回False 可迭代对象：列表、元组、字典、文件、集合、生成器 使用max()和min()要保证序列的数据类型统一 sorted()返回一个排好序的列表 reverse()返回一个翻转的迭代器对象 enumerate()生成由二元组构成的一个迭代对象，每个二元组由迭代参数索引号及对应元素组成 zip(iter1,iter2,...)返回各个可迭代参数共同构成的元组，取最短，分先后 在定义函数的时候，位置参数必须在默认参数的前面，否则就会出错 星号（）在形参中的作用是“打包”，在实参中的作用是“*解包” and和or操作符的用法说明：3 and 4返回后一个4，3 or 4返回前一个3 `print`的参数：`print(*object, sep=' ', end='\n', file=sys.stdout, flush=False)` 函数内部只能访问全局变量，不能修改，非要修改可以使用global关键字声明，但不可用于嵌套函数 Python 模块(Module)，是一个 Python 文件，以 .py 结尾，包含了 Python 对象定义和Python语句 dir(模块)返回的列表容纳了在一个模块里定义的所有模块，变量和函数 Python中的整数区间均为左闭右开，负数区间均为左闭右闭 要完成列表的拷贝必须用分片，即了lis1 = lis2[:]，绝不可以直接lis1 = lis2，因为变量名是“贴”在变量上的，变量名与变量之间并非一一对应关系 列表解析式（或列表推导式）：[有关A的解析式 for A in B]]]></content>
      <categories>
        <category>Summaries</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Hello world in multiple ways Starter Guderian出品 Python1print("hello world") C123456#include&lt;stdio.h&gt;int main()&#123; printf("hello world"); return 0;&#125; C++12345678#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; cout&lt;&lt;"hello world"; return 0;&#125; C#123456789using System; class TestApp &#123; public static void Main() &#123; Console.WriteLine(&quot;hello world&quot;); Console.ReadKey(); &#125; &#125; Pascal1234Program HelloWorld(output); begin writeln('hello world') end. Java1234567public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println("hello world"); &#125; &#125;]]></content>
  </entry>
</search>
