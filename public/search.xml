<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[高阶求导公式]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E9%AB%98%E9%98%B6%E6%B1%82%E5%AF%BC%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[高阶求导公式 Guderian出品 $ (1)(a^x)^{(n)}=a^x (\ln a)$ $ (2)(e^{ax})^{(n)} = a^n e ^{ax} $ $(3)(\sin x)^{(n)}=\sin(x+\frac {n\pi}2)$ $(4)(\cos x)^{(n)}=\cos(x+\frac{n\pi}2)$ $(5)(x^a)^{(n)}=a(a-1)\dots(a-n+1)x^{a-n},若n&gt;a，则导数等于零$ $(6)[\ln (x+a)]^{(n)}=(-1)^n \frac{(n-1)!}{(x+a)^n}，特别地，令a=0，(\ln x)^{(n)}=(-1)^n\frac{(n-1)!}{x^n}$ $(7)(\frac1{ax+b})^{(n)}=(-a)^{n} \frac{n!}{(ax+b)^{n+1}}，特别的，令a=1,(\frac1{x+b})=(-1)^n \frac{n!}{(x+b)^{n+1}}$ $(8)Leibniz公式：[f(x)g(x)]^{(n)}=\sum_{k=0}^n C_n^kf^{(k)}(x)g^{(n-k)}(x)，C_n^k=\frac{n!}{k!(n-k)!)}，形式上类似牛顿二项展开$ $(9)(f(x)\pm g(x))^{(n)}=f^{(n)}(x)+g^{(n)}(x)$ $(10)(af(x))^{(n)}=af^{(n)}(x)$]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拓扑排序]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[拓扑排序 Guderian出品 拓扑是研究几何图形或空间在连续改变形状后还能保持不变的一些性质的一个学科。它只考虑物体间的位置关系而不考虑它们的形状和大小。 AOV网在工程领域，一个大规模工程常被拆分为多个子工程，这些子工程被称为活动（Activity），在有向图中以顶点（Vertex）表示活动，以有向边表示活动之间的先后关系，这样的有向图被称为AOV网（Activity On Vertex Network）。在AOV网中，如果出现了闭环，就意味着有若干个活动将被无限次重复，工程将永远无法完成；因此，一个具有实用价值的AOV网，必定是一个有向无环图（DAG，Directed Acyclic Graph）。 绪论对于一个有向无环图$G=(V,E)$，其拓扑排序是其上顶点的一个线性排序：对于有向边$(u,v)\in E$，顶点$u$在排序中在顶点$v$的前面（如果$G$包含环路，则不可能产生一个线性排序）。可以将$G$上各顶点在一条水平线上从左向右排开，且图的所有边的指向也都是从左向右。拓扑排序并未各顶点上的排序，而是各顶点逻辑上的排序，这种排序可能有不止一种。在工程上，常把一个大规模工程的各个子工程抽象为一个AOV网，用拓扑排序解决工程的调度问题。下面用一个示例说明拓扑排序的具体应用： 下图（a）表示的是某教授每天早上从起床后到上班前所发生的事情的AOV网。教授必须先完成某些活动，才能完成某些活动；而另一些活动则可以以任意次序完成。在图（a）中，有向边$(u,v)$表示的就是活动$u$必须在活动$v$前完成。图（b）将拓扑排序后的有向无环图在一条水平直线上展示出来。如图（b）所示，该有向无环图所有边的指向都是从左到右。 （a） （b） 拓扑排序算法1. 基于入度的拓扑排序基于入度的拓扑排序算法，又被称为Kahn算法。以下摘选维基百科上关于Kahn算法的伪代码： 123456789101112131415//TOPOLOGICAL-SORT(G)L ← Empty list that will contain the sorted elementsS ← Set of all nodes with no incoming edgeswhile S is non-empty do remove a node u from S insert u into L for each node v with an edge e from u to v do remove edge e from the graph if v has no other incoming edges then insert v into Sif graph has edges then return error (graph has at least onecycle)else return L (a topologically sortedorder) Kahn算法的基本思想是“走一步，看一步”。从以上伪代码不难看出Kahn算法的步骤：先统计所有顶点的入度，再把入度为零的顶点从图中分离出来，先放在集合$S$中，再从集合$S$中分别取出顶点放入线性表$L$中，然后把这个顶点指向的所有顶点的入度减1，并删除该顶点及所有与其相连的边。重复上述操作，直到所有顶点都被分离出来。若当集合$S$为空集时，线性表$L$中元素个数等于原来图中顶点的个数，则返回$L$，$L$中元素的排列即为该图的一种拓扑排序；若当集合$S$为空集时，线性表$L$中元素个数不等于原来图中顶点的个数，则意味着图中有闭环，返回错误信息，对图进行修改后再进行下一次拓扑排序。 对于图（a）的例子，首先我们找到入度为零的顶点有“刷牙”和“喂猫”，则把这两个顶点放入集合$S$中，$S=\{“刷牙”, “喂猫”\}$，$L=\varnothing$。 第一步、在$S$中选取”刷牙“并把该顶点从$S$中删除并放入线性表$L$中，”刷牙“与”洗脸“相连，删除相连的边，”洗脸“的入度减1，新的入度为0，把”洗脸“也放入$S$中。此时$S=\{“洗脸”, “喂猫”\}$，$L=“刷牙”$。 第二步、在$S$中选取“洗脸”并把该顶点从$S$中删除并放入线性表$L$中，“洗脸”与“吃饭”“更衣”相连，删除相连的边，”吃饭““更衣”的入度减1，新的入度为0，把”吃饭“”更衣“也放入$S$中。此时$S=\{“吃饭”, “更衣”, “喂猫”\}$，$L=“刷牙”\to“洗脸”$。 以此类推，第三步到第五步的结果分别如图（3）（4）（5）所示（第六步时$G=\varnothing$），采用同样的步骤，直至$S=\varnothing$，算法结束。 （3） （4） （5） 2. 基于深度优先搜索的拓扑排序基于深度优先搜索的拓扑排序算法同样见以下维基百科上关于该算法的伪代码： 12345678910111213//TOPOLOGICAL-SORT(G)L ← Empty list that will contain the sorted nodesS ← Set of all nodes with no outgoing edgesfor each node v in S do visit(v) function visit(node v) if v has not been visited yet then mark v as visited for each node u with an edge from u to v do visit(u) add v to L 这个算法的过程非常直观：先把出度为零的顶点从图中分离出来，放在集合$S$中，再从集合$S$中分别取出顶点，递归访问其父顶点，若该顶点未被访问，则标记为“已访问”；到达递归基础后，将当前顶点放入线性表$L$中，并逐步回溯。 下证基于DFS的拓扑排序算法生成的是有向无环图的拓扑排序： 在有向无环图$G=(V,E)$上运行DFS，只需证明对于任意一对顶点$(u,v)\in E$，$u$的返回在$v$之前即可。 对边$(u,v)\in E $，在调用DFS(v)时，对于即将访问的$u$，不外乎以下两种情况： DFS(u)未被调用，即$u$未被mark，在当前路搜索路径的DFS树上，$u$是$v$的子节点。 DFS(u)已被调用，即$u$已被mark，则可知DFS(u)在另一条已经完成的搜索路径上返回。 对于这两种情况，$u$的返回都在$v$之前，得证。 例题：任务排序问题题目描述假定你需完成$n$项任务，这些任务之间并非独立，一项任务的执行当且仅当其所有前置任务已经被全部完成。 输入格式输入的数据包含若干组样例，每个样例的第一行包括两个整数$n$和$m$。$n$是任务的数量，$m$是任务之间先后关系的数量。接下来有$m$行，每行有两个整数$i$和$j$，表示任务$i$的执行必须在任务$j$之前。 输入结束的标志是一组$n=m=0$的样例。 输出格式对于每一组样例，在一行内输出$n$个整数，每两个整数之间用一个空格隔开，每一行数据表示一种可行的任务排序方案。 输入样例1234565 41 22 31 31 50 0 输出样例11 4 2 5 3 说明/提示$1 \leq n \leq 100$ 解题方法解法一、Kahn算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//Run on C++#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int MAXN = 110, MAXM = 110 * 110 / 2;struct edge&#123; int v, nxt;&#125;E[MAXM];queue &lt;int&gt; q;int n, m, cnt;int head[MAXN], in[MAXN];void addedge(int u, int v)&#123; E[++cnt].v = v; E[cnt].nxt = head[u]; head[u] = cnt;&#125;void init()&#123; cnt = 0; memset(head, 0, sizeof(head)); memset(E, 0, sizeof(E));&#125; int main()&#123; cin &gt;&gt; n &gt;&gt; m; while(n || m) &#123; init(); for(int i = 1; i &lt;= m; i++) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; addedge(u, v); in[v]++; &#125; for(int i = 1; i &lt;= n; i++) if(!in[i]) q.push(i); while(!q.empty()) &#123; int cur = q.front(); q.pop(); cout &lt;&lt; cur &lt;&lt; " "; for(int i = head[cur]; i; i = E[i].nxt) if(!--in[E[i].v]) q.push(E[i].v); &#125; cout &lt;&lt; endl; cin &gt;&gt; n &gt;&gt; m; &#125; return 0;&#125; 解法二、DFS1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//Run on C++#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int MAXN = 110, MAXM = 110 * 110 / 2;struct edge&#123; int u, nxt;&#125;E[MAXM];queue &lt;int&gt; q;int n, m, cnt;int head[MAXN], out[MAXN];bool flag[MAXN];void addedge(int u, int v)&#123; E[++cnt].u = u; E[cnt].nxt = head[v]; head[v] = cnt;&#125;void init()&#123; cnt = 0; memset(head, 0, sizeof(head)); memset(E, 0, sizeof(E)); memset(out, 0, sizeof(out)); memset(flag, 0, sizeof(flag));&#125; void dfs(int V)&#123; if(!flag[V]) &#123; flag[V] = true; for(int i = head[V]; i; i = E[i].nxt) dfs(E[i].u); cout &lt;&lt; V &lt;&lt; " "; &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; while(n || m) &#123; init(); for(int i = 1; i &lt;= m; i++) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; addedge(u, v); out[u]++; &#125; for(int i = 1; i &lt;= n; i++) if(!out[i]) q.push(i); while(!q.empty()) &#123; dfs(q.front()); q.pop(); &#125; cout &lt;&lt; endl; cin &gt;&gt; n &gt;&gt; m; &#125; return 0;&#125;]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>图论</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高等数学公式]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[高等数学公式 Guderian出品 立方公式1.立方和公式$a^3+b^3=(a+b)(a^2-ab+b^2)$ 2.立方差公式$a^3-b^3=(a-b)(a^2+ab+b^2)$ 3.三项立方和公式$a^3+b^3+c^3-abc=(a+b+c)(a^2+b^2+c^2-ab-bc-ac)$ 4.完全立方和公式$(a+b)^3=a^3+3a^2b+3ab^2+b^3$ $(a-b)^3=a^3-3a^2b+3ab^2-b^3$ 5.立方和累加$1^3+2^3+\ldots +n^3=[\frac{n(n+1)}{2}]^2=(1+2+\ldots+n)^2$ 和差化积公式$\sin \alpha+\sin \beta=2\sin \frac{\alpha+ \beta}{2} \cos \frac{\alpha- \beta}{2}$ $\sin \alpha-\sin\beta=2\cos \frac{\alpha+ \beta}{2}\sin \frac{\alpha- \beta}{2}$ $\cos \alpha+\cos \beta=2\cos \frac{\alpha + \beta}{2}\cos \frac{\alpha- \beta}{2}$ $\cos \alpha - \cos \beta=-2\sin \frac{\alpha+ \beta}{2}\sin \frac{\alpha- \beta}{2}$ 积化和差公式$\sin \alpha \sin \beta=\frac12[\sin(\alpha + \beta)+\sin(\alpha - \beta)]$ $\sin \alpha \cos \beta=\frac12[\sin(\alpha + \beta)-\sin(\alpha - \beta)]$ $\cos \alpha \sin \beta=\frac12[\cos(\alpha + \beta)+\cos(\alpha - \beta)]$ $\cos \alpha \cos \beta=\frac12[cos(\alpha + \beta)-cos(\alpha - \beta)]$ 万能公式$\sin \theta=\frac{2\tan \theta}{1+\tan^2\frac{\theta}{2}}$ $\cos \theta=\frac{1-\tan^2\frac{\theta}{2}}{1+\tan^2\frac{\theta}{2}}$ $\tan \theta=\frac{2\tan \frac{\theta}{2}}{1-\tan^2 \frac{\theta}{2}}$ ​ 平方和拓展$1^2+2^2+\ldots+n^2=\frac1{6}n(n+1)(2n+1)$ $1\times2+2\times3+\ldots+n(n+1)=n(n+1)(n+2)$ 裂项相消$\frac1{n(n+1)(n+2)}=\frac12[\frac1{n(n+1)}-\frac1{(n+1)(n+2)}]$]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用等价无穷小]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E5%B8%B8%E7%94%A8%E7%AD%89%E4%BB%B7%E6%97%A0%E7%A9%B7%E5%B0%8F%2F</url>
    <content type="text"><![CDATA[常用等价无穷小 Guderian出品 基础版当$x\to0$时， $(1)\sin x \sim x$ $(2)\tan x \sim x$ $(3)\arcsin x \sim x$ $(4)\arctan x \sim x$ $(5)1-\cos x \sim \frac12 x^2$ $(6)a^x-1 \sim x \ln a$ $(7)e^x-1 \sim x$ $(8)(1+x)^a-1 \sim ax$ * $(9)\ln (1+x) \sim x$ $(10)\sqrt{1+x}-1 \sim \frac12x$ 进阶版当$x\to0$时， $(11)\log_a(1+x) \sim \frac{x}{\ln a}$ $(12)\sqrt[n]{1+x}-1\sim \frac{x}{n}$ $(13)x-\sin x\sim \frac16x^3$ $(14)\tan x-x\sim\frac13x^3$ $(15)\arcsin x-x\sim\frac16x^3$ $(16)x-\arctan x\sim \frac13x^3$ $(17)\tan x-\sin x\sim \frac12x^3$ *. 见Bernoulli不等式：$(1+x)^n \ge 1+nx$ &#8617;]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[导数基本公式]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E5%AF%BC%E6%95%B0%E5%9F%BA%E6%9C%AC%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[导数基本公式 Guderian出品 $(1)(C)’ = 0$ $(2)(x^a)’=ax^{a-1}$ $(3)(a^x)’=a^x\ln a (a&gt;0且a\not=1)$ $(4)(e^x)’=e^x$ $(5)(\log_ax)’=\frac{1}{x\ln a}(a&gt;0且a\not=1)$ $(6)(\ln x)’=\frac1{x}$ $(7)(\sin x)’=\cos x$ $(8)(\cos x)’=-\sin x$ $(9)(\tan x)’=\frac1{\cos^2x}=\sec^2x$ $(10)(\cot x)’=\frac1{-\sin^x}=-\csc^2x$ $(11)(\sec x)’=\sec x\tan x$ $(12)(\csc x)’=-\csc x\cot x$ $(13)(\arcsin x)’=\frac1{\sqrt{1-x^2}}$ $(14)(\arccos x)’=-\frac1{\sqrt{1-x^2}}$ $(15)(\arctan x)’=\frac1{1+x^2}$ $(16)(\mathrm{arccot} x)’=-\frac1{1+x^2}$]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图的表示]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[图的表示 Guderian出品 绪论对于图 $G=(V,E)$ 1，可以用多种表示方法来表示，其中不同的表示方法分别适用与不同特点的图和对图进行不同的操作。在此介绍三种图的表示方法：邻接表、邻接矩阵和边集数组，并将呈现三种存图方法的C和C++代码实现。 存图方法1.邻接矩阵邻接矩阵是一种简单、易用但有较大局限性的存图方式。由于图是由点集和边集两部分组成，难以找到一种线性结构来同时表示两者，那么，由于每条特定的边都可由其两端顶点唯一确定（假设无重边），我们很自然地可以想到使用一个$|V|$ $*$ $|V|$的方矩阵$A = (a_{ij})$来表示，对于无权图，该矩阵满足： a_{ij} = \left\{ \begin{array}{} 1, \ (i, j) \in E\\ 0, \ (i, j) \notin E \end{array} \right.对于带权图，该矩阵满足： a_{ij} = \left\{ \begin{array}{} w, \ (i, j) \in E\\ \infty \ or \ 0\ or-1, \ (i, j) \notin E \end{array} \right. 【例1】 无向带权图示例如下图所示： 上图对应的邻接矩阵表示如图： \mathbf{A} =\left( \begin{array}{ccc}a_{11} & a_{12} & a_{13} & a_{14} \\\\a_{21} & a_{22} & a_{23} & a_{24} \\\\a_{31} & a_{32} & a_{33} & a_{34} \\\\a_{41} & a_{42} & a_{43} & a_{44}\end{array} \right)\mathbf{} =\left( \begin{array}{ccc}\infty & 4 & 5 & 7 \\\\4 & \infty & 2 & 2 \\\\5 & 2 & \infty & 3 \\\\7 & 2 & 3 & \infty\end{array} \right) 123456789//Run on C/C++const int n = 4; //n个顶点const int inf = 0x3f3f3f3f; //正无穷int G[n][n] = &#123; &#123;inf, 4, 5, 7&#125;, &#123;4, inf, 2, 2&#125;, &#123;5, 2, inf, 3&#125;, &#123;7, 2, 3, inf&#125;&#125;; 【例2】 有向带权图示例如下图所示： 上图对应的邻接矩阵表示如图： \mathbf{A} =\left( \begin{array}{ccc}a_{11} & a_{12} & a_{13} & a_{14} \\\\a_{21} & a_{22} & a_{23} & a_{24} \\\\a_{31} & a_{32} & a_{33} & a_{34} \\\\a_{41} & a_{42} & a_{43} & a_{44}\end{array} \right)\mathbf{} =\left( \begin{array}{ccc}\infty & 4 & 5 & 7 \\\\0 & \infty & 2 & 2 \\\\0 & 0 & \infty & 3 \\\\0 & 0 & 0 & \infty\end{array} \right) 123456789//Run on C/C++const int n = 4; //n个顶点const int inf = 0x3f3f3f3f; //正无穷int G[n][n] = &#123; &#123;inf, 4, 5, 7&#125;, &#123;0, inf, 2, 2&#125;, &#123;0, 0, inf, 3&#125;, &#123;0, 0, 0, inf&#125;&#125;; 【例1】【例2】分别给出了无向无权图和有向无权图的邻接矩阵表示，不管一个图有多少条边，邻接矩阵的空间复杂度都为$O(V^2)$。 不难看出，无向图的邻接矩阵是一个对称矩阵。由于在无向图中，边$(u,v)$与边$(v,u)$表示同一条边，无向图的邻接矩阵$A$就是自己的转置，即$A = A^T$。在存储时，可以只存放主对角线及其以上的这部分邻接矩阵（即半个矩阵），从而将图存储空间需求减少几乎一半。 邻接矩阵表示简单、容易理解，对已知的边操作的效率高（插入、删除、查询的时间复杂度都是$O(1)$。但是邻接矩阵的缺陷在于其空间复杂度巨大，在稠密图上邻接矩阵可以取得较好的利用率，但是在稀疏图 2上使用邻接矩阵将会造成大量内存空间的浪费，很容易导致内存溢出。因此，在使用邻接矩阵存图时一定要格外注意内存空间的限制，不可盲目追求简单而忽略了内存空间的优化。 2.邻接表邻接表是一种具有高度鲁棒性 3、适用于大多数情况的存图方法。对于图$ G = (V,E)$，其邻接表表示由一个包含$|V|$条链表的数组Adj[] 4所构成，每个顶点有一条链表。对于每个顶点$u\in V$，邻接表Adj[u]包含所有与顶点$u$之间有边相连的顶点$v$，即Adj[u]包含图$G$中所有与$u$邻接的顶点。邻接表本质上是使用链表存边，一条链表代表着一个点发出的所有边，通过链表存储和遍历和一个顶点相连的所有边，并根据实际应用情况选择是否存储边权。在C/C++中，实现邻接表的方法主要有两种：链式向前星和vector存图。 【例3】 有向带权图示例如下图所示： 上图对应的邻接表表示如图： 链式向前星存图法是利用了一种特殊的链表，这种链表具有普通链表链式存储的特征，但其插入新元素的方式却是“向前星”，即从链表表头插入元素，每次只更新表头，因此得名链式向前星。在使用链式向前星时，应很好的理解这种数据结构与普通链表的区别。 123456789101112131415161718192021222324252627282930313233//链式向前星//Run on C/C++#include&lt;iostream&gt;using namespace std;const int n = 4, m = 6; //n个顶点，m条边struct edge&#123; int w, v, nxt; //nxt指向同一个顶点发出的另一条边&#125;E[n];int cnt = 0;int head[m]; //假设从0号顶点开始存储void add(int u, int v, int w) //改变编号为cnt的边&#123; E[++cnt].v = v; //出边指向v E[cnt].w = w; //记录边权 E[cnt].nxt = head[u]; //将其指向目前链表的表头（重要！） head[u] = cnt; //将表头更新为目前的编号（重要！）&#125;int main()&#123; add(1, 2, 4); add(1, 4, 7); add(1, 3, 5); add(3, 4, 3); add(3, 2, 2); add(2, 4, 2); return 0;&#125; vector存图实际上是利用了一个不定长的链表该存储从一个顶点出发的所有边的情况，与普通链表类似，vector也是从链表的尾端进行插入操作，因此vector存图法在理解难度上比链式向前星要简单。然而由于C/C++语言的原因，使用vector存图实际使用的内存比链式向前星的要大，因此内存溢出的风险也会更大。 123456789101112131415161718192021222324252627282930//vector存图，使用stl::pair版//Run on C/C++#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int n = 4; //n个顶点vector&lt;pair&lt;int, int&gt;&gt; E[n + 1]; //int（first）为u，int（second）为vvoid add(int u, int v, int w)&#123; E[u].push_back(&#123;v, w&#125;);&#125;int main()&#123; add(1, 2, 4); add(1, 4, 7); add(1, 3, 5); add(3, 4, 3); add(3, 2, 2); add(2, 4, 2); for(int i = 1; i &lt;= n; i++) for(int j = 0; j &lt;(int)E[i].size(); j++) cout&lt;&lt;i&lt;&lt;" "&lt;&lt;E[i][j].first&lt;&lt;" "&lt;&lt;E[i][j].second&lt;&lt;endl; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435//vector存图，使用结构体版//Run on C/C++#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int n = 4; //n个顶点struct edge&#123; int v, w;&#125;;vector&lt;edge&gt;E[n + 1];void add(int u, int v, int w)&#123; E[u].push_back(&#123;v, w&#125;);&#125;int main()&#123; add(1, 2, 4); add(1, 4, 7); add(1, 3, 5); add(3, 4, 3); add(3, 2, 2); add(2, 4, 2); for(int i = 1; i &lt;= n; i++) for(int j = 0; j &lt;(int)E[i].size(); j++) cout&lt;&lt;i&lt;&lt;" "&lt;&lt;E[i][j].v&lt;&lt;" "&lt;&lt;E[i][j].w&lt;&lt;endl; return 0;&#125; 不管是用链式向前星存图还是vector存图，邻接表的空间复杂度都为$O(E + V)$。与邻接矩阵相比，邻接表的空间复杂度更小，空间利用率更高。但是邻接表使用链式结构存储边，这导致了对边操作的时间复杂度为$O(n)$，因此邻接表并不适用于需要频繁对边操作的情况；对于稠密图，邻接表的性能也不比邻接矩阵更占上风。然而，对于不需要频繁对边进行操作的稀疏图，使用邻接表存图比使用邻接矩阵存图可以期待更高的效率。综上，邻接表不失为一种性能优秀的存图方法。 3.边集数组边集数组也是一种简单、易用但有较大局限性的存图方式。边集数组由一个一维结构体数组e[]构成，数组的每个数据元素由一条边的起点下标（u），终点下标（v）和权值（w）组成，如下图所示。不难看出，边集数组关注边的集合，而不关注点的集合。因此，使用这种存图方法在需要遍历图的边集时可以获得很高的效率，但是在遍历图的点集时效率简直是灾难。不论一个图有多少个顶点，边集数组的空间复杂度都为$O(E)$。 【例4】 有向带权图示例如下图所示： 上图对应的边集数组如下表所示： u v w e[1] 1 2 4 e[2] 1 4 7 e[3] 1 3 5 e[4] 3 4 3 e[5] 3 2 2 e[6] 2 4 2 12345678910111213141516//Run on C/C++const int m = 6; //m条边struct edge&#123; int u, v, w;&#125;;edge E[m] = &#123; &#123;1, 2, 4&#125;, &#123;1, 4, 7&#125;, &#123;1, 3, 5&#125;, &#123;3, 4, 3&#125;, &#123;3, 2, 2&#125;, &#123;2, 4, 2&#125;&#125;; 据观察，这种存图方法主要用于实现最小生成树的Krusal算法，其他情况下较少使用。 1. 图，graph，记为“G”；顶点，vertex，记为“V”；边，edge，记为“E”。 &#8617; 2. 稠密图与稀疏图的判断标准：(1)定性分析：稠密图的边数非常接近于完全图（即$n(n-1)$），而稀疏图的边数比完全图少得多。(2)定量分析：边数多于$nlogn$的图为稠密图，边数少于$nlogn$的图为稀疏图。 &#8617; 3. 鲁棒性，robust，即健壮性 &#8617; 4. 邻接表，adjlist，记为”Adj” &#8617;]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法性能比较]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[排序算法性能比较 Guderian出品 .tg {border-collapse:collapse;border-spacing:0;}.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg .tg-cly1{text-align:left;vertical-align:middle}.tg .tg-0lax{text-align:left;vertical-align:top} 类别 排序方法 时间复杂度 空间复杂度 稳定性 平均情况 最坏情况 插入排序 直接插入 O(n2) O(n2) O(1) 稳定 希尔排序 O(n1.3) O(n2) O(1） 不稳定 选择排序 直接选择 O(n2) O(n2) O(1) 不稳定 堆排序 O(nlogn) O(nlogn) O(1) 不稳定 交换排序 冒泡排序 O(n2) O(n2) O(1) 稳定 快速排序 O(nlogn) O(n2) O(logn) 不稳定 归并排序 O(nlogn) O(nlogn) O(n) 稳定 基数排序 O(d(r+n)) O(d(r+n)) O(r+n) 稳定 桶排序 O(2(m+n)) O(2(m+n)) O(max{key}) 稳定 *注：基数排序中，d表示关键字的位数长度，r表示关键字每一个数位有r中可能的取值 **注：桶排序中，m表示桶的个数]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加密算法]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Commander: AJCS27862%^%$f!@errgdfqw@!$%yde%%1038J^ Soldier: Got it. Let's go! 加密算法 Guderian出品 加密算法的历史加密算法是一种古老的算法，在人类几千年来的历史进程中，加密算法随着一场场战争的爆发而不断进步，从古罗马时代到第二次世界大战，从凯撒密码到恩尼格玛密码。然而，就像矛和盾的关系一样，加密技术和解密技术也在不断螺旋式发展。下面，笔者将向读者朋友们介绍一种古老的科技：凯撒密码。 在战争中，命令的传递往往需要通过传令兵。如： 后方指挥部 ———传令兵携带命令“攻打X城”———>我方部队可是，一旦传令兵被敌方抓获，重要的军事情报就会泄露给敌方。 后方指挥部—命令“攻打X城”—>敌方部队甚至，敌人可能会篡改命令，并收买传令兵把假情报传给我方部队。 后方指挥部—命令“攻打X城”—>敌方部队—命令“攻打Y城”—>我方部队这样一来，我方部队就会完全落入敌方陷阱中。为了防止这种情况发生，在没有更好的传达命令的方法的情况下，我们不妨修改命令的内容，让敌人即使截获了命令，也无法看懂命令的内容，这就是对信息的加密。 后方指挥部—命令“@#￥！！”—>敌方部队：？？？如何进行加密呢？有一种非常朴素的加密方法叫凯撒密码，它的基本思路就是偏移。 如图所示，图中第一行的字母代表明文，第二行字母代表密文。这个加密算法十分简单，选择一个偏移量，此处是3，把明文当中的所有字母按照字母表的顺序向后偏移三位，从而生成密文。比如： 1234A - &gt; DB - &gt; EC - &gt; FLOL - &gt; MPM 这样一来，就算我军的密码被敌军截获，敌军也无法看懂。一旦我方部队收到了我方的命令，只要逆转原来加密的过程，把密文以偏移量3往左偏移解密为明文，就可以正确收到我方的命令。假设敌军已知我方的加密算法，想要破解，把26个字母都试一遍，终究可以得到正确的原文，这就叫暴力破解。 现代加密算法1.对称加密算法明文--密钥-->密文--密钥-->明文这很好理解，这就好比给你需要传递的信息加上一把锁，这把锁的钥匙只有你和信息接收方拥有，这样就算信息被截获，也只能看出一堆乱码。只要传递方与接收方事先得到一致的密钥，双方就可以安全进行信息往来。 常见的对称加密算法有DES算法和3DES算法，它的基本方法是替换+移位；还有美国联邦政府采用的AES算法；还有RC-5算法和IDEA算法。office Word、Excel、Powerful、pdf、WinRAR的加密算法都属于对称加密算法。 对称加密算法的优点是简单高效，然而缺点却也很明显，那就是安全性低。比如下面这种情况： 你想要给某人通过QQ发送一个加了密的word文档，你发过去了但你的小伙伴打不开，那他当然会向你要密码。为了让他能顺利打开这个文档，你又要给他发送文档的密码。这样一来，你的文档就没有任何安全性可言了。如果你的文档被不怀好意的人截获，那他当然也能截获你的密码。 为了解决对称加密算法安全性低的问题，科学家发明了非对称加密算法。 2. 非对称加密算法明文--公钥-->密文--私钥-->明文 明文--私钥-->密文--公钥-->明文在非对称加密算法中有一对密钥，其中一个叫公钥、另一个叫私钥。如果要加密一个文档，我们既可以用公钥加密文档，用私钥解密文档；也可以用私钥加密文档，用公钥解密文档。最常见的非对称加密算法就是大名鼎鼎的RSA算法，几乎无法破解。 非对称加密算法的缺点是效率低下，然而其优点是安全性极高，解决了对称加密算法的安全性低的问题。比如下面这种情况： 在一间公司中，每一个员工都有自己的一对公钥和私钥，公钥可以交给他人，但是私钥只有自己知道。员工之一的你想要给同样为员工的某人通过QQ发送一个文档，你只需要向接受者索要他的公钥，他就会光明正大地通过QQ发给你，你再利用他的公钥给文档加密，然后光明正大地通过QQ发给他，他接收到你发送的已用他的公钥加密过的文档之后，就可以用他的私钥解密，从而顺利的查看文档了。在这个过程中，就算文档和公钥都被截获，因为没有相应的私钥，也无法正常还原。因此，这个非对称加密算法的安全性比对称加密算法提高了一个等级。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>网络与信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OSI/RM七层模型]]></title>
    <url>%2FG-SS-Hacker.github.io%2FOSIRM%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[OSI/RM = Open System Interconnection Reference Model 计算机网络：OSI/RM七层模型 Guderian出品 在计算机网络建立之初，各大计算机企业之间并没有一套通用的标准来规范计算机网络的建设，相反，各企业在自己的计算机系统上实行自己的标准，这就造成了一种局面：不同品牌计算机之间不能实现互连。要知道互联网建立之初的目的就是让把全世界的计算机连接起来，实现信息共享。这个目标在今天已经基本实现，然而在上个世纪七八十年代，苹果的计算机和IBM的计算机的网路接口都不一样，更不用说两者互连了。这种情况在不同品牌 的计算机之间比比皆是，制约了世界互联网的发展，同时也制约了互联网市场规模的增长。 此时，各计算机企业需要一套公用的标准来规范计算机网络的建设。然而，每一家企业都希望推行自己的标准，不愿意使用别人的标准。正如现在我们所说：“一流的公司定标准。”当别人制定好了标准，你再依据这个标准开发产品的时候，实际上你已经比别人落后了，也就是说标准制定者永远站在领先的位置。各计算机企业争执不下，标准的制定再次陷入僵局。 既然各计算机企业都不愿意放弃自己的标准，使用别人的标准，那么有人提议，我们全部放弃自己的标准，由国际标准化组织（nternational Organization for Standardization, ISO)来制定一套标准，我们就全部采用那套标准。这一提议得到了计算机企业的广泛认可。于是ISO就制定了开放系统互连(OSI)模型，并由全世界的计算机企业以此为标准开发和建立计算机网络。虽然从今天的角度看，这套标准有些繁琐，层次显得太多，但是因为这套标准已经被遵循多年，所以被一直延续了下来，未曾改变。 OSI/RM七层模型 .tg {border-collapse:collapse;border-spacing:0;}.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top} 层次 名称 主要功能 主要设备及协议 7 应用层 实现具体的应用功能 POP3、FTP、HTTP、Telnet、SMTPDHCP、TFTP、SNMP、DNS 6 表示层 数据的格式与表达、加密、压缩 5 会话层 建立、管理和终止对话 4 传输层 端到端的连接 TCP、UDP 3 网络层 分组传输和路由选择 三层交换机、路由器ARP、RARP、IP、ICMP、IGMP 2 数据链路层 传输以帧为单位的信息 网桥、交换机、网卡PPTP、L2TP、SLIP、PPP 1 物理层 二进制传输 中继器、集线器]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows10常用快捷键]]></title>
    <url>%2FG-SS-Hacker.github.io%2FWindows10%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[Life is short, you need shortcuts Windows 10常用快捷键 Guderian出品 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647Windows 徽标键 + I —&gt; 打开“设置”Windows 徽标键 + E —&gt; 打开“文件资源管理器”Windows 徽标键 + D —&gt; 显示和隐藏桌面Windows 徽标键 + L —&gt; 锁定电脑Windows 徽标键 + M —&gt; 最小化所有窗口Windows 徽标键 + R —&gt; 打开“运行”对话框Windows 徽标键 + 逗号 (,) —&gt; 临时快速查看桌面Windows 徽标键 + 数字 —&gt; 打开桌面，并启动固定到任务栏的位于该数字所表示位置的应用。如果该应用已在运行，则切换到该应用。Windows 徽标键 + Tab —&gt; 打开“任务视图”Windows 徽标键 + 向上键 —&gt; 最大化窗口Windows 徽标键 + 向下键 —&gt; 从屏幕中删除当前应用或最小化桌面窗口Windows 徽标键 + 向左键 —&gt; 将应用或桌面窗口最大化到屏幕左侧Windows 徽标键 + 向右键 —&gt; 将应用或桌面窗口最大化到屏幕右侧Alt + Enter —&gt; 打开选定项的“属性”对话框Backspace —&gt; 查看上一个文件夹F2 —&gt; 重命名选定项F3 —&gt; 在文件资源管理器中搜索文件或文件夹Ctrl + X —&gt; 剪切选定项Ctrl + C（或 Ctrl + Insert） —&gt; 复制选定项Ctrl + V（或 Shift + Insert） —&gt; 粘贴选定项Ctrl + Z —&gt; 撤消操作Ctrl + Y —&gt; 重做操作Alt + Tab —&gt; 在打开的应用之间切换Alt + F4 —&gt; 关闭活动项，或者退出活动应用]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Windows10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typora常用快捷键大全]]></title>
    <url>%2FG-SS-Hacker.github.io%2FTypora%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[Life is short, you need shortcuts Typora常用快捷键大全 Guderian出品 .tg {border-collapse:collapse;border-spacing:0;}.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg .tg-m9r4{background-color:#ffffc7;text-align:left;vertical-align:top}.tg .tg-ncd7{background-color:#ffffc7;border-color:inherit;text-align:left;vertical-align:top}.tg .tg-0lax{text-align:left;vertical-align:top}.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top} 操作类型 操作 快捷键 文件操作 新建 Ctrl + N 新建窗口 Ctrl + Shift + N 打开 Ctrl + O 快速打开 Ctrl + P 保存 Ctrl + S 另存为 Ctrl + Shift + S 偏好设置 Ctrl + 逗号 关闭 Ctrl + W 编辑操作 选中当前行/句 Ctrl + L 选中当前格式文本 Ctrl + E 选中当前词 Ctrl + D 查找 Ctrl + F 替换 Ctrl + H 查找下一个 F3 查找上一个 Shift + F3 段落操作 提升标题等级 Ctrl + = 降低标题等级 Ctrl + - 格式操作 加粗 Ctrl +Ｂ 斜体 Ctrl + I 下划线 Ctrl + U 代码 Ctrl + Shift + ` 删除线 Alt + Shift + 5 超链接 Ctrl + K 图像 Ctrl + Shift + I 清除样式 Ctrl + \]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Think before you ask]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E5%85%88%E6%80%9D%E8%80%83%EF%BC%8C%E5%86%8D%E6%8F%90%E9%97%AE%2F</url>
    <content type="text"><![CDATA[If you want something done right, do it yourself. Think before you ask Guderian出品 自己动手，丰衣足食毛泽东曾经说过：“自己动手，丰衣足食。”关于求助这件事，其实很多时候看源代码或者帮助文档能解决很多问题，如果实在没有，一般你遇到的问题别人可能也遇到过，善用搜索引擎能解决更多问题。有一个说法:普通程序员 + google = 超级程序员。所以在平时要养成一些习惯，仔细阅读帮助文档，阅读源代码，善用搜索引擎，实在没辙了再提问。 在一些问答网站上，经常可见回答的一些缩写，很有趣也很有用，在此将其列举出来： RTFSC(Read the fucking source code) RTFM(Read the fucking manual) UTFH (Use The Fucking Help) STFW (Search The Fucking Web) STFG (Search The Fucking Google) GIYF (Google Is Your Friend) JFGI (Just Fucking Google It) UTSL (Use The Source Luke) RTFA (Read The Fucking Article) RTFE (Read The Fucking Email) RTFC (“Read The Fucking Code” or “Reboot The Fucking Computer”) RTFQ (Read The Fucking Question) LMGTFY (Let Me Google That For You) WIDGI (When In Doubt Google It) FIOTI (Find It On The Internet) 通常，给出这些答案的人已经通过这些办法找到了解决问题的关键，正在一边看一边敲键盘。这些回复意味着他认为：第一，你要的信息可以靠你自己的力量找到。第二，自已找要比别人喂到嘴里能学得更多。你不应该觉得这样就被冒犯了，按黑客的标准，他没有不理你就是在向你表示某种尊敬，你反而应该感谢他热切地想帮助你。 结束语 The tools we use have a profound influence on our thinking habits, and therefore, on our thinking abilities. ---from Edsger Dijkstra, 1972 Turing Awards receiver 我们使用的工具深刻地影响着我们的思维习惯，因此，也深刻影响着我们的思维能力。 ——艾兹格·迪科斯彻，1972年图灵奖得主]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解：约瑟夫环问题]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E9%A2%98%E8%A7%A3%EF%BC%9A%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[约瑟夫是一个无聊的人 题解：约瑟夫环问题 Guderian出品 题目背景据说著名犹太历史学家 Josephus有过以下的故事：在罗马人占领乔塔帕特后，39个犹太人与Josephus及他的朋友躲在一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。然而Josephus 和他的朋友并不想遵从。问题是，给定了总人数n和报数值m，一开始要站在什么地方才能避免被处决？Josephus要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。 题目描述n个人(n&lt;=100)围成一圈,从第一个人开始报数,数到m的人出列,再由下一个人重新从1开始报数,数到m的人再出圈,……依次类推,直到所有的人都出圈,请输出依次出圈人的编号。 输入格式n m 输出格式出圈的编号 输入输出样例输入 #1110 3 输出 #113 6 9 2 7 1 8 5 10 4 说明/提示m, n ≤ 100 解题方法解法一：模拟 + 指针模拟链表时间复杂度：$O(m * n)$ 1234567891011121314151617181920212223242526272829303132333435363738//Run on C++#include &lt;cstdio&gt;using namespace std;struct node&#123; int data; node* next;&#125;;int n, m;node *head, *p, *r; //head为头结点，p表示新节点，r表示当前节点int main()&#123; scanf("%d%d", &amp;n, &amp;m); head = new node; head-&gt;data = 1; head-&gt;next = NULL; r = head; for (int i = 2; i &lt;= n; i++) &#123; p = new node; p-&gt;data = i; p-&gt;next = NULL; r-&gt;next = p; r = p; &#125; r-&gt;next = head; r = head; //使链表首尾相连 for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m - 2; j++) r = r-&gt;next; printf("%d ",r-&gt;next-&gt;data); r-&gt;next = r-&gt;next-&gt;next; r = r-&gt;next; &#125; return 0;&#125; 解法二：模拟 + 数组模拟链表 时间复杂度：$O(m * n)$ 123456789101112131415161718192021//Run on C++#include &lt;cstdio&gt;int nxt[110];int n, m;int main()&#123; scanf("%d%d", &amp;n,&amp;m); for (int i = 1; i &lt;= n; i++) nxt[i] = i + 1; nxt[n] = 1; //使链表首尾相连 int pos = 1; //当前位置 for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m - 2; j++) pos = nxt[pos]; printf("%d ", nxt[pos]); nxt[pos] = nxt[nxt[pos]]; pos = nxt[pos]; &#125; return 0;&#125; 解法三：模拟 + 数组时间复杂度：$O(m * n)$ 12345678910111213141516171819202122232425262728//Run on C++#include &lt;cstdio&gt;int m, n;int a[110];int main()&#123; scanf("%d%d", &amp;n, &amp;m); int t = 1, i = 1, cnt = 0; //t为出去的人的数量，i为数组下标索引，cnt为计数器 while(t &lt;= n) &#123; if(i == n + 1) i = 1; //到了最后一个重新从第一个开始 if(a[i] == 0) &#123; cnt++; if(cnt == m) //到了第m个开始新一轮计数 &#123; a[i] = 1; cnt = 0; t++; printf("%d ",i); &#125; &#125; i++; &#125; return 0;&#125; 解法四：模拟 + 队列时间复杂度：$O(m * n)$ 1234567891011121314151617181920//Run on C++#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;queue &lt;int&gt; q;int n,m;int main()&#123; scanf("%d%d",&amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) q.push(i); while(!q.empty()) &#123; for(int i = 1; i &lt; m; i++) q.push(q.front()), q.pop(); //每数一个就把它放到队尾 printf("%d ",q.front()); q.pop(); //队头出圈 &#125; return 0;&#125; 注： 你也可以不用stl提供的队列，自己编写一个队列 你也可以用stl提供的双端队列deque，不过据笔者观察除了装逼效果之外并没有其他用处 解法五：递归（运用递推公式）时间复杂度：$O(n^2)$ 1234567891011121314151617//Run on C++#include &lt;cstdio&gt;int n, m;int Josephus(int x, int y, int z)&#123; if (z == 1) return (y - 1) % x; return (Josephus(x - 1, y, z - 1) + y) % x;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) printf("%d ", Josephus(n, m, i) + 1); return 0;&#125; 解法六：迭代（运用递推公式）时间复杂度：$O(n^2)$ 123456789101112131415161718//Run on C++#include &lt;cstdio&gt;int n, m;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; int ans; for (int j = 1; j &lt;= i; j++) if (j == 1) ans = (m - 1) % (n - i + j); else ans = (ans + m) % (n - i + j); printf("%d ", ans + 1); &#125; return 0;&#125; 推导递推公式*以解法五为例，在递归函数部分代码中 12345int Josephus(int x, int y, int z)&#123; if (z == 1) return (y - 1) % x; return (Josephus(x - 1, y, z - 1) + y) % x;&#125; x代表总人数，y代表每次报y的人出列，z是次数，该函数可以求第y次出圈的人的编号。 举个例子：总人数x为6人，从1开始，每报到3就出圈（z = 3） 初始情况：1 2 3 4 5 6 通过递推的方式使第一个幸运观众出圈之后：1 2 4 5 6 此时，这些编号已经不能组成一个环，但是2和4之间还是连着的，且下一次报数将从4开始。然而，之后的报数将总要考虑3处的空位问题。 如何避免空位对报数所造成的影响？ 可以将剩下的4个数重新组合成一个新的环，这样报数的时候就不必在意3的空缺了。但是新产生的环的数字并非连续的，报数时不能直接用+ y再% x的简单递推方式，这下真令人头大。 如何使新环上的编号依然能够递推？ 可以建立一种有确定规则的映射，要求映射之后的数字可以递推，且可以将在新环中继续按原规则报数得到的结果逆推出在旧环中的对应数字。 阻止我们使用老办法递推的因素就是3号出圈之后产生的新环编号不连续，那么，我们可以通过建立某种映射，使得新环的编号依然连续，方便我们继续使用递推的方法。 原始：1 2 3 4 5 6 旧环：1 2 _ 4 5 6 新环：4 5 _ 1 2 3 正如你所见，相比于旧环中2和4之间被割裂开，新环的5和1之间在对5取余的基础上是完美连续的，这就意味着我们可以继续从新环的1（即旧环的4）开始实施我们的递推方法。且只要推导出新环与旧环的映射关系，就能从在新环中报数的结果得知在旧环中的报数结果。 对于第二个幸运观众： 旧环：1 2 _ 4 5 *6 新环：4 5 _ 1 2 *3 如何从新环的3得到旧环的6呢？其实可以简单地逆推回去 : 新环是由(旧环中编号 - 报数值) % 旧环总人数得到的，所以逆推时可以由(新环编号 + 报数值) % 旧环总人数得到。 如：(3 + 3) % 6 = 0 咦？奇怪怎么是0？不是应该是6吗？这就涉及到一个进位的问题。由于旧环的编号为1~6，而我们在新环依然保留了1~5的编号并确保5和1之间在对5取余的基础上连续，这就导致了5 % 5 = 0，也就是说5与0是无法区分的。因此，虽然实际上旧环编号为6的幸运观众出圈，但是我们的计算结果依然不可避免地把它对6取余，得到一个看似奇怪却又顺理成章的0。 如何避免错误地把最大的数算成0的情况？ 把所有数减1即可，最后输出结果的时候再加上1。让我们再来一遍： 对于第二个幸运观众： 旧环：0 1 _ 3 4 *5 新环：3 4 _ 0 1 *2 从新环推出旧环的幸运观众：(2 + 3) % 6 = 5 由上得，原序列x中第二次出圈的编号可以由新序列x - 1第一次出圈的编号通过特定的逆推运算得出。即在以y为出环报数值的约瑟夫环中，x人环的第z次出环编号可以由x - 1人环中的第z - 1次出环编号通过也定的运算推出。 幸运的是，第一次出环的编号是可以直接求出的，也就是说，对于任意次出环的编号，我们可以将之一直转化为第一次出环的编号问题，再一一迭代求出；也可以把第一次出环的编号作为递归基础，通过递归求出。 因此我们可以写出Josephus函数的递推公式如下： Josephus(x,y,z) = \begin{cases} [Josephus(x-1,y,z-1) + y] \% x ,& \text{z > 1} \\ (y-1)\%x , & \text{z = 1} \end{cases}结束语以上就是关于约瑟夫环问题的六种解法，并送上调试过的C++代码，作者水平不高，将就看看吧 ╮(╯_╰)╭ *. 参考该网站，感谢作者的写作 &#8617;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++指针变量]]></title>
    <url>%2FG-SS-Hacker.github.io%2Fc-%E6%8C%87%E9%92%88%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[指针变量 Guderian出品 指针变量的定义、赋值对指针变量的类型说明，一般形式为： 类型说明符 *变量名; 其中，表示这是一个指针变量，变量名即为定义的指针变量名，类型说明符表示*该指针变量所指向的变量的数据类型。 1、普通变量定义int a = 3; 定义了变量a，是int型的，值为3。内存中有一块内存空间是放a的值，对a的存取操作就是直接到这个内存空间存取。内存空间的位置叫地址，存放3的地址可以用取地址操作符&amp;对a运算得到：&amp;a。 2、指针变量定义int *p = NULL; 定义了一个指针变量p，p指向一个内存空间，里面存放的是一个内存地址。现在赋值为NULL（其实就是0，表示特殊的空地址）。 3、给指针变量p赋值p = &amp;a; 即把a变量的内存空间地址（比如：XXX）给了p。显然，直接对p存取，操作的是地址。通过这个地址间接地操作，才是整数3。P的间接操作要使用指针操作符“*”，即*p的值才是3。设有指向整型变量的指针变量p，如要把整型变量a的地址赋予p可以有以下两种方式： ①指针变量初始化的方法 int a; int *p = &amp;a; ②赋值语句的方法 int a; int *p; p = &amp;a; 不允许把一个数赋予指针变量，故如下的赋值是错误的：int *p；p = 1000；。被赋值的指针变量前不能再加“*”说明符，故如下的赋值也是错误的：*p = &amp;a；。 指针的几个相关操作说明表| 说明 | 样例 || ————————————————— | ————————————————|| 指针定义：类型说明符 *指针变量名 | int *p; || 取地址运算符：&amp; | p = &amp;a; || 间接运算符：* | *p = 20; || 指针变量直接存取的是内存地址 | cout&lt;&lt;p;结果可能是：0x24ae9d || 间接存取的才是存储类型的值 | cout&lt;&lt;*p;结果是：20 | 指针变量同普通变量一样，使用之前不仅要定义说明，而且必须被赋值具体的值，未经赋值的指针变量不能使用。如定义了int a; int *p = &amp;a;，则*p表示p指向的整型变量，而p中存放的是变量a占用单元的起始地址，所以*p实际上访问了变量a，也就是说*p$ \Longleftrightarrow $a。 【例1】输入两个不同的数，通过指针对两个数进行相加和相乘，并输出。 123456789101112131415#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; int a, b, s, t, *pa, *pb; pa = &amp;a; pb = &amp;b; a = 10; b = 20; s = *pa + *pb; t = *pa * *pb; printf("a = %d, b = %d\n", *pa, *pb); printf("s = %d, t = %d\n", s, t); return 0;&#125; 输出： 12a = 10, b = 20s = 30, t = 200 指针的引用与运算一般的，指针(int *p)与普通变量(int a)的对应关系为： 指针变量 普通变量 p &amp;a *p a *p = 3 a = 3 以下为指针的一些运算： 1、指针变量的初始化指针的几个初始化操作说明表| 方法 | 说明 || ——————————- | ————————————————- || int *p = NULL; | NULL是特殊的地址0，叫零指针 || int a; int *p = &amp;a; | p初始化为a的地址 || int *p = new(int); | 申请一个空间给p，*p内容不确定 | 要强调的是，对于定义的局部指针变量，其内容（地址）是随机的，直接对它操作可能会破坏程序或系统内存的值，引发不可预测的错误。所有编程中指针变量要保证先初始化或赋值，给予正确的地址再使用，避免产生*野指针。 2、指针变量的+、-运算指针变量的内容是内存地址，它有两个常用的运算：加、减，这两个运算一般都是配合数组操作的。 【例2】输入N个整数，使用指针变量访问输出。 123456789101112131415161718#include &lt;cstdio&gt;using namespace std;int a[101], n;int main()&#123; scanf("%d",&amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); int p = &amp;a[1]; //定义指针变量int p，初始化为数组开始元素的地址，即a[1]; for (int i = 1; i &lt;= n; i++) &#123; printf("%d ", *p); p++; //p指向下一个数，详见说明 &#125; return 0;&#125; 输入： 1242 1 6 0 输出： 12 1 6 0 【说明】 p++的意思是“广义的加1”，不是p的值（地址）加1，而是根据类型int增加sizeof（int），即刚好“跳过”一个整数的空间，达到下一个整数。 类似的： ①p--就是向前“跳过”一个整数的空间，达到前一个整数。 ②(p + 3)就是指向后面第3个整数的地址。 3、无类型指针有时候，一个指针根据不同的情况，指向的内容是不同类型的值，我们可以先不明确定义它的类型，只是定义一个无类型的指针，以后根据需要再用强制类型转换的方法明确它的类型。 【例3】无类型指针运用举例。 123456789101112131415#include &lt;iostream&gt;using namespace std;int a = 10;double b = 3.5;void *p;int main()&#123; p = &amp;a; //p的地址赋值 cout&lt;&lt;*(int*)p&lt;&lt;endl; //必须明确p指向的空间的数据类型，详见说明 p = &amp;b; cout&lt;&lt;*(double*)p&lt;&lt;endl; return 0;&#125; 输出： 12103.5 【说明】 必须明确p指向的空间的数据类型，类型不一样的不仅空间大小不相同，储存的格式也不同。如果把cout&lt;&lt;*(double*)p&lt;&lt;endl;改成cout&lt;&lt;*(long long*)p&lt;&lt;endl;输出的结果将是：4615063718147915776。 4、多重指针既然指针是指向其他类型的，指针本身也是一种类型。因此，C++允许递归地指针指向指针的指针——多重指针。 【例4】双重指针运用举例。 1234567891011121314#include &lt;cstdio&gt;using namespace std;int a = 10;int *p;int **pp; //定义双重指针int main()&#123; p = &amp;a; //将p指向a pp = &amp;p; //将pp指向p printf("%d = %d = %d\n", a, *p, **pp); //**pp通过2次间接访问了a的变量的值10 return 0;&#125; 输出： 110 = 10 = 10 【说明】 多重指针可以多次“间接”访问数据；竞赛上主要的应用是*动态的多维数组，功能十分强大！！！]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[野指针的产生及其危害]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E9%87%8E%E6%8C%87%E9%92%88%E7%9A%84%E4%BA%A7%E7%94%9F%E5%8F%8A%E5%85%B6%E5%8D%B1%E5%AE%B3%2F</url>
    <content type="text"><![CDATA[野指针的产生及其危害 Guderian出品 野指针指向了一块随机内存空间，不受程序控制。如指针指向已经被删除的对象或者指向一块没有访问权限的内存空间，之后如果对其再进行引用的话，就会出现问题。 成因指针变量未初始化任何指针变量（无static修饰的局部变量）刚被创建时不会自动成为*NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。如果没有初始化，编译器会报错。 注：NULL指针是一个定义在标准库中的值为零的常量，其定义为： 1#define NULL ((void *)0) 指针释放之后未置空又是指针在free或delete后未赋值NULL，便会使人以为是合法的。然而free和delete只是把指针所指的内存给释放掉，并没有把指针本身干掉。此时指针指向的是随机内存空间。释放指针后应立即将指针置为NULL，防止产生野指针。 指针操作超越变量作用域返回或引用指向*栈内存的指针，因为栈内存在函数结束的时候会被释放 后果 指向不可访问地址，造成程序异常终止 指向可用空间，但是这块空间不适用，程序正常运行 指向可用空间，但是这块空间刚好在用，造成数据错误 规避初始化时置NULL指针变量一定要初始化为NULL，因为任何指针变量（无static修饰的局部变量）刚被创建时不会自动成为NULL指针，它的缺省值是随机的。 释放时置NULL当指针p指向的内存空间释放时，没有设置指针p的值为NULL。delete和free只是把内存空间释放了，但是并没有将指针p的值赋为NULL。通常判断一个指针是否合法，都是使用if语句测试该指针是否为NULL。例如（针对C++）： 123int *p = new int(6);delete p;if(p != NULL) *p = NULL; 或者使用宏定义来一次性解决问题： 1#define del(x) delete(x); x = NULL]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python运算符优先级]]></title>
    <url>%2FG-SS-Hacker.github.io%2FPython%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[Python运算符优先级 Guderian出品 .tg {border-collapse:collapse;border-spacing:0;}.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg .tg-ncd7{background-color:#ffffc7;border-color:inherit;text-align:left;vertical-align:top}.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top} 运算符描述 Python运算符 优先级 （*不常用） 索引运算符 x[index] 或x[index:index2[:index3]] 18、19 （*不常用） 属性访问 x.attribute 17 算术运算符 乘方 ** 16 位运算符 按位取反 ~ 15 符号运算符 +（正号）或 -（负号） 14 算术运算符 乘、除 *、/、//、% 13 加、减 +、- 12 位运算符 位移 &gt;&gt;、&lt;&lt; 11 按位与 &amp; 10 按位异或 ^ 9 按位或 | 8 比较运算符 ==、!=、&gt;、&gt;=、&lt;、&lt;= 7 身份运算符 is、is not 6 成员运算符 in、not in 5 逻辑运算符 逻辑非 not 4 逻辑与 and 3 逻辑或 or 2]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C和C++中memset用法]]></title>
    <url>%2FG-SS-Hacker.github.io%2FC%E5%92%8CC-%E4%B8%ADmemset%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[想更方便地初始化吗？Just use memset()!!! C/C++中memset()的用法 Guderian出品 头文件 C： &lt;string.h&gt; C++： &lt;cstring&gt; 声明void *memset(void *str, int c, size_t n) 此处size_t变量类型等价于long unsigned int即无符号长整型，在32位机器上为32位，在64位机器为中64位。 注：32位机器指CPU通用寄存器的数据宽度为32位，也就是说CPU一次可以运行32bit数据 描述复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。 参数 str ——指向要填充的代码块 c——要被设置的值该值以 int 形式传递，但是函数在填充内存块时是使用该值的无符号字符形式。 n——要被设置为该值的字节数。 返回值返回一个指向存储区 str 的指针。 实例对字符串操作123456789101112131415#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main ()&#123; char str[50]; strcpy(str,"This is string.h library function"); puts(str); memset(str,'$',7); puts(str); return(0);&#125; 编译并运行以上程序，得到结果如下： 12This is string.h library function$$$$$$$ string.h library function 初始化数组注意：c接收参数的范围0-255 ，该函数只能取c的后八位赋给你所指定的范围的每个字节 初始化为0memset(arr, 0, sizeof(arr)); 初始化为-1memset(arr, -1, sizeof(arr));或memset(arr, 0x7fffffff,sizeof(arr)); 初始化为正无穷 理论上的正无穷：memset(arr, 0x7f, sizeof(arr)); 实际使用的正无穷：memset(arr, 0x3f, sizeof(arr)); 注：D（decimal）——十进制，B（binary）——二进制，O（octor）——八进制，H（hex）——十六进制 初始化为负无穷 理论上的负无穷：memset(arr, 0x80, sizeof(arr)); 实际使用的负无穷：memset(arr, 0xbf, sizeof(arr)); 注：此处要设置的值也可用二进制表示，如0xbf等价于0b10111111]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构绪论]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[基本概念与术语、逻辑结构与物理结构、抽象数据类型 数据结构绪论 Guderian出品 基本概念与术语数据数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅包括整型、实数型等数值类型，还包括字符及声音、图像、视频等非数值类型（严格地说，布尔型也属于数据）。 综上，我们这里说的数据，其实就是符号，且必须具备两个前提： 可以输入到计算机中 能被计算机程序处理 数据元素数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。 数据项数据项：数据不可分割的最小单位。但在真正讨论问题时，数据元素才是数据结构中建立数据模型的着眼点。 数据对象数据对象：性质相同的数据元素的集合，是数据的子集。 数据结构数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。 逻辑结构与物理结构逻辑结构逻辑结构：是指数据对象中数据元素之间的相互关系。 集合结构：地位平等、同属于一个集合。 线性结构：一对一。 树形结构：一对多。 图形结构：多对多。 逻辑结构针对具体问题，是为了解决某个问题，在对问题理解的基础上，选择一个合适的数据结构表示数据元素之间的逻辑关系。 物理结构物理结构（有名存储结构）：数据的逻辑结构在计算机中的存储形式。 顺序存储结构：地址连续的存储单元。 链式存储结构：任意的存储单元。 抽象数据类型数据类型数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。 数据类型可分两类： 原子类型：不可分解，如整形、实型、字符型。 结构类型：可分解，如整型数组、字符串。 抽象数据类型抽象数据类型（Abstract Data Type）：是指一个数学模型及定义在该模型1及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性。而与其在计算机内部如何表达和实现无关。 抽象：抽取出事物具有的普遍性的本质。”抽象“的意义在于数据类型的数学抽象特性。 抽象数据类型不仅指那些已经定义并实现的数据类型（如整型），还可以是计算机编程者在设计软件程序时自己定义的数据类型（如三维坐标(x, y, z)）。 描述抽象数据类型的标准格式： 12345678910ADT 抽象数据类型Data 数据类型之间逻辑关系的定义Operation 操作1 初始条件 操作结果描述 操作2 ……endADT]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算思维导论]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E8%AE%A1%E7%AE%97%E6%80%9D%E7%BB%B4%E5%AF%BC%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[计算思维的本质是抽象与自动化 计算思维导论 Guderian出品 计算思维的发展 计算机的思维：计算机室如何工作的？计算机的功能是如何越来越强大的? 利用计算机的思维：现实世界的各种食物如何利用计算机进行控制和处理？ 计算思维：利用计算机科学的基础概念去求解问题、设计系统和理解人类行为，其本质是抽象与自动化。 学习步骤 概念与知识 联想与贯通 练习与实践 人计算与机器计算的差别人计算： 规则可能很复杂，但计算量却可能很小 人需要知道具体的计算规则 只能使用特定规则 机器计算（自动计算）： 规则可能很简单，但计算量却可能很大 机器也可以使用人的计算规则 使用一般性的规则 自动计算要解决的几个问题：表示-存储-执行 数据的表示 计算规则的表示 数据与计算规则的自动存储 计算规则的自动执行 自动计算的发展历程 如算盘（计算辅助工具）：可以表示数据，不能自动计算 帕斯卡机械计算机：自动计算，固定的计算规则 巴贝奇机械计算机：特定程序，可有限变化的计算规则 现代电子计算机：一般程序，任意可变的计算规则 电子计算机元器件的发展 电子管 晶体管 集成电路 超大规模集成电路（VLSI） 计算机系统的组成 运算器 控制器 存储器 输入设备 输出设备 计算机系统的发展趋势 微型化：可嵌入，可携带 大型化：可进行大规模复杂计算 智能化：理解自然语言，具有自适应性，自主完成复杂功能 网络化：机-机相连，物-物相连，物-人相连，人-人相连，如：IoT，IBM提出”智慧地球”]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>计算思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown需要转义的字符及其转义方法]]></title>
    <url>%2FG-SS-Hacker.github.io%2FMarkdown%E9%9C%80%E8%A6%81%E8%BD%AC%E4%B9%89%E7%9A%84%E5%AD%97%E7%AC%A6%E5%8F%8A%E5%85%B6%E8%BD%AC%E4%B9%89%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Markdown需要转义的字符及其转义方法 Guderian出品 123456789101112\\ 反斜杠\` 反引号\* 星号\_ 下划线\&#123;\&#125; 大括号\[\] 中括号\(\) 小括号\# 井号\+ 加号\- 减号\. 英文句号\! 感叹号]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Python的坑]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E5%85%B3%E4%BA%8EPython%2F</url>
    <content type="text"><![CDATA[关于Python Guderian出品 学习步骤： [ ] 配置环境，安装Python IDLE [ ] Variale（变量）：int（整形），float（浮点型），str（字符串），bool（布尔型） [ ] Data Type（数据类型）：Number（数字），String（字符串），List（列表），Tuple（元组），Set（集合），Dictionary（字典） [ ] 运算符及其优先级 [ ] 分支和循环 换行符号：\n BIF == Built-in function（__builtins__），即内置函数 Python是动态类型语言、脚本语言（编写速度很快） 变量不能以数字开头且区分大小写 字符串可用单引号或双引号表示 转义字符：\甚至可以转义自身 原始字符串：r&#39;...&#39; 小数达到16位及以上时使用E计数法 配合random模块，random.choice()可从一个非空序列中随机获取一个元素 isinstance(a,b)验证变量a的类型是否是b 保留小数数位round(a,b)：对小数a保留b位（b == 0则为x.0) 格式化输出：输出a，保留x位小数 print(‘%.xf’ %a)，中间无逗号 三元操作符：（非常容易出错）： a = x if 条件 else y assert（断言），当关键字右面条件为真时没有反应，为假时程序自动崩溃并抛出AssertionError异常 Int / int会得到float，哪怕不带小数点，千万注意 print得到的东西会自带换行，要避免的话：print(输出, end = ‘’) 短路逻辑：A and B，如果A == False，那么不判断B直接返回False 可迭代对象：列表、元组、字典、文件、集合、生成器 使用max()和min()要保证序列的数据类型统一 sorted()返回一个排好序的列表 reverse()返回一个翻转的迭代器对象 enumerate()生成由二元组构成的一个迭代对象，每个二元组由迭代参数索引号及对应元素组成 zip(iter1,iter2,...)返回各个可迭代参数共同构成的元组，取最短，分先后 在定义函数的时候，位置参数必须在默认参数的前面，否则就会出错 星号（）在形参中的作用是“打包”，在实参中的作用是“*解包” and和or操作符的用法说明：3 and 4返回后一个4，3 or 4返回前一个3 `print`的参数：`print(*object, sep=' ', end='\n', file=sys.stdout, flush=False)` 函数内部只能访问全局变量，不能修改，非要修改可以使用global关键字声明，但不可用于嵌套函数 Python 模块(Module)，是一个 Python 文件，以 .py 结尾，包含了 Python 对象定义和Python语句 dir(模块)返回的列表容纳了在一个模块里定义的所有模块，变量和函数 Python中的整数区间均为左闭右开，负数区间均为左闭右闭 要完成列表的拷贝必须用分片，即了lis1 = lis2[:]，绝不可以直接lis1 = lis2，因为变量名是“贴”在变量上的，变量名与变量之间并非一一对应关系 列表解析式（或列表推导式）：[有关A的解析式 for A in B]]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2FG-SS-Hacker.github.io%2Fhello-world%2F</url>
    <content type="text"><![CDATA[多种语言实现Hello World Starter Guderian出品 Python1print("hello world") C123456#include&lt;stdio.h&gt;int main()&#123; printf("hello world"); return 0;&#125; C++12345678#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; cout&lt;&lt;"hello world"; return 0;&#125; C#123456789using System; class TestApp &#123; public static void Main() &#123; Console.WriteLine(&quot;hello world&quot;); Console.ReadKey(); &#125; &#125; Pascal1234Program HelloWorld(output); begin writeln('hello world') end. Java1234567public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println("hello world"); &#125; &#125;]]></content>
      <tags>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>Python</tag>
        <tag>C#</tag>
        <tag>Pascal</tag>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
