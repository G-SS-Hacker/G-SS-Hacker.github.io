<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[机器学习中的评价指标：F1-score]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87%EF%BC%9AF1-score%2F</url>
    <content type="text"><![CDATA[机器学习中的评价指标：F1-score 图：西雅图（Seattle） Guderian出品 回顾：F1-score的计算过程混淆矩阵（Confusion Matrix） 混淆矩阵也称误差矩阵，是表示精度评价的一种标准格式，用n行n列的矩阵形式来表示。 在机器学习领域，混淆矩阵用于衡量一个分类器的准确程度。对于二分类问题，将其样例根据真实类别和分类器的预测类别的组合划分为真正例$\mathrm{(True \, Positive)}$、假正例$\mathrm{(False \, Positive)}$、真反例$\mathrm{(True \, Negative)}$、假反例$\mathrm{(False \, Negative)}$四种情形。 对应混淆矩阵$\mathrm{(Confusion \, Matrix)}$如下表： .tg {border-collapse:collapse;border-spacing:0;}.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg .tg-0lax{text-align:left;vertical-align:top}.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top} 真实情况 预测结果 真 假 真 TP（真正例） FN（假反例） 假 FP（假正例） TN（真反例） 精确率（Precision）与召回率（Recall）根据混淆矩阵，我们可以得到如下定义： 精确率$\mathrm{(Precision)}$ $\mathrm{P=\frac{TP}{TP+FP} \times 100\%}$，表示真实情况和预测结果皆为真/预测结果为真 召回率$\mathrm{(Recall)}$ $\mathrm{R=\frac{TP}{TP+FN} \times 100 \%}$，表示真实情况和预测结果皆为真/真实情况为真 F1分数（F1-score） F1分数（$\mathrm{F1-score}$）即精确率与召回率的调和平均数（$\mathrm{Harmonic \, Mean}$），比算术平均数（$\mathrm{Arithmetic \, Mean}$）的评价效果更好。 $\mathrm{F1=\frac{2}{\frac1{P}+\frac1{R}}=\frac{2PR}{P+R}}$ 直观理解为什么F1-score能评价模型优劣在你训练的机器学习模型过程中，你往往希望能够兼顾精确率和召回率，并使用一个统一的单值评价指标来评价你的机器学习模型的训练效果。我们之所以使用调和平均而不是算术平均，是因为在算术平均中，任何一方对数值增长的贡献相当，任何一方对数值下降的责任也相当；而调和平均在增长的时候会偏袒较小值，也会惩罚精确率和召回率相差巨大的极端情况，很好地兼顾了精确率和召回率。 几何观点 上图为函数图象$z=f(x, y)=\frac{2xy}{x+y}$。显而易见当$x=1$，$y=0$或者$y=1$，$x=0$时，$z=0$，说明调和平均惩罚精确率和召回率相差很大的极端情况。当$x&lt;y$时，梯度$\mathrm{grad} \, z $在$x$方向增长比$y$方向快；当$y&lt;x$时，梯度$\mathrm{grad} \, z$在$y$方向增长比$x$方向快，即调和平均在增长的时候会偏袒较小值。 代数观点对函数$f(x, y)=\frac{2xy}{x+y}$，其图象关于平面$x=y$对称。分别求$f(x,y)$对$x$和$y$的偏导数： ​ $\frac{\partial f(x,y)}{\partial x}=\frac{2y^2}{(x+y)^2}$ ​ $\frac{\partial f(x,y)}{\partial y}=\frac{2x^2}{(x+y)^2}$ 当$x&lt;y$时，$\frac{\partial f(x,y)}{\partial x}&gt;\frac{\partial f(x,y)}{\partial y}$，梯度$\mathrm{grad} \, z $在$x$方向增长比$y$方向快； 当$y&lt;x$时，$\frac{\partial f(x,y)}{\partial y}&gt;\frac{\partial f(x,y)}{\partial x}$，梯度$\mathrm{grad} \, z$在$y$方向增长比$x$方向快，即调和平均在增长的时候会偏袒较小值。 可以看出，$\mathrm{F1-score}$是一种综合的评价指标,它要求总体高指标必须建立在同时满足高精确率和高召回率的情况之上。使得我们可以更方便快速地对不同模型进行比较，从而选择最优的那个模型。 Reference and lots of thanks：https://blog.csdn.net/otengyue/article/details/89426004]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C & C++基本数据类型取值范围]]></title>
    <url>%2FG-SS-Hacker.github.io%2FC%E5%92%8CC-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4%2F</url>
    <content type="text"><![CDATA[C &amp; C++基本数据类型取值范围 图：伦敦（London） Guderian出品 .tg {border-collapse:collapse;border-spacing:0;}.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top} 基本数据类型 关键字 存储大小 取数范围 整型 基本整型 int 4字节 -2^31 ~ 2^31-1 实型 长整型 long 4字节 -2^31 ~ 2^31-1 短整型 short 2字节 -2^15 ~ 2^15-1 无符号整型 unsigned unsigned int 4字节unsigned long 4字节unsigned short 2字节 unsigned int : 0 ~ 2^32-1unsigned long : 0 ~ 2^32-1unsigned short : 0 ~ 2^16-1 实型 单精度实型 float 4字节 1.2E-38 ~ 3.4E+38 精度6位小数 双精度实型 double 8字节 2.3E-308 ~ 1.7E+308 精度15位小数 长双精度实型 long double 16字节 3.4E-4932 ~ 1.1E+4932 精度19位小数 字符型 char 1字节 0 ~ 2^8-1 枚举类型 enum 我们不管遇到多复杂的数据类型都不要怕，我们戴口罩面对它。消除恐惧的最好办法就是面对恐惧！坚持就是胜利！学好C语言！奥利给！]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C-plus-plus</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Softmax函数反向传播求导详细过程]]></title>
    <url>%2FG-SS-Hacker.github.io%2FSoftmax%E5%87%BD%E6%95%B0%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E6%B1%82%E5%AF%BC%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Softmax函数反向传播求导详细过程 图：纽约，曼哈顿（Manhattan, New York） Guderian出品 回顾：Softmax函数正向传播第一步：计算Z函数对神经网络输出层（即第$ L $层）有$Z^{[L]}=W^{[L]}a^{[L-1]}+b^{[L]}$，其中$a^{[L-1]}$为上一层输出值。 第二步：计算Softmax函数for i in range(1, C + 1): ​ $\quad a_i^{[L]}=\frac{e^{Z_i^{[L]}}}{\sum_{k=1}^C e^{Z_k^{[L]}}}$ 其中$C$表示要预测的类别数，上式满足$\sum_{i=1}^C a_i{[L]}=1$，即输入样本属于各类别的概率和为$1$。 第三步：计算损失函数单个样本的损失函数为$L(a,y)=-\sum_{i=1}^C y_i\log{a_i}$，其中$y$为目标输出。 求导第一步：对Softmax函数求导​ 对$\mathrm{Softmax}$函数求导，即求$\frac{\partial a_i}{\partial z_j}$：第$\mathrm{i}$项输出对第$\mathrm{j}$项输入的偏导数。 ​ $\frac{\partial a_i}{\partial z_j}=\frac{\partial\frac{e^{z_i}}{\sum_{k=1}^C e^{z_k}}}{\partial z_j}$（省略$[ L ]$标记，默认为第$ L $层，下同），分类讨论： ​ $(1)$当$\mathrm{i=j}$时，把$a_i$分母中除$e^{z_j}$项外视作常量 ​ $\frac{\partial a_i}{\partial z_j}=\frac{\partial\frac{e^{z_j}}{\sum_{k=1}^C e^{z_k}}}{\partial z_j}=(\frac{e^{z_j}}{e^{z_j}+\sum_{k\ne j}^C e^{z_k}})^\prime=a_j(1-a_j)$ ​ $(2)$当$\mathrm{i\ne j}$时，把$a_i$分子和分母中除$e^{z_j}$项外视作常量 ​ $\frac{\partial a_i}{\partial z_j}=\frac{\partial\frac{e^{z_i}}{\sum_{k=1}^C e^{z_k}}}{\partial z_j}=(\frac{e^{z_i}}{e^{z_j}+\sum_{k\ne j}^C e^{z_k}})^\prime=\frac{e^{z_i}e^{z_j}}{\sum_{k=1}^C e^{z_k}}=-a_i a_j$ 第二步：对损失函数求导对损失函数求导，即求$\frac{\partial L}{\partial z_j}$：损失函数对第$\mathrm{j}$项输入的偏导数。 ​ $\because L(a,y)=-\sum_{i=1}^C y_i\log{a_i}$ ​ $\therefore \frac{\partial L}{\partial z_j}=-\sum_{i=1}^C y_i\frac{\partial \log a_i}{\partial z_j}=-\sum_{i=1}^C \frac{y_i}{a_i}\frac{\partial a_i}{\partial z_j}$ （把$y_i$视作常量，再用链导法则转化为对$\mathrm{Softmax}$函数求导） 分别代入$(1)(2)$得： $-\sum_{i=1}^C \frac{y_i}{a_i}\frac{\partial a_i}{\partial z_j}=-\frac{y_i}{a_i}\frac{\partial a_i}{\partial z_j} \, -\sum_{i=1,i \ne j}^C \frac{y_i}{a_i}\frac{\partial a_i}{\partial z_j}$ ​ ​ $\quad =$ $-\frac{y_j}{a_j}a_j(1-a_j)\,+\sum_{i=1,i \ne j}^C \frac{y_i}{a_i}a_ia_j$ ​ $\quad =$ $-y_j\, +y_ja_j\, +\sum_{i=1,i \ne j}^C y_ia_j$ ​ $\quad =$ $-y_j\, +\sum_{i=1}^C y_ia_j$ （合并$y_ja_j$至$\sum_{i=1,i \ne j}^C y_ia_j$中） ​ $\quad =$ $-y_i\, +a_j\sum_{i=1}^C y_i$ （提出$a_j$） ​ $\quad =$ $a_j-y_j$ 从上述结果可以看出，$\mathrm{Softmax}$回归和$\mathrm{Logistic}$回归中损失函数求导后具有相同的形式，这也说明了$\mathrm{Softmax}$回归和$\mathrm{Logistic}$回归具有相同的本质，$\mathrm{Softmax}$回归是$\mathrm{Logistic}$的推广。 Reference and lots of thanks：https://www.cnblogs.com/zhaopAC/p/9539118.html]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>神经网络</tag>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML状态图]]></title>
    <url>%2FG-SS-Hacker.github.io%2FUML%E7%8A%B6%E6%80%81%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[【面向对象分析UML建模工具全部文章】 UML建模工具(1)——用例图 UML建模工具(2)——活动图 UML建模工具(3)——类图 UML建模工具(4)——顺序图 UML建模工具(5)——通信图 UML建模工具(6)——状态图 UML建模工具——状态图 图：马来西亚，吉隆坡（Kapa Lumpur） Guderian出品 状态图(Statechart Diagram)是描述一个实体（对象）基于事件反应的动态行为 完整的状态图例子 状态图的建模元素状态（State） 状态亮灯如上图所示，状态用圆角矩形表示，其中可以包括： 名称 进入动作 退出动作 内部迁移 子状态 事件（Event） 事件可视作引起一个状态迁移至另一个状态的激励条件 如以上状态图中，事件会员收货使得状态订单发货迁移至订单收货。 事件必须有意义，只有有意义的事件才会促成状态迁移，无意义的事件对状态不产生影响。 迁移（Transition） 如上图所示，迁移为状态之间的关联，且必须有事件触发器并满足一定触发条件才会产生状态间的迁移。 迁移由5部分组成： 源状态 事件触发器 触发条件 效应 目标状态 状态图建模注意事项 一个状态必须与其他状态有关联，不允许孤立存在 不允许只进不出或只出不进的迁移 不允许没有事件的迁移 Reference：https://edu.csdn.net/course/play/24559/273459]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>软件工程</tag>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML通信图]]></title>
    <url>%2FG-SS-Hacker.github.io%2FUML%E9%80%9A%E4%BF%A1%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[【面向对象分析UML建模工具全部文章】 UML建模工具(1)——用例图 UML建模工具(2)——活动图 UML建模工具(3)——类图 UML建模工具(4)——顺序图 UML建模工具(5)——通信图 UML建模工具(6)——状态图 UML建模工具——通信图 图：旧金山湾，黑夜中的金门大桥（Golden Gate Bridge） Guderian出品 通信图（Communication diagram）和顺序图都属于UML交互图，与顺序图本质上是一样的，可以互换 但二者建模的角度不同 1 通信图 强调随着时间的推移，各对象是如何交互的 通信图 强调对象之间的结构关系 通信图的组成元素 对象（object） 链接（link） 注意虽然链接和关联的图形都是一条实线，但是此处的链接是对象之间的关系，而关联是类之间的关系 消息（message） 完整的通信图例子 技术员张三创建了一个工具 技术员张三使用了这个工具 2.1 工具检查了A103号锅炉 2.2 工具维修了A103号锅炉 技术员张三销毁了这个工具 1. http://coursehome.zhihuishu.com/courseHome/2049439#teachTeam &#8617;]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>软件工程</tag>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML顺序图]]></title>
    <url>%2FG-SS-Hacker.github.io%2FUML%E9%A1%BA%E5%BA%8F%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[【面向对象分析UML建模工具全部文章】 UML建模工具(1)——用例图 UML建模工具(2)——活动图 UML建模工具(3)——类图 UML建模工具(4)——顺序图 UML建模工具(5)——通信图 UML建模工具(6)——状态图 UML建模工具——顺序图 图：旧金山湾区，晚霞下的泛美金字塔（Transamerica Pyramid） Guderian出品 顺序图和通信图都属于UML交互图 顺序图（Sequence）是场景（Scenario）的图形化表示，描述了以时间顺序组织的对象之间的交互活动 完整的UML顺序图例子 基本建模元素 对象 对象生命线 控制焦点 消息：调用消息、返回消息、异步消息、自关联消息 对象销毁 结构化控制 同步消息与异步消息同步消息 发送方向接收方发送消息，接收方接收此消息并回复发送方。发送者在收到接收者的回复之前不会发送另一条消息。 如：老师想张三问了一个问题，张三必须当场给予回复，老师才会问下一个同学问题。 异步消息 发送方向接收方发送消息，发送者在收到接收者的回复之前可以进行其他活动。 如：老师给张三布置了一个问题，让张三课后思考一下如何解决，然后问其他同学问题。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>软件工程</tag>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML类图]]></title>
    <url>%2FG-SS-Hacker.github.io%2FUML%E7%B1%BB%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[【面向对象分析UML建模工具全部文章】 UML建模工具(1)——用例图 UML建模工具(2)——活动图 UML建模工具(3)——类图 UML建模工具(4)——顺序图 UML建模工具(5)——通信图 UML建模工具(6)——状态图 UML建模工具——类图 图：巴尔的摩（Baltimore） Guderian出品 本文部分内容演绎自：https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html 用例图和活动图用于需求分析，当需求明确之后，则需要用类图进行设计。 回顾什么是类（Class）？ 具有相同属性、方法的一组对象的描述符 什么是对象（Object）？ 对象是类的实例 什么是类图（Class diagram）？ 把类相关的元素画在一起，即为类图 （玄之又玄，众妙之门） 完整的类图例子 1 车的类图结构为&lt;&lt;abstract&gt;&gt;，表示车是一个抽象类； 它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示； 小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示； 小汽车与发动机之间是组合关系，使用带实心箭头的实线表示； 学生与班级之间是聚合关系，使用带空心箭头的实线表示； 学生与身份证之间为关联关系，使用一根实线表示； 学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示； 类图中的元素 类 接口 协作 类之间的关系 关系类型 说明 表示符号 依赖（Dependency） 独立事物发生变化会影响依赖事物 关联（Association） 整体与部分关系 泛化（Generalization） 特殊/一般关系 实现（Realization） 实现表示一个class类实现interface接口（可以是多个）的功能 聚合（Aggregation） A has B，B是A的一部分，但A不控制B的生命周期 组合（Composition） A has B，B是A的一部分，且A控制B的生命周期 依赖（Dependency） 1依赖关系是用一套带箭头的虚线表示的；如下图表示A依赖于B；他描述一个对象在运行期间会用到另一个对象的关系； 与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化； 依赖关系也可能发生变化； 显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生； 注：在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方外，还是“使用”对方的方法和属性； 关联（Association） 1关联关系是用一条直线表示的；它描述不同类的对象之间的结构关系；它是一种静态关系， 通常与运行状态无关，一般由常识等因素决定的；它一般用来定义对象之间静态的、天然的结构； 所以，关联关系是一种“强关联”的关系； 比如，乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系； 关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如下图，表示A知道B，但 B不知道A； 注：在最终代码中，关联对象通常是以成员变量的形式实现的； 泛化（Generalization） 1类的继承结构表现在UML中为：泛化(generalize)与实现(realize)： 继承关系为 is-a的关系；两个对象之间如果可以用 is-a 来表示，就是继承关系：（..是..) eg：自行车是车、猫是动物 泛化关系用一条带空心箭头的直接表示；如下图表示（A继承自B）； eg：汽车在现实中有实现，可用汽车定义具体的对象；汽车与SUV之间为泛化关系； 注：最终代码中，泛化关系表现为继承非抽象类； 实现（Realization） 1实现关系用一条带空心箭头的虚线表示； eg：”车”为一个抽象概念，在现实中并无法直接用来定义对象；只有指明具体的子类(汽车还是自行车)，才 可以用来定义对象（”车”这个类在C++中用抽象类表示，在JAVA中有接口这个概念，更容易理解） 注：最终代码中，实现关系表现为继承抽象类； 聚合（Aggregation） 1聚合关系用一条带空心菱形箭头的直线表示，如下图表示A聚合到B上，或者说B由A组成； 聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义；例如一个部门由多个员工组成； 与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如， 部门撤销了，人员不会消失，他们依然存在； 组合（Composition） 1组合关系用一条带实心菱形箭头直线表示，如下图表示A组成B，或者B由A组成； 与聚合关系一样，组合关系同样表示整体由部分构成的语义；比如公司由多个部门组成； 但组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了；例如， 公司不存在了，部门也将不存在了； 关联关系的修饰名称及其方向 角色及可见性 在关联的每一端，表明相连的类在该关联关系中的作用 多重性（Multiplicity） 修饰（Adornment） 语义（Semantics） 0..1 0or1 1 Exactly 1 0..* 0 or more 1..* 1 or more m..n m to n m..n, p..q m to n or p to q * 0 or more 在图中： 一个Car有一个Person（司机，这里person指司机），因此在Person端有个符号1； 一个Person（司机）开一辆车Car，因此在Car有个符号1； 一个Car有四个Tire（轮胎），因此在Tire端有个符号4； 一个Tire仅能在一个Car上，因此在在Car端有个符号1。需要注意的是，如果认为“ 一个Tire可能在一个Car上，也可能不在Car上”那么Car端的符号为0..1； 一个Car只有一个Brand（标志），所以在Brand端符号为1； 一个标志会在0辆或多辆车上，所以Car端符号为*。 1. Reference and lots of thanks：https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html &#8617;]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>软件工程</tag>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML活动图]]></title>
    <url>%2FG-SS-Hacker.github.io%2FUML%E6%B4%BB%E5%8A%A8%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[【面向对象分析UML建模工具全部文章】 UML建模工具(1)——用例图 UML建模工具(2)——活动图 UML建模工具(3)——类图 UML建模工具(4)——顺序图 UML建模工具(5)——通信图 UML建模工具(6)——状态图 UML建模工具——活动图 图：香港九龙(Kowloon, Hong Kong) Guderian出品 定义 活动图（Activity Diagram）是一种特殊的状态图，它展现了在系统内从一个活动到另一个活动的流程 活动图与用例图互为补充，主要用于需求分析阶段 基本建模元素 开始（Initial Node）、结束（Final Node）、对象（Objects） 动作（Actions） 分支（Decision Nodes） 分岔和汇合（Forking and Joining） 泳道（Partition） 开始、结束、对象 动作/活动节点 一个活动节点是一个过程中进行的非原子的执行单元，活动的执行最终延伸为一些独立动作的（Action）的执行 分支 分支相当于编程语言中的if语句，可以有一个进入流和多个离去流 分岔和汇合 分差表示把一个单独的控制流分成两个或多个并发的控制流。汇合表示两个或多个并发控制流的同步发生，一个汇合可以有两个或多个进入转移和一个输出转移。用同步棒来说明并行控制流的分岔和汇合。 泳道 将一个活动图中的活动分组，每一组表示一个特定的类别、人或部门，他们负责组内的活动，每个组被称为一个泳道，用一条垂直的实线把它们分开。每个活动严格属于每一个泳道，转移（流）和同步棒（分差与汇合）可以跨越泳道。 完整的活动图例子电商平台 货物交易]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>软件工程</tag>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML用例图]]></title>
    <url>%2FG-SS-Hacker.github.io%2FUML%E7%94%A8%E4%BE%8B%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[【面向对象分析UML建模工具全部文章】 UML建模工具(1)——用例图 UML建模工具(2)——活动图 UML建模工具(3)——类图 UML建模工具(4)——顺序图 UML建模工具(5)——通信图 UML建模工具(6)——状态图 UML建模工具——用例图 图：歼15双机编队 Guderian出品 系统 System 参与者 Actors 用例 Use Cases 关系 Relationships 系统（System） 一个系统就是你开发的所有东西，可以是网站、软件组件、业务流程、应用程序、etc. 用一个矩形代表一个系统，然后将系统名称放在顶部。矩形用于定义系统的范围，矩形内的所有内容都在系统内发生，矩形外的所有内容都不会在系统外发生。 如图所示，灰色区域即为飞行控制系统，而副驾驶、机长都是系统外内容，属于参与者。 参与者（Actor） 使用我们的系统（与系统交互）实现目标的某人或某物，可以是一个人、一个组织、另一个系统或一个外部设备 参与者的普通图形用火柴人表示；当另一个系统充当参与者时，参与者的图形用矩形表示。 在软件工程中，参与者告诉我们我们这个系统应该具有的功能。不同的参与者希望获得不同的功能，我们需要找到重要的参与者，认真调查他们的需求，并根据不同参与者的需求完善系统。 用例（Use Case） 系统为响应参与者引发的一个事件而执行的一系列的处理/动作，而这些处理应该为参与者产生一种有价值的结果 用椭圆形容一个用例，代表要系统做的一个任务。 关系（Relationship）用例图中涉及的关系有：关联、泛化、包含、扩展 关系类型 说明 表示符号 关联（Association） 参与者与用例之间的关系 泛化（Inheritance） 参与者之间或用例之间的关系 包含（Include） 用例之间的关系 扩展（Extend） 用例之间的关系 关联（Association） 关联关系，用实线表示。表示参与者与用例之间的通信，任何一方都可以发送和接受信息。 参与者Actor与用例Use Case相关联，参与者既要向用例发送信息，也要就收用例反馈的信息。 泛化（Inheritance） 泛化关系，实现+空心箭头，从子类指向父类。 （account拼错了） 如上图所示，用户User可以被细分为VIP用户和游客Guest；登录Log in也可以被细分为邮箱登录Log in by email和QQ登录Log in by QQ account。 包含（Include） 包含关系，把一个较复杂用例所表示的功能分解成较小的步骤，是上一个用例执行过程中必不可少的。箭头指向包含的子用例。 如上图所示，系统维护System Maintenance的工作包含了添加Add、删除Remove和修正Modify。 扩展（Extend） 扩展关系，用例功能的延伸，相当于为基础用例提供一个附加功能，不是必不可少的。箭头指向被扩展的父用例。 如上图所示，打喷嚏Sneeze必然包含闭眼Close Eyes的过程，因此Sneeze和Close Eyes是包含关系；打完喷嚏Sneeze之后不一定需要道歉Say Excuse Me，因此Sneeze和Say Excuse Me是扩展关系。 完整的用例图例子 这是一个Bank app系统，参与者包括用户Customer和银行数据库Bank，用户可以进行的操作包括登录Log in、验证余额Check Balance、转账Transfer Funds、支付Make Payment和建立档案Set Up Profile。 用户登录后，需要验证密码Verify Password，因此Log in和Verify Password是包含关系；如果用户输入密码错误，则展示错误信息Display Login Error，因此Log in和Display Login Error是扩展关系（用户不一定会输错密码）。 用户验证余额、转账和支付都需要银行数据库来帮助实现，因此验证余额、转账和支付和Bank都是关联关系。而用户进行转账和支付操作时，都必须验证用户账户资金是否足够Veirify Sufficient Funds，因此转账、支付和Verify Sufficient Funds是包含关系。 用户在支付时，可以选择使用支票支付Pay from Checking或余额支付Pay from Savings，故支票支付和余额支付与支付是泛化关系。 此处有一个带有扩展点Extension Points的用例：建立档案Set Up Profile。用例名称在上方，扩展点在下方。扩展点是扩展关系的详细叙述。这个用例表明用户可以再Banking App中建立自己的档案，当用户在建立他们的档案是，可以选择转移至几个不同的屏幕。如果用户感到困惑，他们可以转到档案帮助页面Go to Profile Help；如果用户希望了解隐私信息，他们可以转到隐私信息页面Show Privacy Info。还可以添加注释，以写明导致扩展的情况发生的条件。 Reference：https://www.youtube.com/watch?v=zid-MVo7M-E]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>软件工程</tag>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象绪论]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%AA%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[面向对象绪论 图：歼15航母降落 Guderian出品 面向对象的基本概念 类 Class 对象 Object 浅显理解：类是抽象的对象，对象是具体的类 概念之间的互用 属性 Attribute == 数据 Data == 状态 State == 信息 Information 操作 Operation == 方法 Method == 行为 Behavior == 职责 Responsibility 对象 Object == 实例 Instance 面向对象的核心特征 封装 Encapsulation 继承 Inheritance 多态 Polymorphism 封装、继承和多态被称为所谓的“面向对象三大特征” 聚合/组合 Aggregation / Composition 接口/实现 Interface / Implementation 抽象 Abstraction 封装 Encapsulation 是指隐藏对象的属性和实现细节，仅对外提供公共访问方式 封装什么？ 内部的、不想让其他人随意了解的信息 类的属性 Attribute 类的方法 Method 为什么要封装？ 保护隐私 保护数据安全 隔离复杂度 面向对象的封装有四种方式 Public Private Protected Package 继承 Inheritance 一个类从其他类获得它的状态和行为，同时还可以加上自己额外的状态和行为 父类中的属性和方法，在子类中可以重复使用，子类就不需要再定义了，这样即可实现代码的可重用性。如以下类图例子，定义类C1Dobject一维物体，它有一个属性x对应x轴上的一个坐标，两个方法getx()和setx(int)分别表示x坐标的获取和设置。如果我们需要定义二维物体，就没有必要把x坐标重复定义。我们在类C1Dobject的基础上派生出子类C2Dobject，只需再定义属性y和方法gety()及sety(int)就可以完整地抽象出一个二维物体；类似地，如果我们需要定义三维物体，没有必要把x坐标、y坐标重复定义，只需再类C2Dobject的基础上派生出子类C3Dobject，再定义属性z和方法getz()及setz(int)即可。显而易见，继承提高了代码的可重用性，减少了创建类的工作量。 以上类图对应的C++代码如下： 1234567891011121314151617181920212223242526class C1Dobject&#123;private: int x = 0;public: int getx() &#123; return x; &#125; void setx(int xPrime) &#123; x = xPrime; &#125;&#125;;class C2Dobject: public C1Dobject&#123;private: int y = 0;public: int gety() &#123; return y; &#125; void sety(int yPrime) &#123; y = yPrime; &#125;&#125;;class C3Dobject: public C2Dobject&#123;private: int z = 0;public: int getz() &#123; return z; &#125; void setz(int zPrime) &#123; z = zPrime; &#125;&#125;; 多态 Polymorphism 使用指向父类的指针或者引用，能够调用子类的对象 结论： 当一个类从另一个类继承而来，多态使得子类可以代替父类 消息发送方不需要知道消息接收方属于哪一个子类 同一类族的接收者可以按自己的方式处理消息 如以下类图例子，定义形状CShape作为父类，派生出矩形CRectangle和三角形CTriangle。现在假设我们知道一个图形shape，希望获取它的面积，而我们并不需要知道它的具体形状（属于哪一个子类），只需要确保shape所属的类在CShape的类组下即可。图形shape的面积可以通过调用函数area()实现。 C++中多态的实现涉及静态多态和动态多态以及虚函数的使用，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;using namespace std;class CShape&#123;protected: int width, height;public: CShape(int a = 0, int b = 0) &#123; width = a, height = b; &#125; //纯虚函数，具体功能在子类中实现 virtual int area() = 0;&#125;;class CRectangle: public CShape&#123;public: //显式调用父类的构造函数 CRectangle( int a = 0, int b = 0): CShape(a, b) &#123;&#125;; int area() &#123; cout &lt;&lt; "CRectangle area calls: "; return width * height; &#125;&#125;;class CTriangle: public CShape&#123;public: //显式调用父类的构造函数 CTriangle( int a = 0, int b = 0): CShape(a, b) &#123;&#125;; int area() &#123; cout &lt;&lt; "CTriangle area calls: "; return width * height / 2; &#125;&#125;;int main()&#123; CShape *ptr; CRectangle rect(10, 10); CTriangle tri(10, 10); //获取矩形的面积 ptr = &amp;rect; cout &lt;&lt; ptr-&gt;area() &lt;&lt; endl; //获取三角形的面积 ptr = &amp;tri; cout &lt;&lt; ptr-&gt;area() &lt;&lt; endl; return 0;&#125; C++中构成多态需要满足两个条件： 调用函数的对象须是指针或引用 被调用的函数须是重写 1的虚函数 2 聚合/组合 Aggregation / Composition聚合 Aggregation A has B，B是A的一部分，但A不控制B的生命周期 如：学校由学生组成，那么学校与学生是聚合关系 UML图中聚合关系的符号如下图 组合 Composition A has B，B是A的一部分，且A控制B的生命周期 如：树由树叶组成，那么树与树叶是组合关系 UML图中聚合关系的符号如下图 接口/实现 Interface / Implementation接口 Interface 描述一个类的用户如何与这个类交互 实现 Implementation 完成接口所定义的功能，如类、构建等完成的任务 如电视机、插座、发电厂的关系如何呢？ 电视机是用户 client 插座是接口 Interface 发电厂是实现 Implementation 抽象 Abstraction 抽取具体客观事物的共性 抽象是面向对象领域发现类的主要方法 （所谓抽象，玄之又玄，众妙之门） 1. 重写：函数重写必须函数名一致、参数一致、返回值一致 &#8617; 2. 虚函数：在类的成员函数前加virtual关键字 &#8617;]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C-plus-plus</tag>
        <tag>OOP</tag>
        <tag>面向对象</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二次曲面]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E4%BA%8C%E6%AC%A1%E6%9B%B2%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[二次曲面 图：Watch Dog 2 by Ubisoft Guderian出品 1.椭圆柱面 \frac{x^2}{a^2}+\frac{y^2}{b^2}=1 2.双曲柱面 \frac{x^2}{a^2}-\frac{y^2}{b^2}=1 3.抛物柱面 x^2=2py,(p\ne 0) 4.椭球面 \frac{x^2}{a^2}+\frac{y^2}{b^2}+\frac{z^2}{c^2}=1 5.单叶双曲面 \frac{x^2}{a^2}+\frac{y^2}{b^2}-\frac{z^2}{c^2}=1 6.双叶双曲面 \frac{x^2}{a^2}-\frac{y^2}{b^2}-\frac{z^2}{c^2}=1 7.椭圆抛物面 \frac{x^2}{2p}+\frac{y^2}{2q}=z,(p,q同号) 8.双曲抛物面 \frac{x^2}{2p}-\frac{y^2}{2q}=z,(p,q同号)变种： x^2-y^2=z 9.二次锥面 \frac{x^2}{a^2}+\frac{y^2}{b^2}+\frac{z^2}{c^2}=0 ~我们遇到什么困难也不要怕，微笑着面对它！消除恐惧的最好办法就是面对恐惧！坚持就是胜利！加油！奥利给！~ 【其他文章·微积分·线性代数】 不定积分公式 常用泰勒展开式 高阶求导公式 高等数学公式 常用等价无穷小 导数基本公式 矩阵章节总结 行列式章节总结 线性方程组章节总结]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象设计七大原则]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[面向对象设计七大原则 图：北京航空航天大学 Guderian出品 AKA：设计模式七大原则 1. 单一职责原则 SRP，Single Responsibility Principle 每一个对象有且只有一个职责，从而实现”高内聚、低耦合“ 防止一个类实现多个功能，改变一个功能后影响其他功能的正常运作 2. 开放-封闭原则 OCP，Open-Closed Principle 对拓展开放、对修改关闭 需要对程序进行拓展的时候，不能修改原有代码，只能在原有代码的基础上添加 3. 李氏替换原则 LSP，Liskov Substitution Principle 任何基类出现的地方，一定可以用派生类代替 派生类可以拓展基类的功能，但不能改变基类的功能 4. 依赖倒置原则 DIP，Dependence Inversion Principle 实现依赖于抽象，而抽象不依赖于实现 解除高层组件对低层组件的依赖，是实现开闭原则的重要基础 5. 接口隔离原则 ISP，Interface Segregation Principle 一个类对另外一个类的依赖性应当是建立在最小的接口上 在特定的使用场合给特定用户提供其需要的方法、屏蔽其不需要的方法 6. 组合重用原则 CRP, Composite Reuse Principle, 尽量使用组合，尽量不用继承 在新的对象里面使用已有的对象，使之成为新的对象的一部分 7. 迪米特原则 LoD，Law of Demeter 一个对象应该对其他对象又尽可能少的了解 尽量降低成员的访问权限，提供访问器而不公开成员变量 注：C++中只有抽象类的概念，JAVA中既有抽象类的概念，又有接口的概念。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++引用]]></title>
    <url>%2FG-SS-Hacker.github.io%2FC-%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[C++引用 图：LEGO小人仔 Guderian出品 笔记整理自《北京大学公开课：C++面向对象程序设计》 C++跟C相比，多了很多独特的内容，其中有很多都是为了实现面向对象编程范式而引入的，C++的引用就是其一。 引用的概念 定义一个引用，并将其初始化为引用某个变量的通用写法：类型名 &amp; 引用名 = 某变量名 某个变量的引用，等价于这个变量，相当于该变量的一个别名 12345678int n = 7;int &amp; r = n;//r引用了n，r的类型是int &amp;r = 4;cout &lt;&lt; r; //输出4cour &lt;&lt; n; //输出4n = 5;cout &lt;&lt; n; 定义引用时一定要将其初始化成引用某个变量，而不像指针可以指向某个变量也可以不指向某个变量 初始化后，它就一直引用该变量，不会再引用别的变量了（引用是从一而终的） 引用只能引用变量，不能引用常量和表达式 1234567double a = 3, b = 5;double &amp; r1 = a;double &amp; r2 = r1; //r2也引用ar2 = 10;cout &lt;&lt; a &lt;&lt; endl; //输出10r1 = b; //r1并没有引用bcout &lt;&lt; a &lt;&lt; endl; //输出5 引用的应用C中，如何编写交换两个整型变量值的函数? 这样写吗？ 12345678void swap(int a, int b)&#123; int tmp; tmp = a; a = b; b = tmp;&#125;int n1, n2;swap(n1, n2);//n1, n2的值没有被交换 这是错误的，改变形参不会改变实参。 或者用指针？ 12345678void swap(int *a, int *b)&#123; int tmp; tmp = *a; *a = *b; *b = tmp;&#125;int n1, n2;swap(&amp; n1, &amp; n2); //取地址//n1, n2的值被交换 正确，但丑陋！ 那么C++中，如何编写交换两个整型变量值的函数? 引用作为参数 C++示例：交换两个整数 12345678void swap(int &amp; a, int &amp; b) //a就是n1，b就是n2&#123; int tmp; tmp = a; a = b; b = tmp;&#125;int n1, n2;swap(n1, n2);//n1, n2的值被交换 引用作为返回值12345678910111213int n = 4;int &amp; SetValue() &#123; return n; &#125;int main()&#123; //神奇之处，对函数的返回值进行赋值 SetValue() = 40; //然而它究竟有什么作用呢？我还没想好... cout &lt;&lt; n; //输出：40 return 0;&#125; 注意被引用的对象不能超过作用域，返回一个局部变量的引用是不合法的，但是，可以返回一个静态类型变量的引用。 常引用定义引用时，在前面加const关键字即为“常引用”。 12int n;const int &amp; r = n; 注意不能通过常引用去修改其引用的内容！ 1234int n = 100;const int &amp; r = n;r = 200; //errn = 300; //ok 常引用和非常引用的转换 const T &amp;和T &amp;是不同的类型（千万要注意！！！） T &amp;类型的引用或T类型的变量可以用来初始化const T &amp;类型的引用 const T类型的常变量和const T &amp;类型的引用则不能用来初始化T &amp;类型的引用，除非进行强制类型转换 参考并整理自《C++面向对象设计》郭炜，北京大学，感谢原作者！编辑时有删改]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C-plus-plus</tag>
        <tag>OOP</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++继承和派生]]></title>
    <url>%2FG-SS-Hacker.github.io%2FC-%E7%BB%A7%E6%89%BF%E5%92%8C%E6%B4%BE%E7%94%9F%2F</url>
    <content type="text"><![CDATA[C++继承和派生 图：古老的地球 Guderian出品 本文整理自《北京大学公开课：C++面向对象程序设计》 基本概念 继承和派生实际上是一回事：在定义一个新的类B时，如果该类与某个已有的类A相似（指的是B拥有A的全部特点），那么可以把A作为一个基类，而把B作为基类的一个派生类（也称子类），这使得创建和维护一个程序更加容易 派生类拥有基类的全部特点，派生类还可以对基类进行修改和扩充。在派生类中，可以扩充新的成员变量和成员函数 派生类一经定义，可以独立使用，定义对象时不依赖于基类 派生类拥有基类的全部成员函数和成员变量。不论是private、protected、public 在派生类的各个成员函数中，不能访问基类的private成员 简单理解成员修饰符protected和private的区别：protected成员在派生类中可以被访问，而private不能 对象不同类型对应的访问权限： 类型 public protected private 本类 √ √ √ 派生类 √ √ × 其他类 √ × × 派生类的写法12345class 派生类名: 访问修饰符 基类名 //Zhclass derived-class: access-specifier base-class //En&#123; //...&#125;; 访问修饰符可以是private、protected、public中的一个。如果未使用访问修饰符，则默认为private。该访问修饰符规定了继承类型。 继承类型 公有继承（public）：继承public和protected且类型不变，不继承private 保护继承（protected）：继承public和protected且类型都为protected，不继承private 私有继承（private）：继承public和protected且类型都变为private，不继承private 一般使用公有继承。 写法示例：学生管理系统1234567891011121314151617181920212223242526272829class CStudent&#123; private: string sName; int nAge; public: bool IsThreeGood() &#123;&#125;; void SetName(const string &amp; name) &#123; sName = name; &#125; //...&#125;;class CUndergraduteStudent: public CStudent//本科生&#123; private: int nDepartment; public: bool IsThreeGood() &#123;/*...*/&#125;; //覆盖（不是重载！覆盖的参数表不变，重载的参数表改变！） //名字与基类一样，但行为不一样 bool CanBaoYan() &#123;/*...*/&#125;;&#125;;class CGraduatedStudent: public CStudent//研究生&#123; private: int nDepartment; char szMentorName[20]; public: int CountSalary() &#123;/*...*/&#125;;&#125;; 派生类对象的内存空间派生类对象的体积 = 基类对象的体积 + 派生类对象自己的成员变量的体积。 在派生类对象中，包含基类对象，而且基类对象的存储位置位于派生类对象新增的成员变量之前。 学籍管理程序实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class CStudent&#123; private: string name; string id; char gender; int age; public: void PrintInfo(); void SetInfo(const string &amp; name_, const string % id_, int age_, char gender_); string GetName() &#123; return name; &#125;&#125;;class CUndergraduteStudent: public CStudent&#123;//本科生类，继承了CStudent类 private: string department; //学生所属的系的名称 public: void QualifiedForBaoyan() //给予保研资格 &#123; cout &lt;&lt; "qualified for baoyan" &lt;&lt; endl; &#125; void PrintInfo() &#123; CStudent::PrintInfo(); //调用基类的PrintInfo cout &lt;&lt; "Department" &lt;&lt; department &lt;&lt; endl; &#125; void SetInfo(const string &amp; name_, const string % id_, int age_, char gender_) &#123; CStudent::SetInfo(name_, id_, age_, gender_); //调用基类的SetInfo department = department_; &#125;&#125;;int main()&#123; CUndergraduteStudent s2; s2.SetInfo("Guderian", "999999999", 21, "M", "Combat Command"); //古德里安，999999999，,2岁，男性，战役指挥学 s2.QualifiedForBaoyan(); //获得保研资格 s2.PrintInfo(); //打印信息 return 0;&#125;//输出：Guderian qualified for baoyanName: GuderianID: 999999999Age: 21Gender: MDepartment: Combat Command 派生类的使用方法 在派生类中，调用基类的成员函数，设置了从基类继承的信息之后，之后再设置自己独有的信息。这一方法在C++面向对象编程中是很常用的。 多继承：一个子类可以有多个父亲，继承多个父亲的特性 参考并整理自《C++面向对象设计》郭炜，北京大学，感谢原作者！编辑时有删改]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C-plus-plus</tag>
        <tag>OOP</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++友元]]></title>
    <url>%2FG-SS-Hacker.github.io%2FC-%E5%8F%8B%E5%85%83%2F</url>
    <content type="text"><![CDATA[C++友元 Guderian出品 本文整理自《北京大学公开课：C++面向对象程序设计》 友元很简单，在某种程度上算作是C++设计者对C使用者的妥协。友元分为友元函数和友元类两种。 友元函数一个类的友元函数可以访问该类的私有成员，友元函数不是这个类的成员函数，可以是一个普通的全局函数或其他类的成员函数 123456789101112131415161718192021222324252627class CCar; //提前声明CCar是一个类，以便后面的CDriver类使用class CDriver&#123; public: void ModifyCar(CCar *pCar);&#125;;class CCar&#123; private: int price; friend int MostExpensiveCar(CCar cars[], int total); //声明友元 friend void CDriver::ModifyCar(CCar *pCar) //声明友元&#125;;void CDriver::ModifyCar(CCar *pCar)&#123; pCar-&gt;price += 1000; //汽车改装后价值增加&#125;int MostExpensiveCar(CCar cars[], int total)&#123; int tmpMax = -1; for(int i = 0; i &lt; total; ++i) if(cars[i].price &gt; tmpMax) tmpMax = cars[i].price; return tmpMax; &#125; 可以将一个类的成员函数（包括构造、析构函数）说明为另一个类的友元 123456789class B&#123; public: void function();&#125;;class A&#123; friend void B::function();&#125;; 友元类如果A是B的友元类，那么A的所有成员函数可以访问B的所有私有成员 12345678910111213141516class CCar&#123; private: int price; friend class CDriver; //声明CDriver为友元类&#125;;class CDriver&#123; public: CCar myCar; void ModifyCar() //改装汽车 &#123; myCar.price += 1000; //因CDriver是CCar的友元类故可以访问其私有成员 &#125;&#125;; 友元类之间的关系不能传递：类A是类B的友元，类C是类B的友元，但类A不是类C的友元 友元类之间的关系不能继承]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C-plus-plus</tag>
        <tag>OOP</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++常量对象、常量成员函数和常引用]]></title>
    <url>%2FG-SS-Hacker.github.io%2FC-%E5%B8%B8%E9%87%8F%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B8%B8%E9%87%8F%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%92%8C%E5%B8%B8%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[C++常量对象、常量成员函数和常引用 图：广州塔 Guderian出品 本文整理自《北京大学公开课：C++面向对象程序设计》 常量对象如果不希望某个对象的值被改变，则定义该对象的时候可在前面加const关键字。 123456789class CDemo&#123; private: int vale; public: void SetValue() &#123;&#125;&#125;;const Demo obj; //常量对象 常量成员函数在类的成员函数说明后面可以加const关键字，则该成员函数成为常量成员函数。 常量成员函数执行期间不应该修改其所作用的对象。因此，在常量成员函数中不能修改成员变量的值（静态成员变量除外），也不能调用同类的非常量成员函数（静态成员函数除外）。 非常亮成员函数在执行的过程中是有可能修改掉常量成员函数中的值的。 12345678910111213141516171819202122232425class Sample&#123; public: int value; void GetValue() const; void func() &#123;&#125;; Sample() &#123;&#125;&#125;;void Sample::GetValue() const&#123; value = 0; //wrong,不能修改成员变量的值 func(); //wrong,不能调用同类的非常量成员函数&#125;int main()&#123; const Sample o; o.value = 100; //err,不能修改成员变量的值 o.func(); //err,不能调用同类的非常量成员函数 o.GetValue(); //ok,可以执行常量成员函数 return 0;&#125; 常量成员函数的重载两个成员函数，名字和参数表都一样，但是一个是const，一个不是，算重载，而不是重复定义。 12345678910111213141516171819202122class CTest&#123; private: int n; public: CTest() &#123; n = 1 ;&#125; int GetValue() const &#123; return n; &#125; int GetValue() &#123; return 2 * n; &#125; //这两个GetValue()函数是重载关系，而不是重复定义&#125;;int main()&#123; const CTest objTest1; CTest objTest2; cout &lt;&lt; objTest1.GetValue() &lt;&lt; ", " &lt;&lt; objTest2.GetValue(); //objTest1是常量对象，调用的是GetValue() const //objTest2是非常量对象，调用的是GetValue() return 0;&#125; 常引用引用前面可以加const关键字，成为常引用。不能通过常引用，修改其引用的变量。 123const int &amp;r = n;r = 5; //errorn = 4; //OK 对象作为函数的参数时，生成该参数需要调用复制构造函数，效率比较低。用指针作参数，代码又不好看，如何解决？可以用对象的引用作为参数。 12345678class Sample&#123; //... &#125;;void PrintfObj(Sample &amp;o)&#123; //...&#125; 但对象引用作为函数参数有一定风险性，若函数中不小心修改了形参o，则实参也跟着变，这不是我想要的。如何避免？使用常引用！ 12345678class Sample&#123; //... &#125;;void PrintfObj(const Sample &amp;o)&#123; //...&#125; 这样函数中就能确保不会出现无意中更改o值的语句了。 参考并整理自《C++面向对象设计》郭炜，北京大学，感谢原作者！编辑时有删改]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C-plus-plus</tag>
        <tag>OOP</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++复制构造函数]]></title>
    <url>%2FG-SS-Hacker.github.io%2FC-%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[C++复制构造函数 图：广州天河CBD Guderian出品 本文整理自《北京大学公开课：C++面向对象程序设计》 基本概念 只有一个参数，即对同类对象的引用 形如X::X(X &amp;)或X::X(const X &amp;)，二者选一，后者能以常量对象作为参数 如果没有定义复制构造函数，那么编译器生成默认的复制构造函数。默认的复制构造函数完成复制功能 构造函数与复制构造函数的异同 构造函数（或称无参构造函数）不一定存在，你不写构造函数，编译器就只会帮你生成一个什么也不做的无参构造函数 复制构造函数一定存在，你不写复制构造函数，编译器也会帮你写好一个具有复制功能的复制构造函数 12345678class Complex&#123; private: douebl real, imag;&#125;;Complex c1; //调用缺省的构造函数Complex c2(c1); //调用缺省的复制构造函数，将c2初始化成和c1一样 如果定义了自己的复制构造函数，则默认的复制构造函数不存在 12345678910111213141516class Complex&#123; public: double real, imag; Complex() &#123;&#125; Complex(const Complex &amp;c) &#123; real = c.real; imag = c.imag; cout &lt;&lt; "Copy constructor called"; &#125;&#125;;Complex c1;Complex c2(c1);//调用自己定义过的复制构造函数，输出Copy constructor called 特别强调1注意：不允许有形如X::X(X)的复制构造函数，参数一定是引用，不能是对象 12345678class CSample&#123; CSample(CSample c) &#123; //错，不允许出现这样的复制构造函数 //这样写的话，下面的内容要么变成了构造函数，要么语法是错误的 &#125;&#125;; 复制构造函数起作用的三种情况（1）当用一个对象去初始化同类的另一个对象时12Complex c2(c1);Complex c2 = c1; //初始化语句，非赋值语句，与上面写法是等价的 （2）当某函数有一个参数是类A的对象时那么该函数被调用时，类A的复制构造函数将被调用。C++规则：形参是实参的拷贝 123456789101112131415161718192021class A&#123; public: A() &#123;&#125;; A(A &amp;a) &#123; cout &lt;&lt; "Copy constructor called" &lt;&lt; endl; &#125;&#125;;void Func(A a1) &#123;&#125;int main()&#123; A a2; Func(a2); retrun 0;&#125;//输出：Copy constructor called （3）当函数的返回值是类A的对象时那么在函数返回时，A的复制构造函数被调用，作用是初始化作为返回值的类A对象 1234567891011121314151617181920212223242526272829class A&#123; public: int v; A(int n) &#123;v = n&#125;; A(const A &amp;a) &#123; v = a.v; cout &lt;&lt; "Copy constructor called" &lt;&lt; endl; &#125;&#125;;A.Func()&#123; A b(4); return b;&#125;int main()&#123; cout &lt;&lt; Func().v &lt;&lt; endl; //此处Func()的返回值没有名字，是一个复制构造函数初始化的对象 return 0;&#125;//输出：Copy constructor called4 特别强调2注意：对象间赋值并不导致复制构造函数被调用 123456789101112131415161718192021222324class CMyClass&#123; public: int n; CMyClass() &#123;&#125;; CMyClass(CMyClass &amp;c) &#123; n = 2 * c.n; &#125; //不推荐复制构造函数这样写，此处仅用于凸显调用复制构造函数与对象间赋值的区别&#125;;int main()&#123; CMyClass c1, c2; c1.n = 5; c2 = c1; //这是赋值语句 CMyClass c3(c1); //调用复制构造函数，c3并没有变得跟c1一样 cout &lt;&lt; c2.n &lt;&lt; ", "; cout &lt;&lt; c3.n &lt;&lt; endl; return 0;&#125;//输出：5, 10 定义函数时常量引用参数的使用1234void fun(CMyClass obj)&#123; cout &lt;&lt; "fun" &lt;&lt; endl;&#125; 这样的函数，调用时生成形参会引发复制构造函数调用，复制一遍时间开销比较大 所以可以考虑使用CMyClass &amp; 引用类型作为参数，本质上与实参是一样的 如果希望确保实参的值在函数中不应被改变，那么可以加上const关键字，这样的话如果你定义的函数中出现了改变实参的值得语句。编译器就会报错 我自己写的程序难道我自己不记得我没有改过参数吗？的确，你现在记得，明天也记得，但以后再改你的程序，就未必记得了。从代码规范的角度来讲，加上const关键字是必要的 1234void fun(const CMyClass &amp;obj)&#123; //如此一来，函数中任何试图改变obj值得语句都将是非法&#125; 思考：为什么要自己写复制构造函数？ 想通这个问题是高难度操作，作者水平有限，无法清晰地回答，仅提供参考链接。 前置知识： 深拷贝、浅拷贝 传值、传地址、传引用 参考链接： 为什么需要拷贝构造函数 c++的默认拷贝构造函数，从深度拷贝和浅拷贝说起 为什么要自己写构造函数和析构函数 使用缺省的拷贝构造函数带来的危险性 值传递 引用传递（传地址，传引用）的区别 参考并整理自《C++面向对象设计》郭炜，北京大学，感谢原作者！编辑时有删改]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C-plus-plus</tag>
        <tag>OOP</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++构造函数]]></title>
    <url>%2FG-SS-Hacker.github.io%2FC-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[C++ 构造参数 图：深圳福田CBD Guderian出品 本文整理自《北京大学公开课：C++面向对象程序设计》 构造函数的性质 构造参数是成员函数的一种 名字与类名相同，可以由参数，不能有返回值（void也不行） 作用是对对象进行初始化，如给成员变量赋初值 如果定义类的时候没写构造函数，则编译器生成一个默认的无参数的构造函数 默认构造函数无参数，不进行任何操作 如果定义了构造函数，则编译器不生成默认的无参数的构造函数 对象生成时构造函数被自动调用。对象一旦生成，就再也不能在其上执行构造函数 一个类可以有多个构造函数 注：如果只定义了带参构造函数，在定义对象时必须声明参数 为什么需要构造函数： 不用专门写初始化函数，也不用担心忘记 有时对象没有被初始化，会导致程序出错 构造函数的使用一个类可以有一个构造函数1234567891011121314151617181920class Circle&#123; private: double radius, xLoc, yLoc; public: Circle(double r ,double x = 0, y = 0)&#125;;Circle::Circle(double r, double x, double y)&#123; radius = r, xLoc = x, yLoc = y;&#125;//Wrong samplesCircle c1; //error,缺少构造函数的参数Circle *pc = new Circle; //error，没有参数//Correct samplesCircle c1(2); //OKCircle c1(2, 4, 4); //OKCircle *pc = new Circle(3, 4); //also OK 一个类可以有多个构造函数只要不同的构造函数的参数个数和参数类型不同，这些构造函数就会构成重载的关系 1234567891011121314151617181920212223242526class Circle&#123; private: double radius, xLoc, yLoc; public: Circle(double r ,double x = 0, y = 0) Circle(double r); Circle(Circle c1, Circle c2)&#125;;Circle::Circle(double r, double x, double y)&#123; radius = r, xLoc = x, yLoc = y;&#125;Circle::Circle(double r)&#123; radius = r;&#125;Circle::Circle(Circle c1, Circle c2)&#123; radius = c1.radius + c2.radius; xLoc = c1.xLOc + c2.xLoc; yLoc = c1.yLOc + c2.yLoc;&#125;//SamplesCircle c1(3), c2(1, 0), c3(c1, c2); 构造函数在数组的使用（1）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class CSample&#123; private: int x; public: CSample() &#123; cout &lt;&lt; "Constructor 1 Called" &lt;&lt; endl; &#125; CSample(int n) &#123; x = n; cout &lt;&lt; "Constructor 2 Called" &lt;&lt; endl; &#125;&#125;;int main()&#123; cout &lt;&lt; "step1" &lt;&lt; endl; CSample array1[2]; cout &lt;&lt; "step2" &lt;&lt; endl; CSample array2[2] = &#123;4, 5&#125;; cout &lt;&lt; "step3" &lt;&lt; endl; CSample array3[2] = &#123;3&#125;; cout &lt;&lt; "step4" &lt;&lt; endl; CSample *array4 = new CSample[2]; //随机生成两个元素的数组 delete []array4; //解除空间占用 return 0;&#125;//输出：step1//对两个对象初始化的参数没有作任何交代，编译器就认为这个对象就应该用无参的构造函数初始化Constructor 1 CalledConstructor 1 Calledstep2 //对两个对象初始化的参数都有交代Constructor 2 CalledConstructor 2 Calledstep3 //只对第一个对象初始化的参数作了交代Constructor 2 CalledConstructor 1 Calledstep4 //对两个对象初始化的参数没有作任何交代Constructor 1 CalledConstructor 1 Called 构造函数在数组的使用（2）1234567891011121314151617181920212223class Test&#123; public: Test(int n) &#123;&#125; //(1) Test(int n, int m) &#123;&#125; //(2) Test() &#123;&#125; //(3)&#125;;Test array1[3] = &#123;1, Test(1,2)&#125;;//三个元素分别用(1)，(2)，(3)初始化Test array2[3] = &#123;Test(2, 3), Test(1, 2), 1&#125;;//三个元素分别用(2)，(2)，(1)初始化Test *pArray1[3];//仅仅这么定义是不会导致对象生成的，不会引发Test的构造函数被调用。//*pArray1[3]仅仅是指针而已，不会产生任何对象Test *pArray2[3] = &#123;new Test(4), new Test(1, 2)&#125;;//对指针数组的前两个元素初始化，方法是new两个对象，返回值是指针，用new的两个对象的地址去初始化数组pArray2[3]的前两个元素。//注意这个语句只生成了两个对象，pArray2[2]还是一个指针，无从得知它的指针指向哪里，它的生成并不会导致任何对象的生成。//注意在使用中，指针数组与数组的区别 参考并整理自《C++面向对象程序设计》郭炜，北京大学，感谢原作者！编辑时有删改]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C-plus-plus</tag>
        <tag>OOP</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不定积分公式]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[不定积分公式 Guderian出品 $(1)\int0 \mathrm{dx} = C$ $(2)\int1\mathrm{dx}=x+C$ $(3)\int x^\mu \mathrm{dx}=\frac1{\mu+1}x^{\mu+1}+C(\mu \ne -1)$ $(4)\int\frac1{x}\mathrm{dx}=\ln|x|+C$ $(5)\int a^x \mathrm{dx}=\frac{a^x}{\ln a}+C$ $(6)\int e^x \mathrm{dx}=e^x+C$ $(7)\int \sin x \mathrm{dx}=-\cos x +C$ $(8)\int \cos x \mathrm{dx}=\sin x +C$ $(9)\int \sec^2 x \mathrm{dx}=\int \frac1{\cos^2 x}\mathrm{dx}=\tan x+C$ $(10)\int \csc^2x\mathrm{dx}=\int \frac1{\sin^2x}\mathrm{dx}=-\cot x +C$ $(11)\int\sec x\tan x\mathrm{dx}=\sec x+C$ $(12)\int \csc x\cot x\mathrm{dx}=-\csc x +C$ $(13)\int \frac{\mathrm{dx}}{\sqrt{1-x^2}}=\arcsin x+C$ $(14)\int \frac{\mathrm{dx}}{1+x^2}=\arctan x+C$ $(15)\int \tan x\mathrm{dx}=-\ln|\cos x|+C$ $(16)\int \cot x \mathrm{dx}=\ln|\sin x|+C$ $(17)\int \sec x \mathrm{dx}=\ln|\sec x+\tan x|+C$ $(18)\int \csc x\mathrm{dx}=\ln|\csc x -\cot x|+C$ $(19)\int \frac{\mathrm{dx}}{x^2+a^2}=\frac1{a}\arctan {\frac{x}{a}}+C$ $(20)\int \frac{\mathrm{dx}}{x^2-a^2}=\frac1{2a}\ln|\frac{x-a}{x+a}|+C$ $(21)\int \frac{\mathrm{dx}}{\sqrt{a^2-x^2}}=\arcsin \frac{x}{a}+C$ $(22)\int \frac{\mathrm{dx}}{\sqrt{x^2\pm a^2}}=\ln|x+\sqrt{x^2\pm a^2}|+C$ $(23)\int \sqrt{a^2-x^2}\mathrm{dx}=\frac{x}{2}\sqrt{a^2-x^2}+\frac{a^2}{2}\arcsin \frac{x}{a}+C$ $(24)\int \sqrt{x^2\pm a^2}\mathrm{dx}=\frac{x}{2}\sqrt{x^2\pm a^2}\pm \frac{a^2}{2}\ln|x+\sqrt{x^2\pm a^2}|+C$ $(25)\int \ln x\mathrm{dx}=x\ln x-x+C$ ~我们遇到什么困难也不要怕，微笑着面对它！消除恐惧的最好办法就是面对恐惧！坚持就是胜利！加油！奥利给！~ 【其他文章·微积分·线性代数】 不定积分公式 常用泰勒展开式 高阶求导公式 高等数学公式 常用等价无穷小 导数基本公式 矩阵章节总结 行列式章节总结 线性方程组章节总结]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性方程组章节总结]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E7%AB%A0%E8%8A%82%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[线性方程组章节总结 Guderian出品 线性方程组有解的充要条件 齐次线性方程组要么只有一组零解，要么有无穷多解 非齐次线性方程组有解的充要条件 $R(A)=R(A|\beta)$ 注：$R(A)$和$R(A|\beta)$要么相等，要么差$1$ 线性方程组解的结构 齐次线性方程组 (1) $AX=0$只有零解 $ \Leftrightarrow R(A)$等于未知数个数$\Leftrightarrow$A为列满秩阵 (2) $AX=0$有无穷多组解 $ \Leftrightarrow R(A)$小于未知数个数 非齐次线性方程组 (1) $AX=B$ 有唯一解 $\Leftrightarrow R(A)=R(A|\beta)=n$ (2) $AX=B$ 有无穷多组解 $\Leftrightarrow R(A)=R(A|\beta)&lt;n$ (3) $AX=B$ 无解 $\Leftrightarrow R(A) \ne R(A|\beta)$ 注：在非常严苛的条件下，以下两命题等价：$AX=B$ 有唯一解 $\Leftrightarrow $ $AX=0$只有零解（当$A$时方阵时成立） 线性方程组的解思想：利用矩阵初等行变换（高斯消元） 齐次线性方程组 记$N(A)$为齐次线性方程组的全体解向量所构成的向量空间，则$\dim N(A)=n-R(A)$，称$n(A)$的基为齐次线性方程组的基础解系： (1) 当$R(A)=n$时，齐次线性方程组只有零解，没有基础解系 (2) 当$R(A)&lt;n$时，基础解系为齐次线性方程组的$n-R(A)$个线性无关的解向量 非齐次线性方程组 $AX=B$ 和 $AX=0$的解向量满足： (1) 若$\eta_1$，$\eta_2$都是$AX=B$的解，那么$\eta_1 - \eta_2$是$AX=0$的解（几乎没用） (2) 若$\eta_1$是$AX=B$的解，$\eta_2$是$AX=0$的解，那么$\eta_1 + \eta_2$还是$AX=B$的解 ~我们遇到什么困难也不要怕，微笑着面对它！消除恐惧的最好办法就是面对恐惧！坚持就是胜利！加油！奥利给！~ 【其他文章·线性代数·微积分】 线性方程组章节总结 矩阵章节总结 行列式章节总结 常用泰勒展开式 高阶求导公式 高等数学公式 常用等价无穷小 导数基本公式 不定积分公式]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模式匹配算法：KMP算法]]></title>
    <url>%2FG-SS-Hacker.github.io%2FKMP%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[模式匹配算法：KMP算法 图：北京航空航天大学 Guderian出品 模式匹配是数据结构中字符串的一种基本运算，给定一个字符串P，要求在某个字符串T中找出与字符串P相同的所有子串，这就是模式匹配。 模式匹配算法要解决的问题 detection ：P是否出现 location ：首次在哪里出现 counting ：共有几次出现 enumeration ：各出现在哪里？ 绪论KMP算法（全称Knuth-Morris-Pratt算法）是一种高效的模式匹配算法。在模式匹配算法中，常见的算法包括BF算法（朴素算法）、KMP算法、BM算法、RK算法、有限自动机算法、Horspool算法、Sunday算法。在这些算法中，最经典的算法非KMP算法和BM算法莫属。这两种算法都有一个共同点：抽象，理解难度大。实际上，KMP算法还有一个明显特点：会者不难。本文内容默认你已经明白BF算法的原理和不足（因此这部分内容将简单略过），展开讲述KMP算法的原理、优点和c++代码实现。相信你在学会KMP算法之后将会有一种“踏遍青山人未老，这边风景独好”的快意。让我们开始吧。 BF算法BF算法的本质就是暴力搜索。既然要在串T中找出与串P相同的所有子串，那不妨找出串T中所有与串P长度相同的子串，在逐个判断这个子串是否与串P相同。具体的例子点击这里或者看下方的视频（讲得很形象了，应该不会有理解上的困难）。设strlen(T) == n, strlen(P) == m，则BF算法的预处理时间为$0$，匹配时间为$O(mn)$，总时间复杂度为$O(mn)$（简直是蜗速），在大部分应用场景中并不优秀。 KMP算法更高的效率容易看出BF算法的效率是十分蹩脚的，而它蹩脚的原因也很明显：在一次匹配尝试中，一旦失配（某一位匹配失败），就把串P整体向右移动一位。在模拟算法运行过程中，我们发现如果开始匹配时第一位就失配，那么只向右移动一位的确无可厚非，毕竟说不定移动一位之后就会匹配成功呢；但是如果已经匹配了串P的一部分了才失配，在向右移动一位之后，有时候（而且往往是经常）我们发现依然注定会匹配失败，也就是说在上次失败之后，向右移动一位再做尝试是根本不必要的，这种“只移动一位”的策略实际上造成了巨大的步骤浪费。那么有没有办法，把这些不必要的尝试舍弃，节约算法的运行时间呢？ 此处我们需要考虑以下问题，以便对BF算法做出有效的改进： 为什么有一些尝试是注定徒劳的？ 如何判断哪些尝试需要舍弃？ 如果不是向右移动一位，又应该如何确定向右移动的位数？ 在看完点击这里（还是上面那个链接）之后，前两个问题都能得到答案。在链接的视频讲解中，讲述者构造了一个前缀表数组prefix table来确定串P中每个从头开始的子串的最长公共前后缀（自身除外，以下省略此说明），一旦失配，就把串P向右移动到失配位置左侧子串的最长前缀处，使它们重叠，也就是把下图中的1号移动到2号位置，继续从当前位置匹配，如果当前位置为串T的结尾，则结束匹配。 那么问题来了：为什么要把最长公共前缀移动至最长公共后缀的位置？这个移动距离能不能更短？能不能更长？ **引理** 串的**最长公共前后缀**的**最长公共前后缀**是原串的**次长公共前后缀**。 **证明** 略~~（逃~~ 实际上，在BF算法的一次匹配过程中，一旦失配，就把串P整体向右移动一位再次尝试匹配。假设第一次匹配时在串P的第r + 1位失配，此时已经确定串P失配位置的前r项与串T相应位置元素匹配，也确定了串P失配位置的前r - 1项与串T相应位置元素匹配。那么第二次匹配成功，当且仅当在串P的前r项组成的子串中，前r - 1位字符组成的前缀和后r - 1位字符组成的后缀相同，即某一个公共前后缀长度为r - 1。也就是说，如果匹配失败向右移动s位，那么再次匹配成功的必要条件是串P在失配位置前的子串的某一个公共前后缀长度为r - s。如果串P在失配位置前的子串的最长公共前后缀长度就是r - s，匹配失败后向右移动了不足s位，这意味着移动距离过短，将会做一遍无用功。 如果移动距离过长，那就有可能会错过一个成功的匹配。如果匹配失败向右移动s位，那么再次匹配成功的必要条件是串P在失配位置前的子串的某一个公共前后缀长度为r - s。注意这里是必要条件而不是充分条件，在把串P向右移动的过程中，并不是在失配位置前随便放一个公共前后缀都能匹配成功，我们需要从最长公共前后缀开始尝试，逐步减少原失配位置前子串的长度，直到匹配成功或者串P在失配位置前子串最长公共前后缀长度变为0。 此处我们引入next[]数组来记录在失配时应该把串P的哪一位移动到当前位置。对于串P的第j + 1位的字符来说，next[j + 1]的意义是由串P的前j项的子串中最长公共前后缀的长度。next[]数组是KMP算法降低时间复杂度的关键，在预处理时就已经确定。下面介绍next[]数组求法。 next数组求法如果你直接跳过了前面看到了这里，那说明你已经看了无数多参考资料，还是搞不懂next[]数组求法的原理，几乎走投无路了。但是，正如B站鬼畜区某神所言： ~我们遇到什么困难也不要怕，微笑着面对它！消除恐惧的最好办法就是面对恐惧！坚持就是胜利！加油！奥利给！~ 回到正题。 先考虑求next[]数组的朴素算法：我们要求一个长度为l的串S的最长公共前后缀，因为自身除外，所以把串S复制一遍，产生一个串S&#39;，并让串S&#39;的第1位对齐串S的第2位，尝试匹配剩余l - 1位。若匹配成功，则剩余l - 1位就是串P的最长公共前后缀；若匹配失败，则把串S&#39;向右移动1位，再次尝试，知道匹配成功或串S&#39;已被移出串S的范围之内。 等一等，为什么这波操作如此熟悉？（战术后仰 是的，这就是所谓的“串P匹配自身”，有没有办法可以优化以上的朴素算法呢？ 我们的任务是求出串P每一个由前j项元素组成的子串的最长公共前后缀的长度。假设串P从字符串下标1开始存储，规定next[1] = 0，并从第2位开始匹配。设用串P&#39;匹配串P，当前匹配位置是串P&#39;的第j + 1位，串P的第i位，如果失配，那么处理方法同上面介绍的一样，把串P&#39;向右移动到失配位置左侧子串的最长前缀处，即令j = next[j]（思想：回溯），使它们重叠，即把下图中的1号移动到2号位置，继续从当前位置匹配；如果第j + 1位匹配成功，则更新串P前i位元素组成的子串的最长公共前后缀的长度为j，即令next[i] = j。 你已经明白了KMP算法的原理，那么不难推算出KMP算法的时间复杂度：预处理时间为$\Theta(m)$，匹配时间为$\Theta(n)$，总时间复杂度为$\Theta(m+n)$。与BF算法相比，KMP算法是一种优秀的模式匹配算法。 伪代码123456789101112131415161718192021222324252627282930KMP-MATCHER(T, P)n = T.lengthm = P.lengthnext = COMPUTE-PREFIX-FUNCTION(P)j = 0for i = 1 to n while j &gt; 0 and P[j + 1] != T[i] j = next[j] if P[j + 1] == T[j] j = j + 1 if j == m print "Pattern occurs with shift" i - m j = next[j] COMPUTE-PREFIX-FUNCTION(P)m = P.lengthlet next[1..m] be a new arraynext[1] = 0j = 0for i = 2 to m while j &gt; 0 and P[j + 1] != T[i] j = next[j] if P[j + 1] == T[j] j = j + 1 next[i] = jreturn next 例题：KMP算法模版题目描述输入两个字符串$s1$和$s2$（皆从下标为$1$处开始存储），$s2$为$s1$的子串，输出$s2$在$s1$中所有出现位置的下标。 输入格式第一行为$s1$，第二行为$s2$ 输出格式每行一个正整数表示s2在s1中出现的位置 输入样例12123456123123 输出样例1217 说明/提示 $s1$和$s2$的长度在$1000000$之内 运行速度不能太慢 解题方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//Presented by G-SS-Hacker//cc BY-NC-SA 4.0//Run on C++#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int MAXN = 1000000 + 100;const int MAXM = 1000000 + 100;//next,x0,x1,y0,y1,index cannot be named to variablesint nxt[MAXM]; //nxt[i]表示字串1到i最长公共前后缀的长度int len1, len2;char s1[MAXN], s2[MAXM];void pre()&#123; for(int j = 0, i = 2; i &lt;= len2; i++) &#123; while(j &amp;&amp; s2[i] != s2[j + 1]) j = nxt[j]; if(s2[i] == s2[j + 1]) j++; nxt[i] = j; &#125;&#125;void kmp()&#123; for(int j = 0, i = 1; i &lt;= len1; i++) &#123; while(j &amp;&amp; s1[i] != s2[j + 1]) j = nxt[j]; if(s1[i] == s2[j + 1]) j++; if(j == len2) cout &lt;&lt; i - len2 + 1 &lt;&lt; endl, j = nxt[j]; &#125;&#125;int main()&#123; cin &gt;&gt; s1 + 1 &gt;&gt; s2 + 1; len1 = strlen(s1 + 1); len2 = strlen(s2 + 1); pre(); kmp(); return 0;&#125; 结束语~我们遇到什么困难也不要怕，微笑着面对它！消除恐惧的最好办法就是面对恐惧！坚持就是胜利！加油！奥利给！~ 【其他文章·数据结构】 拓扑排序 图的表示 数据结构绪论]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C-plus-plus</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用泰勒展开式]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E5%B8%B8%E7%94%A8%E6%B3%B0%E5%8B%92%E5%B1%95%E5%BC%80%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[常用泰勒展开 Guderian出品 $(1)e^x=1+x+\frac{x^2}{2!}+\dots +\frac{x^n}{n!}+\frac{e^{\theta x}}{(n+1)!}x^{n+1}$ $(2)\sin x=x-\frac{x^3}{3!}+\frac{x^5}{5!}-\dots+(-1)^m\frac{x^{2m+1}}{(2m+1)!}+(-1)^{m+1}\frac{\cos \theta x}{(2m+3!)}x^{2m+3}$ $(3)\cos x=1-\frac{x^2}{2!}+\frac{x^4}{4!}-\dots+(-1)^m\frac{x^{2m}}{(2m)!}+(-1)^{m+1}\frac{\cos \theta x}{(2m+2)!}x^{2m+2}$ $(4)\ln(1+x)=x-\frac{x^2}{2}+\frac{x^3}{3}-\dots+(-1)^{n-1}\frac{x^n}{n}+(-1)^n\frac{x^{n+1}}{(n+1)(1+\theta x)^{n+1}}$ $(5)(1+x)^\alpha=\sum_{k=0}^n C_\alpha^n x^n+C_\alpha^{n+1}x^{n+1}(1+\theta x)^{\alpha -n-1}$ ~我们遇到什么困难也不要怕，微笑着面对它！消除恐惧的最好办法就是面对恐惧！坚持就是胜利！加油！奥利给！~]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵章节总结]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E7%9F%A9%E9%98%B5%E7%AB%A0%E8%8A%82%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[矩阵章节总结 Guderian出品 矩阵（matrix）形式优美，应用广泛。但是笔者相当头痛矩阵问题。实际上，矩阵的计算绝对不能靠硬算（硬算的事交给Matlab就好了，实际上计算机做矩阵运算，为了避免数值不稳定问题，使用的是和人计算不同的算法），而是灵活变形后运用基本的计算公式；矩阵的证明则更离不开对公式及其推论的灵活运用。笔者从题海中抽象出矩阵计算的常用思想和性质。作者实属菜鸟，水平很菜，将就看看吧 ╮(╯_╰)╭ 运算律 $ {AB}= {BA}$时，矩阵运算满足交换律，故以下运算皆成立 $(\mathrm{i})( {A}\pm {B})^2= {A}^2 \pm 2 {AB} + {B}^2$ $(\mathrm{ii})( {A}+ {B})( {A}- {B})= {A}^2- {B}^2$ $(\mathrm{iii})( {AB})^2=( {BA})^2$ $ {A}^*， {A}’， {A}^{-1}$组合会产生十分令人头疼的问题，使用以下公式来缓解头疼 $(\mathrm{i})( {AB})’= {B}’ {A}’$ $(\mathrm{ii})( {AB})^{-1}= {B}^{-1} {A}^{-1}$ $(\mathrm{iii})( {A}^*)^{-1}=( {A}^{-1})^*$ 带系数的情况 $(\mathrm{i})|k {A}|=k^n| {A}|$ $(\mathrm{ii})(k {A})^{-1}=\frac1{k} {A}^{-1}$ $(\mathrm{iii})(k {A})’=k {A}’$ $(\mathrm{iv})\overline{k {A}}=\overline{k}\overline{ {A}}$ 共轭矩阵记住以下四个公式，以备突然考到 $(\mathrm{i})\overline{ {A}+ {B}}=\overline{ {A}}+\overline{ {B}}$ $(\mathrm{ii})\overline{k {A}}=\overline{k}\overline{ {A}}$ $(\mathrm{iii})\overline{ {AB}}=\overline{ {A}}\overline{ {B}}$ $(\mathrm{iv})|\overline{ {A}}|=\overline{| {A}|}$ 简单地记，凡是涉及共轭的题目，计算的时候看起来能取共轭的都取共轭 伴随矩阵 看到$ {A}^*$，以下公式至少用其一 $(\mathrm{i}) {A}^* {A}= {A} {A}^*=| {A}| {E}$ $(\mathrm{ii}) {A}^{-1}=\frac{ {A}^*}{| {A}|}$ $(\mathrm{iii})| {A}^*|=| {A}|^{n-1}$ $(\mathrm{iv})( {A}^*)^*=| {A}|^{n-2} {A}$ 伴随矩阵的特殊性质：极端的伴随矩阵 {R}({A}^*)=\begin{cases} n,\quad {R}({A})=n\\ 1,\quad {R}({A})=n-1\\ 0,\quad {R}({A})]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[行列式章节总结]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E8%A1%8C%E5%88%97%E5%BC%8F%E7%AB%A0%E8%8A%82%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[行列式章节总结 图：刺客伍六七 Guderian出品 行列式形式优美，应用广泛。但是笔者相当头痛行列式的计算问题和行列式等式的证明问题。为了让行列式计算与证明不那么难算，笔者从题海中抽象出行列式计算和证明的常用算法和性质。作者水平不高，将就看看吧 ╮(╯_╰)╭ 行列式计算公式1.行列式定义 \left|\begin{array}{cccc} a_{11} & a_{12} & \dots & a_{1n}\\ a_{21} & a_{22} & \dots & a_{2n}\\ \vdots & \vdots & & \vdots\\ a_{n1} & a_{n2} & \dots & a_{nn}\\ \end{array}\right| = \sum(-1)^{t(p_1p_2\dots p_n)}a_{p_11}a_{p_22}\dots a_{p_nn}特别地，对于二阶和三阶行列式，可直接用对角线法则求出结果。 2.行列式展开定理 引理 如果$n$阶行列式$D$中第$i$行（列）所有元素除$a_{ij}$外都是零，那么，$D$等于$a_{ij}$与它的代数余子式$A_{ij}$的乘积，即$D=a_{ij}A_{ij}$。 展开定理 行列式等于它的任一行（列）的各元素与其代数余子式的乘积之和，即 D=a_{i1}A_{i1}+a_{i2}A_{i2}+\dots a_{in}A_{in},\quad i=1,2,\dots,n;\\ D=a_{1j}A_{1j}+a_{2j}A_{2j}+\dots a_{nj}A_{nj},\quad j=1,2,\dots,n.推论 行列式$D$的任一行（列）元素与另一行（列）对应元素的代数余子式乘积之和等于$0$，即 a_{i1}A_{j1}+a_{i2}A_{j2}+\dots a_{in}A_{jn}=0,\quad i \ne j,\quad i,j=1,2,\dots ,n;\\ a_{1i}A_{1j}+a_{2i}A_{2j}+\dots a_{ni}A_{nj}=0,\quad i \ne j,\quad i,j=1,2,\dots ,n.行列式结果等于$0$的定理常用于填空题和判断题。 3.范德蒙定理 范德蒙定理的证明用到了第二数学归纳法，在行列式和矩阵中，任何看起来可以用数学归纳法证明的题目（甚至包括一部分计算题），都可以用数学归纳法来做。 D_n= \left|\begin{array}{cccc} 1 & 1 & \dots & 1\\ x_1 & x_2 & \dots & x_n\\ x_1^2& x_2^2& \dots & x_n^2\\ \vdots & \vdots & & \vdots\\ x_1^{n-1} & x_2^{n-1} & \dots & x_n^{n-1}\\ \end{array}\right| = \prod_{1\leq j]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高阶求导公式]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E9%AB%98%E9%98%B6%E6%B1%82%E5%AF%BC%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[高阶求导公式 Guderian出品 $ (1)(a^x)^{(n)}=a^x (\ln a)$ $ (2)(e^{ax})^{(n)} = a^n e ^{ax} $ $(3)(\sin x)^{(n)}=\sin(x+\frac {n\pi}2)$ $(4)(\cos x)^{(n)}=\cos(x+\frac{n\pi}2)$ $(5)(x^a)^{(n)}=a(a-1)\dots(a-n+1)x^{a-n},若n&gt;a，则导数等于零$ $(6)[\ln (x+a)]^{(n)}=(-1)^n \frac{(n-1)!}{(x+a)^n}，特别地，令a=0，(\ln x)^{(n)}=(-1)^n\frac{(n-1)!}{x^n}$ $(7)(\frac1{ax+b})^{(n)}=(-a)^{n} \frac{n!}{(ax+b)^{n+1}}，特别地，令a=1,(\frac1{x+b})=(-1)^n \frac{n!}{(x+b)^{n+1}}$ $(8)Leibniz公式：[f(x)g(x)]^{(n)}=\sum_{k=0}^n C_n^kf^{(k)}(x)g^{(n-k)}(x)，C_n^k=\frac{n!}{k!(n-k)!)}$ $(9)(f(x)\pm g(x))^{(n)}=f^{(n)}(x)+g^{(n)}(x)$ $(10)(af(x))^{(n)}=af^{(n)}(x)$]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拓扑排序]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[拓扑排序 图：索菲亚教堂 Guderian出品 拓扑是研究几何图形或空间在连续改变形状后还能保持不变的一些性质的一个学科。它只考虑物体间的位置关系而不考虑它们的形状和大小。 AOV网在工程领域，一个大规模工程常被拆分为多个子工程，这些子工程被称为活动（Activity），在有向图中以顶点（Vertex）表示活动，以有向边表示活动之间的先后关系，这样的有向图被称为AOV网（Activity On Vertex Network）。在AOV网中，如果出现了闭环，就意味着有若干个活动将被无限次重复，工程将永远无法完成；因此，一个具有实用价值的AOV网，必定是一个有向无环图（DAG，Directed Acyclic Graph）。 绪论对于一个有向无环图$G=(V,E)$，其拓扑排序是其上顶点的一个线性排序：对于有向边$(u,v)\in E$，顶点$u$在排序中在顶点$v$的前面（如果$G$包含环路，则不可能产生一个线性排序）。可以将$G$上各顶点在一条水平线上从左向右排开，且图的所有边的指向也都是从左向右。拓扑排序并未各顶点上的排序，而是各顶点逻辑上的排序，这种排序可能有不止一种。在工程上，常把一个大规模工程的各个子工程抽象为一个AOV网，用拓扑排序解决工程的调度问题。下面用一个示例说明拓扑排序的具体应用： 下图（a）表示的是某教授每天早上从起床后到上班前所发生的事情的AOV网。教授必须先完成某些活动，才能完成某些活动；而另一些活动则可以以任意次序完成。在图（a）中，有向边$(u,v)$表示的就是活动$u$必须在活动$v$前完成。图（b）将拓扑排序后的有向无环图在一条水平直线上展示出来。如图（b）所示，该有向无环图所有边的指向都是从左到右。 （a） （b） 拓扑排序算法1. 基于入度的拓扑排序基于入度的拓扑排序算法，又被称为Kahn算法。以下摘选维基百科上关于Kahn算法的伪代码： 12345678910111213141516//TOPOLOGICAL-SORT(G)L ← Empty list that will contain the sorted elementsS ← Set of all nodes with no incoming edgeswhile S is non-empty do remove a node u from S insert u into L for each node v with an edge e from u to v do remove edge e from the graph if v has no other incoming edges then insert v into Sif graph has edges then return error (graph has at least onecycle)else return L (a topologically sortedorder) Kahn算法的基本思想是“走一步，看一步”。从以上伪代码不难看出Kahn算法的步骤：先统计所有顶点的入度，再把入度为零的顶点从图中分离出来，先放在集合$S$中，再从集合$S$中分别取出顶点放入线性表$L$中，然后把这个顶点指向的所有顶点的入度减1，并删除该顶点及所有与其相连的边。重复上述操作，直到所有顶点都被分离出来。若当集合$S$为空集时，线性表$L$中元素个数等于原来图中顶点的个数，则返回$L$，$L$中元素的排列即为该图的一种拓扑排序；若当集合$S$为空集时，线性表$L$中元素个数不等于原来图中顶点的个数，则意味着图中有闭环，返回错误信息，对图进行修改后再进行下一次拓扑排序。 对于图（a）的例子，首先我们找到入度为零的顶点有“刷牙”和“喂猫”，则把这两个顶点放入集合$S$中，$S=\{“刷牙”, “喂猫”\}$，$L=\varnothing$。 第一步、在$S$中选取”刷牙“并把该顶点从$S$中删除并放入线性表$L$中，”刷牙“与”洗脸“相连，删除相连的边，”洗脸“的入度减1，新的入度为0，把”洗脸“也放入$S$中。此时$S=\{“洗脸”, “喂猫”\}$，$L=“刷牙”$。 第二步、在$S$中选取“洗脸”并把该顶点从$S$中删除并放入线性表$L$中，“洗脸”与“吃饭”“更衣”相连，删除相连的边，”吃饭““更衣”的入度减1，新的入度为0，把”吃饭“”更衣“也放入$S$中。此时$S=\{“吃饭”, “更衣”, “喂猫”\}$，$L=“刷牙”\to“洗脸”$。 以此类推，第三步到第五步的结果分别如图（3）（4）（5）所示（第六步时$G=\varnothing$），采用同样的步骤，直至$S=\varnothing$，算法结束。 （3） （4） （5） 2. 基于深度优先搜索的拓扑排序基于深度优先搜索的拓扑排序算法同样见以下维基百科上关于该算法的伪代码： 1234567891011121314//TOPOLOGICAL-SORT(G)L ← Empty list that will contain the sorted nodesS ← Set of all nodes with no outgoing edgesfor each node v in S do visit(v) function visit(node v) if v has not been visited yet then mark v as visited for each node u with an edge from u to v do visit(u) add v to L 这个算法的过程非常直观：先把出度为零的顶点从图中分离出来，放在集合$S$中，再从集合$S$中分别取出顶点，递归访问其父顶点，若该顶点未被访问，则标记为“已访问”；到达递归基础后，将当前顶点放入线性表$L$中，并逐步回溯。 下证基于DFS的拓扑排序算法生成的是有向无环图的拓扑排序： 在有向无环图$G=(V,E)$上运行DFS，只需证明对于任意一对顶点$(u,v)\in E$，$u$的返回在$v$之前即可。 对边$(u,v)\in E $，在调用DFS(v)时，对于即将访问的$u$，不外乎以下两种情况： DFS(u)未被调用，即$u$未被mark，在当前路搜索路径的DFS树上，$u$是$v$的子节点。 DFS(u)已被调用，即$u$已被mark，则可知DFS(u)在另一条已经完成的搜索路径上返回。 对于这两种情况，$u$的返回都在$v$之前，得证。 例题：任务排序问题题目描述假定你需完成$n$项任务，这些任务之间并非独立，一项任务的执行当且仅当其所有前置任务已经被全部完成。 输入格式输入的数据包含若干组样例，每个样例的第一行包括两个整数$n$和$m$。$n$是任务的数量，$m$是任务之间先后关系的数量。接下来有$m$行，每行有两个整数$i$和$j$，表示任务$i$的执行必须在任务$j$之前。 输入结束的标志是一组$n=m=0$的样例。 输出格式对于每一组样例，在一行内输出$n$个整数，每两个整数之间用一个空格隔开，每一行数据表示一种可行的任务排序方案。 输入样例1234565 41 22 31 31 50 0 输出样例11 4 2 5 3 说明/提示$1 \leq n \leq 100$ 解题方法解法一、Kahn算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//Run on C++#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int MAXN = 110, MAXM = 110 * 110 / 2;struct edge&#123; int v, nxt;&#125;E[MAXM];queue &lt;int&gt; q;int n, m, cnt;int head[MAXN], in[MAXN];void addedge(int u, int v)&#123; E[++cnt].v = v; E[cnt].nxt = head[u]; head[u] = cnt;&#125;void init()&#123; cnt = 0; memset(head, 0, sizeof(head)); memset(E, 0, sizeof(E));&#125; int main()&#123; cin &gt;&gt; n &gt;&gt; m; while(n || m) &#123; init(); for(int i = 1; i &lt;= m; i++) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; addedge(u, v); in[v]++; &#125; for(int i = 1; i &lt;= n; i++) if(!in[i]) q.push(i); while(!q.empty()) &#123; int cur = q.front(); q.pop(); cout &lt;&lt; cur &lt;&lt; " "; for(int i = head[cur]; i; i = E[i].nxt) if(!--in[E[i].v]) q.push(E[i].v); &#125; cout &lt;&lt; endl; cin &gt;&gt; n &gt;&gt; m; &#125; return 0;&#125; 解法二、DFS1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//Run on C++#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int MAXN = 110, MAXM = 110 * 110 / 2;struct edge&#123; int u, nxt;&#125;E[MAXM];queue &lt;int&gt; q;int n, m, cnt;int head[MAXN], out[MAXN];bool flag[MAXN];void addedge(int u, int v)&#123; E[++cnt].u = u; E[cnt].nxt = head[v]; head[v] = cnt;&#125;void init()&#123; cnt = 0; memset(head, 0, sizeof(head)); memset(E, 0, sizeof(E)); memset(out, 0, sizeof(out)); memset(flag, 0, sizeof(flag));&#125; void dfs(int V)&#123; if(!flag[V]) &#123; flag[V] = true; for(int i = head[V]; i; i = E[i].nxt) dfs(E[i].u); cout &lt;&lt; V &lt;&lt; " "; &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; while(n || m) &#123; init(); for(int i = 1; i &lt;= m; i++) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; addedge(u, v); out[u]++; &#125; for(int i = 1; i &lt;= n; i++) if(!out[i]) q.push(i); while(!q.empty()) &#123; dfs(q.front()); q.pop(); &#125; cout &lt;&lt; endl; cin &gt;&gt; n &gt;&gt; m; &#125; return 0;&#125;]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C-plus-plus</tag>
        <tag>算法</tag>
        <tag>排序</tag>
        <tag>数据结构</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高等数学公式]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[高等数学公式 Guderian出品 立方公式1.立方和公式$a^3+b^3=(a+b)(a^2-ab+b^2)$ 2.立方差公式$a^3-b^3=(a-b)(a^2+ab+b^2)$ 3.三项立方和公式$a^3+b^3+c^3-abc=(a+b+c)(a^2+b^2+c^2-ab-bc-ac)$ 4.完全立方和公式$(a+b)^3=a^3+3a^2b+3ab^2+b^3$ $(a-b)^3=a^3-3a^2b+3ab^2-b^3$ 5.立方和累加$1^3+2^3+\ldots +n^3=[\frac{n(n+1)}{2}]^2=(1+2+\ldots+n)^2$ 和差化积公式$\sin \alpha+\sin \beta=2\sin \frac{\alpha+ \beta}{2} \cos \frac{\alpha- \beta}{2}$ $\sin \alpha-\sin\beta=2\cos \frac{\alpha+ \beta}{2}\sin \frac{\alpha- \beta}{2}$ $\cos \alpha+\cos \beta=2\cos \frac{\alpha + \beta}{2}\cos \frac{\alpha- \beta}{2}$ $\cos \alpha - \cos \beta=-2\sin \frac{\alpha+ \beta}{2}\sin \frac{\alpha- \beta}{2}$ 积化和差公式$\sin \alpha \sin \beta=\frac12[\sin(\alpha + \beta)+\sin(\alpha - \beta)]$ $\sin \alpha \cos \beta=\frac12[\sin(\alpha + \beta)-\sin(\alpha - \beta)]$ $\cos \alpha \sin \beta=\frac12[\cos(\alpha + \beta)+\cos(\alpha - \beta)]$ $\cos \alpha \cos \beta=\frac12[cos(\alpha + \beta)-cos(\alpha - \beta)]$ 万能公式$\sin \theta=\frac{2\tan \frac{\theta}{2}}{1+\tan^2\frac{\theta}{2}}$ $\cos \theta=\frac{1-\tan^2\frac{\theta}{2}}{1+\tan^2\frac{\theta}{2}}$ $\tan \theta=\frac{2\tan \frac{\theta}{2}}{1-\tan^2 \frac{\theta}{2}}$ ​ 平方和拓展$1^2+2^2+\ldots+n^2=\frac1{6}n(n+1)(2n+1)$ $1\times2+2\times3+\ldots+n(n+1)=n(n+1)(n+2)$ 裂项相消$\frac1{n(n+1)(n+2)}=\frac12[\frac1{n(n+1)}-\frac1{(n+1)(n+2)}]$]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用等价无穷小]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E5%B8%B8%E7%94%A8%E7%AD%89%E4%BB%B7%E6%97%A0%E7%A9%B7%E5%B0%8F%2F</url>
    <content type="text"><![CDATA[常用等价无穷小 Guderian出品 基础版当$x\to0$时， $(1)\sin x \sim x$ $(2)\tan x \sim x$ $(3)\arcsin x \sim x$ $(4)\arctan x \sim x$ $(5)1-\cos x \sim \frac12 x^2$ $(6)a^x-1 \sim x \ln a$ $(7)e^x-1 \sim x$ $(8)(1+x)^a-1 \sim ax$ * $(9)\ln (1+x) \sim x$ $(10)\sqrt{1+x}-1 \sim \frac12x$ 进阶版当$x\to0$时， $(11)\log_a(1+x) \sim \frac{x}{\ln a}$ $(12)\sqrt[n]{1+x}-1\sim \frac{x}{n}$ $(13)x-\sin x\sim \frac16x^3$ $(14)\tan x-x\sim\frac13x^3$ $(15)\arcsin x-x\sim\frac16x^3$ $(16)x-\arctan x\sim \frac13x^3$ $(17)\tan x-\sin x\sim \frac12x^3$ *. 见Bernoulli不等式：$(1+x)^n \ge 1+nx$ &#8617;]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[导数基本公式]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E5%AF%BC%E6%95%B0%E5%9F%BA%E6%9C%AC%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[导数基本公式 Guderian出品 $(1)(C)’ = 0$ $(2)(x^a)’=ax^{a-1}$ $(3)(a^x)’=a^x\ln a (a&gt;0且a\not=1)$ $(4)(e^x)’=e^x$ $(5)(\log_ax)’=\frac{1}{x\ln a}(a&gt;0且a\not=1)$ $(6)(\ln x)’=\frac1{x}$ $(7)(\sin x)’=\cos x$ $(8)(\cos x)’=-\sin x$ $(9)(\tan x)’=\frac1{\cos^2x}=\sec^2x$ $(10)(\cot x)’=\frac1{-\sin^x}=-\csc^2x$ $(11)(\sec x)’=\sec x\tan x$ $(12)(\csc x)’=-\csc x\cot x$ $(13)(\arcsin x)’=\frac1{\sqrt{1-x^2}}$ $(14)(\arccos x)’=-\frac1{\sqrt{1-x^2}}$ $(15)(\arctan x)’=\frac1{1+x^2}$ $(16)(\mathrm{arccot} x)’=-\frac1{1+x^2}$]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图的表示]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[图的表示 Guderian出品 绪论对于图 $G=(V,E)$ 1，可以用多种表示方法来表示，其中不同的表示方法分别适用与不同特点的图和对图进行不同的操作。在此介绍三种图的表示方法：邻接表、邻接矩阵和边集数组，并将呈现三种存图方法的C和C++代码实现。 存图方法1.邻接矩阵邻接矩阵是一种简单、易用但有较大局限性的存图方式。由于图是由点集和边集两部分组成，难以找到一种线性结构来同时表示两者，那么，由于每条特定的边都可由其两端顶点唯一确定（假设无重边），我们很自然地可以想到使用一个$|V|$ $*$ $|V|$的方矩阵$A = (a_{ij})$来表示，对于无权图，该矩阵满足： a_{ij} = \left\{ \begin{array}{} 1, \ (i, j) \in E\\ 0, \ (i, j) \notin E \end{array} \right.对于带权图，该矩阵满足： a_{ij} = \left\{ \begin{array}{} w, \ (i, j) \in E\\ \infty \ or \ 0\ or-1, \ (i, j) \notin E \end{array} \right. 【例1】 无向带权图示例如下图所示： 上图对应的邻接矩阵表示如图： \mathbf{A} =\left( \begin{array}{ccc}a_{11} & a_{12} & a_{13} & a_{14} \\\\a_{21} & a_{22} & a_{23} & a_{24} \\\\a_{31} & a_{32} & a_{33} & a_{34} \\\\a_{41} & a_{42} & a_{43} & a_{44}\end{array} \right)\mathbf{} =\left( \begin{array}{ccc}\infty & 4 & 5 & 7 \\\\4 & \infty & 2 & 2 \\\\5 & 2 & \infty & 3 \\\\7 & 2 & 3 & \infty\end{array} \right) 123456789//Run on C/C++const int n = 4; //n个顶点const int inf = 0x3f3f3f3f; //正无穷int G[n][n] = &#123; &#123;inf, 4, 5, 7&#125;, &#123;4, inf, 2, 2&#125;, &#123;5, 2, inf, 3&#125;, &#123;7, 2, 3, inf&#125;&#125;; 【例2】 有向带权图示例如下图所示： 上图对应的邻接矩阵表示如图： \mathbf{A} =\left( \begin{array}{ccc}a_{11} & a_{12} & a_{13} & a_{14} \\\\a_{21} & a_{22} & a_{23} & a_{24} \\\\a_{31} & a_{32} & a_{33} & a_{34} \\\\a_{41} & a_{42} & a_{43} & a_{44}\end{array} \right)\mathbf{} =\left( \begin{array}{ccc}\infty & 4 & 5 & 7 \\\\0 & \infty & 2 & 2 \\\\0 & 0 & \infty & 3 \\\\0 & 0 & 0 & \infty\end{array} \right) 123456789//Run on C/C++const int n = 4; //n个顶点const int inf = 0x3f3f3f3f; //正无穷int G[n][n] = &#123; &#123;inf, 4, 5, 7&#125;, &#123;0, inf, 2, 2&#125;, &#123;0, 0, inf, 3&#125;, &#123;0, 0, 0, inf&#125;&#125;; 【例1】【例2】分别给出了无向无权图和有向无权图的邻接矩阵表示，不管一个图有多少条边，邻接矩阵的空间复杂度都为$O(V^2)$。 不难看出，无向图的邻接矩阵是一个对称矩阵。由于在无向图中，边$(u,v)$与边$(v,u)$表示同一条边，无向图的邻接矩阵$A$就是自己的转置，即$A = A^T$。在存储时，可以只存放主对角线及其以上的这部分邻接矩阵（即半个矩阵），从而将图存储空间需求减少几乎一半。 邻接矩阵表示简单、容易理解，对已知的边操作的效率高（插入、删除、查询的时间复杂度都是$O(1)$。但是邻接矩阵的缺陷在于其空间复杂度巨大，在稠密图上邻接矩阵可以取得较好的利用率，但是在稀疏图 2上使用邻接矩阵将会造成大量内存空间的浪费，很容易导致内存溢出。因此，在使用邻接矩阵存图时一定要格外注意内存空间的限制，不可盲目追求简单而忽略了内存空间的优化。 2.邻接表邻接表是一种具有高度鲁棒性 3、适用于大多数情况的存图方法。对于图$ G = (V,E)$，其邻接表表示由一个包含$|V|$条链表的数组Adj[] 4所构成，每个顶点有一条链表。对于每个顶点$u\in V$，邻接表Adj[u]包含所有与顶点$u$之间有边相连的顶点$v$，即Adj[u]包含图$G$中所有与$u$邻接的顶点。邻接表本质上是使用链表存边，一条链表代表着一个点发出的所有边，通过链表存储和遍历和一个顶点相连的所有边，并根据实际应用情况选择是否存储边权。在C/C++中，实现邻接表的方法主要有两种：链式向前星和vector存图。 【例3】 有向带权图示例如下图所示： 上图对应的邻接表表示如图： 链式向前星存图法是利用了一种特殊的链表，这种链表具有普通链表链式存储的特征，但其插入新元素的方式却是“向前星”，即从链表表头插入元素，每次只更新表头，因此得名链式向前星。在使用链式向前星时，应很好的理解这种数据结构与普通链表的区别。 123456789101112131415161718192021222324252627282930313233//链式向前星//Run on C/C++#include&lt;iostream&gt;using namespace std;const int n = 4, m = 6; //n个顶点，m条边struct edge&#123; int w, v, nxt; //nxt指向同一个顶点发出的另一条边&#125;E[n];int cnt = 0;int head[m]; //假设从0号顶点开始存储void add(int u, int v, int w) //改变编号为cnt的边&#123; E[++cnt].v = v; //出边指向v E[cnt].w = w; //记录边权 E[cnt].nxt = head[u]; //将其指向目前链表的表头（重要！） head[u] = cnt; //将表头更新为目前的编号（重要！）&#125;int main()&#123; add(1, 2, 4); add(1, 4, 7); add(1, 3, 5); add(3, 4, 3); add(3, 2, 2); add(2, 4, 2); return 0;&#125; vector存图实际上是利用了一个不定长的链表该存储从一个顶点出发的所有边的情况，与普通链表类似，vector也是从链表的尾端进行插入操作，因此vector存图法在理解难度上比链式向前星要简单。然而由于C/C++语言的原因，使用vector存图实际使用的内存比链式向前星的要大，因此内存溢出的风险也会更大。 123456789101112131415161718192021222324252627282930//vector存图，使用stl::pair版//Run on C/C++#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int n = 4; //n个顶点vector&lt;pair&lt;int, int&gt;&gt; E[n + 1]; //int（first）为u，int（second）为vvoid add(int u, int v, int w)&#123; E[u].push_back(&#123;v, w&#125;);&#125;int main()&#123; add(1, 2, 4); add(1, 4, 7); add(1, 3, 5); add(3, 4, 3); add(3, 2, 2); add(2, 4, 2); for(int i = 1; i &lt;= n; i++) for(int j = 0; j &lt;(int)E[i].size(); j++) cout&lt;&lt;i&lt;&lt;" "&lt;&lt;E[i][j].first&lt;&lt;" "&lt;&lt;E[i][j].second&lt;&lt;endl; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435//vector存图，使用结构体版//Run on C/C++#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int n = 4; //n个顶点struct edge&#123; int v, w;&#125;;vector&lt;edge&gt;E[n + 1];void add(int u, int v, int w)&#123; E[u].push_back(&#123;v, w&#125;);&#125;int main()&#123; add(1, 2, 4); add(1, 4, 7); add(1, 3, 5); add(3, 4, 3); add(3, 2, 2); add(2, 4, 2); for(int i = 1; i &lt;= n; i++) for(int j = 0; j &lt;(int)E[i].size(); j++) cout&lt;&lt;i&lt;&lt;" "&lt;&lt;E[i][j].v&lt;&lt;" "&lt;&lt;E[i][j].w&lt;&lt;endl; return 0;&#125; 不管是用链式向前星存图还是vector存图，邻接表的空间复杂度都为$O(E + V)$。与邻接矩阵相比，邻接表的空间复杂度更小，空间利用率更高。但是邻接表使用链式结构存储边，这导致了对边操作的时间复杂度为$O(n)$，因此邻接表并不适用于需要频繁对边操作的情况；对于稠密图，邻接表的性能也不比邻接矩阵更占上风。然而，对于不需要频繁对边进行操作的稀疏图，使用邻接表存图比使用邻接矩阵存图可以期待更高的效率。综上，邻接表不失为一种性能优秀的存图方法。 3.边集数组边集数组也是一种简单、易用但有较大局限性的存图方式。边集数组由一个一维结构体数组e[]构成，数组的每个数据元素由一条边的起点下标（u），终点下标（v）和权值（w）组成，如下图所示。不难看出，边集数组关注边的集合，而不关注点的集合。因此，使用这种存图方法在需要遍历图的边集时可以获得很高的效率，但是在遍历图的点集时效率简直是灾难。不论一个图有多少个顶点，边集数组的空间复杂度都为$O(E)$。 【例4】 有向带权图示例如下图所示： 上图对应的边集数组如下表所示： u v w e[1] 1 2 4 e[2] 1 4 7 e[3] 1 3 5 e[4] 3 4 3 e[5] 3 2 2 e[6] 2 4 2 12345678910111213141516//Run on C/C++const int m = 6; //m条边struct edge&#123; int u, v, w;&#125;;edge E[m] = &#123; &#123;1, 2, 4&#125;, &#123;1, 4, 7&#125;, &#123;1, 3, 5&#125;, &#123;3, 4, 3&#125;, &#123;3, 2, 2&#125;, &#123;2, 4, 2&#125;&#125;; 据观察，这种存图方法主要用于实现最小生成树的Krusal算法，其他情况下较少使用。 1. 图，graph，记为“G”；顶点，vertex，记为“V”；边，edge，记为“E”。 &#8617; 2. 稠密图与稀疏图的判断标准：(1)定性分析：稠密图的边数非常接近于完全图（即$n(n-1)$），而稀疏图的边数比完全图少得多。(2)定量分析：边数多于$nlogn$的图为稠密图，边数少于$nlogn$的图为稀疏图。 &#8617; 3. 鲁棒性，robust，即健壮性 &#8617; 4. 邻接表，adjlist，记为”Adj” &#8617;]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C-plus-plus</tag>
        <tag>C</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法性能比较]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[排序算法性能比较 Guderian出品 .tg {border-collapse:collapse;border-spacing:0;}.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg .tg-cly1{text-align:left;vertical-align:middle}.tg .tg-0lax{text-align:left;vertical-align:top} 类别 排序方法 时间复杂度 空间复杂度 稳定性 平均情况 最坏情况 插入排序 直接插入 O(n2) O(n2) O(1) 稳定 希尔排序 O(n1.3) O(n2) O(1） 不稳定 选择排序 直接选择 O(n2) O(n2) O(1) 不稳定 堆排序 O(nlogn) O(nlogn) O(1) 不稳定 交换排序 冒泡排序 O(n2) O(n2) O(1) 稳定 快速排序 O(nlogn) O(n2) O(logn) 不稳定 归并排序 O(nlogn) O(nlogn) O(n) 稳定 基数排序 O(d(r+n)) O(d(r+n)) O(r+n) 稳定 桶排序 O(2(m+n)) O(2(m+n)) O(max{key}) 稳定 *注：基数排序中，d表示关键字的位数长度，r表示关键字每一个数位有r中可能的取值 **注：桶排序中，m表示桶的个数]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加密算法]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[加密算法 Guderian出品 加密算法的历史加密算法是一种古老的算法，在人类几千年来的历史进程中，加密算法随着一场场战争的爆发而不断进步，从古罗马时代到第二次世界大战，从凯撒密码到恩尼格玛密码。然而，就像矛和盾的关系一样，加密技术和解密技术也在不断螺旋式发展。下面，笔者将向读者朋友们介绍一种古老的科技：凯撒密码。 在战争中，命令的传递往往需要通过传令兵。如： 后方指挥部 ———传令兵携带命令“攻打X城”———>我方部队可是，一旦传令兵被敌方抓获，重要的军事情报就会泄露给敌方。 后方指挥部—命令“攻打X城”—>敌方部队甚至，敌人可能会篡改命令，并收买传令兵把假情报传给我方部队。 后方指挥部—命令“攻打X城”—>敌方部队—命令“攻打Y城”—>我方部队这样一来，我方部队就会完全落入敌方陷阱中。为了防止这种情况发生，在没有更好的传达命令的方法的情况下，我们不妨修改命令的内容，让敌人即使截获了命令，也无法看懂命令的内容，这就是对信息的加密。 后方指挥部—命令“@#￥！！”—>敌方部队：？？？如何进行加密呢？有一种非常朴素的加密方法叫凯撒密码，它的基本思路就是偏移。 如图所示，图中第一行的字母代表明文，第二行字母代表密文。这个加密算法十分简单，选择一个偏移量，此处是3，把明文当中的所有字母按照字母表的顺序向后偏移三位，从而生成密文。比如： 1234A - &gt; DB - &gt; EC - &gt; FLOL - &gt; MPM 这样一来，就算我军的密码被敌军截获，敌军也无法看懂。一旦我方部队收到了我方的命令，只要逆转原来加密的过程，把密文以偏移量3往左偏移解密为明文，就可以正确收到我方的命令。假设敌军已知我方的加密算法，想要破解，把26个字母都试一遍，终究可以得到正确的原文，这就叫暴力破解。 现代加密算法1.对称加密算法明文--密钥-->密文--密钥-->明文这很好理解，这就好比给你需要传递的信息加上一把锁，这把锁的钥匙只有你和信息接收方拥有，这样就算信息被截获，也只能看出一堆乱码。只要传递方与接收方事先得到一致的密钥，双方就可以安全进行信息往来。 常见的对称加密算法有DES算法和3DES算法，它的基本方法是替换+移位；还有美国联邦政府采用的AES算法；还有RC-5算法和IDEA算法。office Word、Excel、Powerful、pdf、WinRAR的加密算法都属于对称加密算法。 对称加密算法的优点是简单高效，然而缺点却也很明显，那就是安全性低。比如下面这种情况： 你想要给某人通过QQ发送一个加了密的word文档，你发过去了但你的小伙伴打不开，那他当然会向你要密码。为了让他能顺利打开这个文档，你又要给他发送文档的密码。这样一来，你的文档就没有任何安全性可言了。如果你的文档被不怀好意的人截获，那他当然也能截获你的密码。 为了解决对称加密算法安全性低的问题，科学家发明了非对称加密算法。 2. 非对称加密算法明文--公钥-->密文--私钥-->明文 明文--私钥-->密文--公钥-->明文在非对称加密算法中有一对密钥，其中一个叫公钥、另一个叫私钥。如果要加密一个文档，我们既可以用公钥加密文档，用私钥解密文档；也可以用私钥加密文档，用公钥解密文档。最常见的非对称加密算法就是大名鼎鼎的RSA算法，几乎无法破解。 非对称加密算法的缺点是效率低下，然而其优点是安全性极高，解决了对称加密算法的安全性低的问题。比如下面这种情况： 在一间公司中，每一个员工都有自己的一对公钥和私钥，公钥可以交给他人，但是私钥只有自己知道。员工之一的你想要给同样为员工的某人通过QQ发送一个文档，你只需要向接受者索要他的公钥，他就会光明正大地通过QQ发给你，你再利用他的公钥给文档加密，然后光明正大地通过QQ发给他，他接收到你发送的已用他的公钥加密过的文档之后，就可以用他的私钥解密，从而顺利的查看文档了。在这个过程中，就算文档和公钥都被截获，因为没有相应的私钥，也无法正常还原。因此，这个非对称加密算法的安全性比对称加密算法提高了一个等级。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>网络与信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OSI/RM七层模型]]></title>
    <url>%2FG-SS-Hacker.github.io%2FOSIRM%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[OSI/RM = Open System Interconnection Reference Model 计算机网络：OSI/RM七层模型 Guderian出品 在计算机网络建立之初，各大计算机企业之间并没有一套通用的标准来规范计算机网络的建设，相反，各企业在自己的计算机系统上实行自己的标准，这就造成了一种局面：不同品牌计算机之间不能实现互连。要知道互联网建立之初的目的就是让把全世界的计算机连接起来，实现信息共享。这个目标在今天已经基本实现，然而在上个世纪七八十年代，苹果的计算机和IBM的计算机的网路接口都不一样，更不用说两者互连了。这种情况在不同品牌 的计算机之间比比皆是，制约了世界互联网的发展，同时也制约了互联网市场规模的增长。 此时，各计算机企业需要一套公用的标准来规范计算机网络的建设。然而，每一家企业都希望推行自己的标准，不愿意使用别人的标准。正如现在我们所说：“一流的公司定标准。”当别人制定好了标准，你再依据这个标准开发产品的时候，实际上你已经比别人落后了，也就是说标准制定者永远站在领先的位置。各计算机企业争执不下，标准的制定再次陷入僵局。 既然各计算机企业都不愿意放弃自己的标准，使用别人的标准，那么有人提议，我们全部放弃自己的标准，由国际标准化组织（nternational Organization for Standardization, ISO)来制定一套标准，我们就全部采用那套标准。这一提议得到了计算机企业的广泛认可。于是ISO就制定了开放系统互连(OSI)模型，并由全世界的计算机企业以此为标准开发和建立计算机网络。虽然从今天的角度看，这套标准有些繁琐，层次显得太多，但是因为这套标准已经被遵循多年，所以被一直延续了下来，未曾改变。 OSI/RM七层模型 .tg {border-collapse:collapse;border-spacing:0;}.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top} 层次 名称 主要功能 主要设备及协议 7 应用层 实现具体的应用功能 POP3、FTP、HTTP、Telnet、SMTPDHCP、TFTP、SNMP、DNS 6 表示层 数据的格式与表达、加密、压缩 5 会话层 建立、管理和终止对话 4 传输层 端到端的连接 TCP、UDP 3 网络层 分组传输和路由选择 三层交换机、路由器ARP、RARP、IP、ICMP、IGMP 2 数据链路层 传输以帧为单位的信息 网桥、交换机、网卡PPTP、L2TP、SLIP、PPP 1 物理层 二进制传输 中继器、集线器]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows10常用快捷键]]></title>
    <url>%2FG-SS-Hacker.github.io%2FWindows10%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[Life is short, you need shortcuts Windows 10常用快捷键 Guderian出品 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647Windows 徽标键 + I —&gt; 打开“设置”Windows 徽标键 + E —&gt; 打开“文件资源管理器”Windows 徽标键 + D —&gt; 显示和隐藏桌面Windows 徽标键 + L —&gt; 锁定电脑Windows 徽标键 + M —&gt; 最小化所有窗口Windows 徽标键 + R —&gt; 打开“运行”对话框Windows 徽标键 + 逗号 (,) —&gt; 临时快速查看桌面Windows 徽标键 + 数字 —&gt; 打开桌面，并启动固定到任务栏的位于该数字所表示位置的应用。如果该应用已在运行，则切换到该应用。Windows 徽标键 + Tab —&gt; 打开“任务视图”Windows 徽标键 + 向上键 —&gt; 最大化窗口Windows 徽标键 + 向下键 —&gt; 从屏幕中删除当前应用或最小化桌面窗口Windows 徽标键 + 向左键 —&gt; 将应用或桌面窗口最大化到屏幕左侧Windows 徽标键 + 向右键 —&gt; 将应用或桌面窗口最大化到屏幕右侧Alt + Enter —&gt; 打开选定项的“属性”对话框Backspace —&gt; 查看上一个文件夹F2 —&gt; 重命名选定项F3 —&gt; 在文件资源管理器中搜索文件或文件夹Ctrl + X —&gt; 剪切选定项Ctrl + C（或 Ctrl + Insert） —&gt; 复制选定项Ctrl + V（或 Shift + Insert） —&gt; 粘贴选定项Ctrl + Z —&gt; 撤消操作Ctrl + Y —&gt; 重做操作Alt + Tab —&gt; 在打开的应用之间切换Alt + F4 —&gt; 关闭活动项，或者退出活动应用]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Windows10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typora常用快捷键大全]]></title>
    <url>%2FG-SS-Hacker.github.io%2FTypora%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[Life is short, you need shortcuts Typora常用快捷键大全 Guderian出品 .tg {border-collapse:collapse;border-spacing:0;}.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg .tg-m9r4{background-color:#ffffc7;text-align:left;vertical-align:top}.tg .tg-ncd7{background-color:#ffffc7;border-color:inherit;text-align:left;vertical-align:top}.tg .tg-0lax{text-align:left;vertical-align:top}.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top} 操作类型 操作 快捷键 文件操作 新建 Ctrl + N 新建窗口 Ctrl + Shift + N 打开 Ctrl + O 快速打开 Ctrl + P 保存 Ctrl + S 另存为 Ctrl + Shift + S 偏好设置 Ctrl + 逗号 关闭 Ctrl + W 编辑操作 选中当前行/句 Ctrl + L 选中当前格式文本 Ctrl + E 选中当前词 Ctrl + D 查找 Ctrl + F 替换 Ctrl + H 查找下一个 F3 查找上一个 Shift + F3 段落操作 提升标题等级 Ctrl + = 降低标题等级 Ctrl + - 格式操作 加粗 Ctrl +Ｂ 斜体 Ctrl + I 下划线 Ctrl + U 代码 Ctrl + Shift + ` 删除线 Alt + Shift + 5 超链接 Ctrl + K 图像 Ctrl + Shift + I 清除样式 Ctrl + \ 【其他文章·Markdown·Windows10】 Markdown需要转义的字符及其转义方法 Typora常用快捷键大全 Windows10常用快捷键]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Think before you ask]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E5%85%88%E6%80%9D%E8%80%83%EF%BC%8C%E5%86%8D%E6%8F%90%E9%97%AE%2F</url>
    <content type="text"><![CDATA[If you want something done right, do it yourself. Think before you ask Guderian出品 自己动手，丰衣足食毛泽东曾经说过：“自己动手，丰衣足食。”关于求助这件事，其实很多时候看源代码或者帮助文档能解决很多问题，如果实在没有，一般你遇到的问题别人可能也遇到过，善用搜索引擎能解决更多问题。有一个说法:普通程序员 + google = 超级程序员。所以在平时要养成一些习惯，仔细阅读帮助文档，阅读源代码，善用搜索引擎，实在没辙了再提问。 在一些问答网站上，经常可见回答的一些缩写，很有趣也很有用，在此将其列举出来： RTFSC(Read the fucking source code) RTFM(Read the fucking manual) UTFH (Use The Fucking Help) STFW (Search The Fucking Web) STFG (Search The Fucking Google) GIYF (Google Is Your Friend) JFGI (Just Fucking Google It) UTSL (Use The Source Luke) RTFA (Read The Fucking Article) RTFE (Read The Fucking Email) RTFC (“Read The Fucking Code” or “Reboot The Fucking Computer”) RTFQ (Read The Fucking Question) LMGTFY (Let Me Google That For You) WIDGI (When In Doubt Google It) FIOTI (Find It On The Internet) 通常，给出这些答案的人已经通过这些办法找到了解决问题的关键，正在一边看一边敲键盘。这些回复意味着他认为：第一，你要的信息可以靠你自己的力量找到。第二，自已找要比别人喂到嘴里能学得更多。你不应该觉得这样就被冒犯了，按黑客的标准，他没有不理你就是在向你表示某种尊敬，你反而应该感谢他热切地想帮助你。 结束语 The tools we use have a profound influence on our thinking habits, and therefore, on our thinking abilities. ---from Edsger Dijkstra, 1972 Turing Awards receiver 我们使用的工具深刻地影响着我们的思维习惯，因此，也深刻影响着我们的思维能力。 ——艾兹格·迪科斯彻，1972年图灵奖得主]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解：约瑟夫环问题]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E9%A2%98%E8%A7%A3%EF%BC%9A%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[约瑟夫是一个无聊的人 题解：约瑟夫环问题 Guderian出品 题目背景据说著名犹太历史学家 Josephus有过以下的故事：在罗马人占领乔塔帕特后，39个犹太人与Josephus及他的朋友躲在一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。然而Josephus 和他的朋友并不想遵从。问题是，给定了总人数n和报数值m，一开始要站在什么地方才能避免被处决？Josephus要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。 题目描述n个人(n&lt;=100)围成一圈,从第一个人开始报数,数到m的人出列,再由下一个人重新从1开始报数,数到m的人再出圈,……依次类推,直到所有的人都出圈,请输出依次出圈人的编号。 输入格式n m 输出格式出圈的编号 输入输出样例输入 #1110 3 输出 #113 6 9 2 7 1 8 5 10 4 说明/提示m, n ≤ 100 解题方法解法一：模拟 + 指针模拟链表时间复杂度：$O(m * n)$ 1234567891011121314151617181920212223242526272829303132333435363738//Run on C++#include &lt;cstdio&gt;using namespace std;struct node&#123; int data; node* next;&#125;;int n, m;node *head, *p, *r; //head为头结点，p表示新节点，r表示当前节点int main()&#123; scanf("%d%d", &amp;n, &amp;m); head = new node; head-&gt;data = 1; head-&gt;next = NULL; r = head; for (int i = 2; i &lt;= n; i++) &#123; p = new node; p-&gt;data = i; p-&gt;next = NULL; r-&gt;next = p; r = p; &#125; r-&gt;next = head; r = head; //使链表首尾相连 for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m - 2; j++) r = r-&gt;next; printf("%d ",r-&gt;next-&gt;data); r-&gt;next = r-&gt;next-&gt;next; r = r-&gt;next; &#125; return 0;&#125; 解法二：模拟 + 数组模拟链表 时间复杂度：$O(m * n)$ 123456789101112131415161718192021//Run on C++#include &lt;cstdio&gt;int nxt[110];int n, m;int main()&#123; scanf("%d%d", &amp;n,&amp;m); for (int i = 1; i &lt;= n; i++) nxt[i] = i + 1; nxt[n] = 1; //使链表首尾相连 int pos = 1; //当前位置 for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m - 2; j++) pos = nxt[pos]; printf("%d ", nxt[pos]); nxt[pos] = nxt[nxt[pos]]; pos = nxt[pos]; &#125; return 0;&#125; 解法三：模拟 + 数组时间复杂度：$O(m * n)$ 12345678910111213141516171819202122232425262728//Run on C++#include &lt;cstdio&gt;int m, n;int a[110];int main()&#123; scanf("%d%d", &amp;n, &amp;m); int t = 1, i = 1, cnt = 0; //t为出去的人的数量，i为数组下标索引，cnt为计数器 while(t &lt;= n) &#123; if(i == n + 1) i = 1; //到了最后一个重新从第一个开始 if(a[i] == 0) &#123; cnt++; if(cnt == m) //到了第m个开始新一轮计数 &#123; a[i] = 1; cnt = 0; t++; printf("%d ",i); &#125; &#125; i++; &#125; return 0;&#125; 解法四：模拟 + 队列时间复杂度：$O(m * n)$ 1234567891011121314151617181920//Run on C++#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;queue &lt;int&gt; q;int n,m;int main()&#123; scanf("%d%d",&amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) q.push(i); while(!q.empty()) &#123; for(int i = 1; i &lt; m; i++) q.push(q.front()), q.pop(); //每数一个就把它放到队尾 printf("%d ",q.front()); q.pop(); //队头出圈 &#125; return 0;&#125; 注： 你也可以不用stl提供的队列，自己编写一个队列 你也可以用stl提供的双端队列deque，不过据笔者观察除了装逼效果之外并没有其他用处 解法五：递归（运用递推公式）时间复杂度：$O(n^2)$ 1234567891011121314151617//Run on C++#include &lt;cstdio&gt;int n, m;int Josephus(int x, int y, int z)&#123; if (z == 1) return (y - 1) % x; return (Josephus(x - 1, y, z - 1) + y) % x;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) printf("%d ", Josephus(n, m, i) + 1); return 0;&#125; 解法六：迭代（运用递推公式）时间复杂度：$O(n^2)$ 123456789101112131415161718//Run on C++#include &lt;cstdio&gt;int n, m;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; int ans; for (int j = 1; j &lt;= i; j++) if (j == 1) ans = (m - 1) % (n - i + j); else ans = (ans + m) % (n - i + j); printf("%d ", ans + 1); &#125; return 0;&#125; 推导递推公式*以解法五为例，在递归函数部分代码中 12345int Josephus(int x, int y, int z)&#123; if (z == 1) return (y - 1) % x; return (Josephus(x - 1, y, z - 1) + y) % x;&#125; x代表总人数，y代表每次报y的人出列，z是次数，该函数可以求第y次出圈的人的编号。 举个例子：总人数x为6人，从1开始，每报到3就出圈（z = 3） 初始情况：1 2 3 4 5 6 通过递推的方式使第一个幸运观众出圈之后：1 2 4 5 6 此时，这些编号已经不能组成一个环，但是2和4之间还是连着的，且下一次报数将从4开始。然而，之后的报数将总要考虑3处的空位问题。 如何避免空位对报数所造成的影响？ 可以将剩下的4个数重新组合成一个新的环，这样报数的时候就不必在意3的空缺了。但是新产生的环的数字并非连续的，报数时不能直接用+ y再% x的简单递推方式，这下真令人头大。 如何使新环上的编号依然能够递推？ 可以建立一种有确定规则的映射，要求映射之后的数字可以递推，且可以将在新环中继续按原规则报数得到的结果逆推出在旧环中的对应数字。 阻止我们使用老办法递推的因素就是3号出圈之后产生的新环编号不连续，那么，我们可以通过建立某种映射，使得新环的编号依然连续，方便我们继续使用递推的方法。 原始：1 2 3 4 5 6 旧环：1 2 _ 4 5 6 新环：4 5 _ 1 2 3 正如你所见，相比于旧环中2和4之间被割裂开，新环的5和1之间在对5取余的基础上是完美连续的，这就意味着我们可以继续从新环的1（即旧环的4）开始实施我们的递推方法。且只要推导出新环与旧环的映射关系，就能从在新环中报数的结果得知在旧环中的报数结果。 对于第二个幸运观众： 旧环：1 2 _ 4 5 *6 新环：4 5 _ 1 2 *3 如何从新环的3得到旧环的6呢？其实可以简单地逆推回去 : 新环是由(旧环中编号 - 报数值) % 旧环总人数得到的，所以逆推时可以由(新环编号 + 报数值) % 旧环总人数得到。 如：(3 + 3) % 6 = 0 咦？奇怪怎么是0？不是应该是6吗？这就涉及到一个进位的问题。由于旧环的编号为1~6，而我们在新环依然保留了1~5的编号并确保5和1之间在对5取余的基础上连续，这就导致了5 % 5 = 0，也就是说5与0是无法区分的。因此，虽然实际上旧环编号为6的幸运观众出圈，但是我们的计算结果依然不可避免地把它对6取余，得到一个看似奇怪却又顺理成章的0。 如何避免错误地把最大的数算成0的情况？ 把所有数减1即可，最后输出结果的时候再加上1。让我们再来一遍： 对于第二个幸运观众： 旧环：0 1 _ 3 4 *5 新环：3 4 _ 0 1 *2 从新环推出旧环的幸运观众：(2 + 3) % 6 = 5 由上得，原序列x中第二次出圈的编号可以由新序列x - 1第一次出圈的编号通过特定的逆推运算得出。即在以y为出环报数值的约瑟夫环中，x人环的第z次出环编号可以由x - 1人环中的第z - 1次出环编号通过也定的运算推出。 幸运的是，第一次出环的编号是可以直接求出的，也就是说，对于任意次出环的编号，我们可以将之一直转化为第一次出环的编号问题，再一一迭代求出；也可以把第一次出环的编号作为递归基础，通过递归求出。 因此我们可以写出Josephus函数的递推公式如下： Josephus(x,y,z) = \begin{cases} [Josephus(x-1,y,z-1) + y] \% x ,& \text{z > 1} \\ (y-1)\%x , & \text{z = 1} \end{cases}结束语以上就是关于约瑟夫环问题的六种解法，并送上调试过的C++代码，作者水平不高，将就看看吧 ╮(╯_╰)╭ *. 参考该网站，感谢作者的写作 &#8617;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>C-plus-plus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++指针变量]]></title>
    <url>%2FG-SS-Hacker.github.io%2Fc-%E6%8C%87%E9%92%88%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[指针变量 Guderian出品 指针变量的定义、赋值对指针变量的类型说明，一般形式为： 类型说明符 *变量名; 其中，表示这是一个指针变量，变量名即为定义的指针变量名，类型说明符表示*该指针变量所指向的变量的数据类型。 1、普通变量定义int a = 3; 定义了变量a，是int型的，值为3。内存中有一块内存空间是放a的值，对a的存取操作就是直接到这个内存空间存取。内存空间的位置叫地址，存放3的地址可以用取地址操作符&amp;对a运算得到：&amp;a。 2、指针变量定义int *p = NULL; 定义了一个指针变量p，p指向一个内存空间，里面存放的是一个内存地址。现在赋值为NULL（其实就是0，表示特殊的空地址）。 3、给指针变量p赋值p = &amp;a; 即把a变量的内存空间地址（比如：XXX）给了p。显然，直接对p存取，操作的是地址。通过这个地址间接地操作，才是整数3。P的间接操作要使用指针操作符“*”，即*p的值才是3。设有指向整型变量的指针变量p，如要把整型变量a的地址赋予p可以有以下两种方式： ①指针变量初始化的方法 int a; int *p = &amp;a; ②赋值语句的方法 int a; int *p; p = &amp;a; 不允许把一个数赋予指针变量，故如下的赋值是错误的：int *p；p = 1000；。被赋值的指针变量前不能再加“*”说明符，故如下的赋值也是错误的：*p = &amp;a；。 指针的几个相关操作说明表| 说明 | 样例 || ————————————————— | ————————————————|| 指针定义：类型说明符 *指针变量名 | int *p; || 取地址运算符：&amp; | p = &amp;a; || 间接运算符：* | *p = 20; || 指针变量直接存取的是内存地址 | cout&lt;&lt;p;结果可能是：0x24ae9d || 间接存取的才是存储类型的值 | cout&lt;&lt;*p;结果是：20 | 指针变量同普通变量一样，使用之前不仅要定义说明，而且必须被赋值具体的值，未经赋值的指针变量不能使用。如定义了int a; int *p = &amp;a;，则*p表示p指向的整型变量，而p中存放的是变量a占用单元的起始地址，所以*p实际上访问了变量a，也就是说*p$ \Longleftrightarrow $a。 【例1】输入两个不同的数，通过指针对两个数进行相加和相乘，并输出。 123456789101112131415#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; int a, b, s, t, *pa, *pb; pa = &amp;a; pb = &amp;b; a = 10; b = 20; s = *pa + *pb; t = *pa * *pb; printf("a = %d, b = %d\n", *pa, *pb); printf("s = %d, t = %d\n", s, t); return 0;&#125; 输出： 12a = 10, b = 20s = 30, t = 200 指针的引用与运算一般的，指针(int *p)与普通变量(int a)的对应关系为： 指针变量 普通变量 p &amp;a *p a *p = 3 a = 3 以下为指针的一些运算： 1、指针变量的初始化指针的几个初始化操作说明表| 方法 | 说明 || ——————————- | ————————————————- || int *p = NULL; | NULL是特殊的地址0，叫零指针 || int a; int *p = &amp;a; | p初始化为a的地址 || int *p = new(int); | 申请一个空间给p，*p内容不确定 | 要强调的是，对于定义的局部指针变量，其内容（地址）是随机的，直接对它操作可能会破坏程序或系统内存的值，引发不可预测的错误。所有编程中指针变量要保证先初始化或赋值，给予正确的地址再使用，避免产生*野指针。 2、指针变量的+、-运算指针变量的内容是内存地址，它有两个常用的运算：加、减，这两个运算一般都是配合数组操作的。 【例2】输入N个整数，使用指针变量访问输出。 123456789101112131415161718#include &lt;cstdio&gt;using namespace std;int a[101], n;int main()&#123; scanf("%d",&amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); int p = &amp;a[1]; //定义指针变量int p，初始化为数组开始元素的地址，即a[1]; for (int i = 1; i &lt;= n; i++) &#123; printf("%d ", *p); p++; //p指向下一个数，详见说明 &#125; return 0;&#125; 输入： 1242 1 6 0 输出： 12 1 6 0 【说明】 p++的意思是“广义的加1”，不是p的值（地址）加1，而是根据类型int增加sizeof（int），即刚好“跳过”一个整数的空间，达到下一个整数。 类似的： ①p--就是向前“跳过”一个整数的空间，达到前一个整数。 ②(p + 3)就是指向后面第3个整数的地址。 3、无类型指针有时候，一个指针根据不同的情况，指向的内容是不同类型的值，我们可以先不明确定义它的类型，只是定义一个无类型的指针，以后根据需要再用强制类型转换的方法明确它的类型。 【例3】无类型指针运用举例。 123456789101112131415#include &lt;iostream&gt;using namespace std;int a = 10;double b = 3.5;void *p;int main()&#123; p = &amp;a; //p的地址赋值 cout&lt;&lt;*(int*)p&lt;&lt;endl; //必须明确p指向的空间的数据类型，详见说明 p = &amp;b; cout&lt;&lt;*(double*)p&lt;&lt;endl; return 0;&#125; 输出： 12103.5 【说明】 必须明确p指向的空间的数据类型，类型不一样的不仅空间大小不相同，储存的格式也不同。如果把cout&lt;&lt;*(double*)p&lt;&lt;endl;改成cout&lt;&lt;*(long long*)p&lt;&lt;endl;输出的结果将是：4615063718147915776。 4、多重指针既然指针是指向其他类型的，指针本身也是一种类型。因此，C++允许递归地指针指向指针的指针——多重指针。 【例4】双重指针运用举例。 1234567891011121314#include &lt;cstdio&gt;using namespace std;int a = 10;int *p;int **pp; //定义双重指针int main()&#123; p = &amp;a; //将p指向a pp = &amp;p; //将pp指向p printf("%d = %d = %d\n", a, *p, **pp); //**pp通过2次间接访问了a的变量的值10 return 0;&#125; 输出： 110 = 10 = 10 【说明】 多重指针可以多次“间接”访问数据；竞赛上主要的应用是*动态的多维数组，功能十分强大！！！]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C-plus-plus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[野指针的产生及其危害]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E9%87%8E%E6%8C%87%E9%92%88%E7%9A%84%E4%BA%A7%E7%94%9F%E5%8F%8A%E5%85%B6%E5%8D%B1%E5%AE%B3%2F</url>
    <content type="text"><![CDATA[野指针的产生及其危害 Guderian出品 野指针指向了一块随机内存空间，不受程序控制。如指针指向已经被删除的对象或者指向一块没有访问权限的内存空间，之后如果对其再进行引用的话，就会出现问题。 成因指针变量未初始化任何指针变量（无static修饰的局部变量）刚被创建时不会自动成为*NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。如果没有初始化，编译器会报错。 注：NULL指针是一个定义在标准库中的值为零的常量，其定义为： 1#define NULL ((void *)0) 指针释放之后未置空又是指针在free或delete后未赋值NULL，便会使人以为是合法的。然而free和delete只是把指针所指的内存给释放掉，并没有把指针本身干掉。此时指针指向的是随机内存空间。释放指针后应立即将指针置为NULL，防止产生野指针。 指针操作超越变量作用域返回或引用指向*栈内存的指针，因为栈内存在函数结束的时候会被释放 后果 指向不可访问地址，造成程序异常终止 指向可用空间，但是这块空间不适用，程序正常运行 指向可用空间，但是这块空间刚好在用，造成数据错误 规避初始化时置NULL指针变量一定要初始化为NULL，因为任何指针变量（无static修饰的局部变量）刚被创建时不会自动成为NULL指针，它的缺省值是随机的。 释放时置NULL当指针p指向的内存空间释放时，没有设置指针p的值为NULL。delete和free只是把内存空间释放了，但是并没有将指针p的值赋为NULL。通常判断一个指针是否合法，都是使用if语句测试该指针是否为NULL。例如（针对C++）： 123int *p = new int(6);delete p;if(p != NULL) *p = NULL; 或者使用宏定义来一次性解决问题： 1#define del(x) delete(x); x = NULL]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C-plus-plus</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python运算符优先级]]></title>
    <url>%2FG-SS-Hacker.github.io%2FPython%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[Python运算符优先级 Guderian出品 .tg {border-collapse:collapse;border-spacing:0;}.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg .tg-ncd7{background-color:#ffffc7;border-color:inherit;text-align:left;vertical-align:top}.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top} 运算符描述 Python运算符 优先级 （*不常用） 索引运算符 x[index] 或x[index:index2[:index3]] 18、19 （*不常用） 属性访问 x.attribute 17 算术运算符 乘方 ** 16 位运算符 按位取反 ~ 15 符号运算符 +（正号）或 -（负号） 14 算术运算符 乘、除 *、/、//、% 13 加、减 +、- 12 位运算符 位移 &gt;&gt;、&lt;&lt; 11 按位与 &amp; 10 按位异或 ^ 9 按位或 | 8 比较运算符 ==、!=、&gt;、&gt;=、&lt;、&lt;= 7 身份运算符 is、is not 6 成员运算符 in、not in 5 逻辑运算符 逻辑非 not 4 逻辑与 and 3 逻辑或 or 2]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C & C++ memset]]></title>
    <url>%2FG-SS-Hacker.github.io%2FC%E5%92%8CC-%E4%B8%ADmemset%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[想更方便地初始化吗？Just use memset()!!! C/C++ memset() Guderian出品 头文件 C： &lt;string.h&gt; C++： &lt;cstring&gt; 声明void *memset(void *str, int c, size_t n) 此处size_t变量类型等价于long unsigned int即无符号长整型，在32位机器上为32位，在64位机器为中64位。 注：32位机器指CPU通用寄存器的数据宽度为32位，也就是说CPU一次可以运行32bit数据 描述复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。 参数 str ——指向要填充的代码块 c——要被设置的值该值以 int 形式传递，但是函数在填充内存块时是使用该值的无符号字符形式。 n——要被设置为该值的字节数。 返回值返回一个指向存储区 str 的指针。 实例对字符串操作123456789101112131415#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main ()&#123; char str[50]; strcpy(str,"This is string.h library function"); puts(str); memset(str,'$',7); puts(str); return(0);&#125; 编译并运行以上程序，得到结果如下： 12This is string.h library function$$$$$$$ string.h library function 初始化数组注意：c接收参数的范围0-255 ，该函数只能取c的后八位赋给你所指定的范围的每个字节 初始化为0memset(arr, 0, sizeof(arr)); 初始化为-1memset(arr, -1, sizeof(arr));或memset(arr, 0x7fffffff,sizeof(arr)); 初始化为正无穷 理论上的正无穷：memset(arr, 0x7f, sizeof(arr)); 实际使用的正无穷：memset(arr, 0x3f, sizeof(arr)); 注：D（decimal）——十进制，B（binary）——二进制，O（octor）——八进制，H（hex）——十六进制 初始化为负无穷 理论上的负无穷：memset(arr, 0x80, sizeof(arr)); 实际使用的负无穷：memset(arr, 0xbf, sizeof(arr)); 注：此处要设置的值也可用二进制表示，如0xbf等价于0b10111111]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>C-plus-plus</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构绪论]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[基本概念与术语、逻辑结构与物理结构、抽象数据类型 数据结构绪论 Guderian出品 基本概念与术语数据数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅包括整型、实数型等数值类型，还包括字符及声音、图像、视频等非数值类型（严格地说，布尔型也属于数据）。 综上，我们这里说的数据，其实就是符号，且必须具备两个前提： 可以输入到计算机中 能被计算机程序处理 数据元素数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。 数据项数据项：数据不可分割的最小单位。但在真正讨论问题时，数据元素才是数据结构中建立数据模型的着眼点。 数据对象数据对象：性质相同的数据元素的集合，是数据的子集。 数据结构数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。 逻辑结构与物理结构逻辑结构逻辑结构：是指数据对象中数据元素之间的相互关系。 集合结构：地位平等、同属于一个集合。 线性结构：一对一。 树形结构：一对多。 图形结构：多对多。 逻辑结构针对具体问题，是为了解决某个问题，在对问题理解的基础上，选择一个合适的数据结构表示数据元素之间的逻辑关系。 物理结构物理结构（有名存储结构）：数据的逻辑结构在计算机中的存储形式。 顺序存储结构：地址连续的存储单元。 链式存储结构：任意的存储单元。 抽象数据类型数据类型数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。 数据类型可分两类： 原子类型：不可分解，如整形、实型、字符型。 结构类型：可分解，如整型数组、字符串。 抽象数据类型抽象数据类型（Abstract Data Type）：是指一个数学模型及定义在该模型1及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性。而与其在计算机内部如何表达和实现无关。 抽象：抽取出事物具有的普遍性的本质。”抽象“的意义在于数据类型的数学抽象特性。 抽象数据类型不仅指那些已经定义并实现的数据类型（如整型），还可以是计算机编程者在设计软件程序时自己定义的数据类型（如三维坐标(x, y, z)）。 描述抽象数据类型的标准格式： 12345678910ADT 抽象数据类型Data 数据类型之间逻辑关系的定义Operation 操作1 初始条件 操作结果描述 操作2 ……endADT]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算思维导论]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E8%AE%A1%E7%AE%97%E6%80%9D%E7%BB%B4%E5%AF%BC%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[计算思维的本质是抽象与自动化 计算思维导论 Guderian出品 计算思维的发展 计算机的思维：计算机室如何工作的？计算机的功能是如何越来越强大的? 利用计算机的思维：现实世界的各种食物如何利用计算机进行控制和处理？ 计算思维：利用计算机科学的基础概念去求解问题、设计系统和理解人类行为，其本质是抽象与自动化。 学习步骤 概念与知识 联想与贯通 练习与实践 人计算与机器计算的差别人计算： 规则可能很复杂，但计算量却可能很小 人需要知道具体的计算规则 只能使用特定规则 机器计算（自动计算）： 规则可能很简单，但计算量却可能很大 机器也可以使用人的计算规则 使用一般性的规则 自动计算要解决的几个问题：表示-存储-执行 数据的表示 计算规则的表示 数据与计算规则的自动存储 计算规则的自动执行 自动计算的发展历程 如算盘（计算辅助工具）：可以表示数据，不能自动计算 帕斯卡机械计算机：自动计算，固定的计算规则 巴贝奇机械计算机：特定程序，可有限变化的计算规则 现代电子计算机：一般程序，任意可变的计算规则 电子计算机元器件的发展 电子管 晶体管 集成电路 超大规模集成电路（VLSI） 计算机系统的组成 运算器 控制器 存储器 输入设备 输出设备 计算机系统的发展趋势 微型化：可嵌入，可携带 大型化：可进行大规模复杂计算 智能化：理解自然语言，具有自适应性，自主完成复杂功能 网络化：机-机相连，物-物相连，物-人相连，人-人相连，如：IoT，IBM提出”智慧地球”]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>计算思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown需要转义的字符及其转义方法]]></title>
    <url>%2FG-SS-Hacker.github.io%2FMarkdown%E9%9C%80%E8%A6%81%E8%BD%AC%E4%B9%89%E7%9A%84%E5%AD%97%E7%AC%A6%E5%8F%8A%E5%85%B6%E8%BD%AC%E4%B9%89%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Markdown需要转义的字符及其转义方法 Guderian出品 123456789101112\\ 反斜杠\` 反引号\* 星号\_ 下划线\&#123;\&#125; 大括号\[\] 中括号\(\) 小括号\# 井号\+ 加号\- 减号\. 英文句号\! 感叹号]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Python的坑]]></title>
    <url>%2FG-SS-Hacker.github.io%2F%E5%85%B3%E4%BA%8EPython%2F</url>
    <content type="text"><![CDATA[关于Python Guderian出品 学习步骤： [ ] 配置环境，安装Python IDLE [ ] Variale（变量）：int（整形），float（浮点型），str（字符串），bool（布尔型） [ ] Data Type（数据类型）：Number（数字），String（字符串），List（列表），Tuple（元组），Set（集合），Dictionary（字典） [ ] 运算符及其优先级 [ ] 分支和循环 换行符号：\n BIF == Built-in function（__builtins__），即内置函数 Python是动态类型语言、脚本语言（编写速度很快） 变量不能以数字开头且区分大小写 字符串可用单引号或双引号表示 转义字符：\甚至可以转义自身 原始字符串：r&#39;...&#39; 小数达到16位及以上时使用E计数法 配合random模块，random.choice()可从一个非空序列中随机获取一个元素 isinstance(a,b)验证变量a的类型是否是b 保留小数数位round(a,b)：对小数a保留b位（b == 0则为x.0) 格式化输出：输出a，保留x位小数 print(‘%.xf’ %a)，中间无逗号 三元操作符：（非常容易出错）： a = x if 条件 else y assert（断言），当关键字右面条件为真时没有反应，为假时程序自动崩溃并抛出AssertionError异常 Int / int会得到float，哪怕不带小数点，千万注意 print得到的东西会自带换行，要避免的话：print(输出, end = ‘’) 短路逻辑：A and B，如果A == False，那么不判断B直接返回False 可迭代对象：列表、元组、字典、文件、集合、生成器 使用max()和min()要保证序列的数据类型统一 sorted()返回一个排好序的列表 reverse()返回一个翻转的迭代器对象 enumerate()生成由二元组构成的一个迭代对象，每个二元组由迭代参数索引号及对应元素组成 zip(iter1,iter2,...)返回各个可迭代参数共同构成的元组，取最短，分先后 在定义函数的时候，位置参数必须在默认参数的前面，否则就会出错 星号（）在形参中的作用是“打包”，在实参中的作用是“*解包” and和or操作符的用法说明：3 and 4返回后一个4，3 or 4返回前一个3 `print`的参数：`print(*object, sep=' ', end='\n', file=sys.stdout, flush=False)` 函数内部只能访问全局变量，不能修改，非要修改可以使用global关键字声明，但不可用于嵌套函数 Python 模块(Module)，是一个 Python 文件，以 .py 结尾，包含了 Python 对象定义和Python语句 dir(模块)返回的列表容纳了在一个模块里定义的所有模块，变量和函数 Python中的整数区间均为左闭右开，负数区间均为左闭右闭 要完成列表的拷贝必须用分片，即了lis1 = lis2[:]，绝不可以直接lis1 = lis2，因为变量名是“贴”在变量上的，变量名与变量之间并非一一对应关系 列表解析式（或列表推导式）：[有关A的解析式 for A in B]]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2FG-SS-Hacker.github.io%2Fhello-world%2F</url>
    <content type="text"><![CDATA[多种语言实现Hello World Starter Guderian出品 Python1print("hello world") C123456#include&lt;stdio.h&gt;int main()&#123; printf("hello world"); return 0;&#125; C++12345678#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; cout&lt;&lt;"hello world"; return 0;&#125; C#123456789using System; class TestApp &#123; public static void Main() &#123; Console.WriteLine("hello world"); Console.ReadKey(); &#125; &#125; Pascal1234Program HelloWorld(output); begin writeln('hello world') end. Java1234567public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println("hello world"); &#125; &#125;]]></content>
  </entry>
</search>
